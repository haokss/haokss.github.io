<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Log4cpp</title>
    <link href="/2024/08/03/Log4cpp/"/>
    <url>/2024/08/03/Log4cpp/</url>
    
    <content type="html"><![CDATA[<h3 id="1、Log4cpp概述"><a href="#1、Log4cpp概述" class="headerlink" title="1、Log4cpp概述"></a>1、Log4cpp概述</h3><p>​      Log4cpp是一个开源的C++类库，它提供了C++程序中使用日志和跟踪调试的功能，它的优点如下：提供应用程序运行上下文，方便跟踪调试；可扩展的、多种方式记录日志，包括命令行、文件、回卷文件、内存、syslog服务器、Win事件日志等；</p><h3 id="2、原理"><a href="#2、原理" class="headerlink" title="2、原理"></a>2、原理</h3><p>​      Log4cpp有三个主要的组件：日志类别（Category）、输出源（Appender）和布局（Layout）。这三种类型的组件一起工作使得系统可以根据信息的类型和级别记录它们，并且在运行时控制这些信息的输出格式和位置。</p><img src="/2024/08/03/Log4cpp/b3d70f2fb3a9c34b42dc35c53da3befc.png" class=""><h3 id="3、三个组件的介绍："><a href="#3、三个组件的介绍：" class="headerlink" title="3、三个组件的介绍："></a>3、三个组件的介绍：</h3><p>1）<strong>日志类别（Category）</strong>含义是：日志级别的意思是低于该级别的日志不会被记录。但如果配置的级别是ERROR,则只有高于ERROR优先级的日志才可以打印出来。</p><p>日志的级别总共有：</p><blockquote><p>NOTSET &lt; DEBUG &lt; INFO &lt; NOTICE &lt; WARN &lt; ERROR &lt; CRIT &lt; ALERT &lt; FATAL &#x3D; EMERG</p></blockquote><p>2）<strong>输出源（Appender）</strong>用来输出日志（被layout格式化后）到一些设备上，比如文件、命令行、内存等。也可以定义自己的appender输出日志信息到别的设备上。log4cpp提供的appender如下： FileAppender  输出到文件 RollingFileAppender 输出到回卷文件，即当文件到达某个大小后回卷 ConsoleAppender 输出到控制台</p><p>3）<strong>布局（Layout）</strong>显示样式PatternLayout表示让用户根据类似于C语言printf函数的转换模式来指定输出格式</p><p>PatternLayout支持以下一组格式字符:</p><ul><li>%% - 一个百分号；</li><li>%c - the category；</li><li>%d - date日期格式:日期格式字符后面可以跟着花括号括起来的日期格式说明符。例如<code>%d &#123;% H: % M: % S、l %&#125;或%d &#123;% d % M H % Y %: % M: % S、l %&#125;</code>。如果没有给出日期格式说明符，则使用以下格式:”Wed Jan 02 02:03:55 1980”。</li><li>%m - 你要输出的日志信息；</li><li>%n - 换行符；</li><li>%p - 优先级；</li><li>%r - 该布局创建后的毫秒数；</li><li>%R - 从1970年1月1日0时开始到目前为止的秒数；</li><li>%u - 进程开始到目前为止的时钟周期数；</li><li>%x - the NDC；</li><li>%t - 线程的名字；</li><li>默认情况下，PatternLayout的ConversionPattern设置为“%m%n”。</li></ul><p><strong>三个组件之间的关系</strong></p><p>Category和Appender的关系是：多个Appender可以附加到一个Category上，这样一个日志消息可以同时输出到多个设备上。<br>Appender和Layout的关系是：Layout附加在Appender上，appender调用layout处理完日志消息后，记录到某个</p><h3 id="4、官方案例"><a href="#4、官方案例" class="headerlink" title="4、官方案例"></a>4、官方案例</h3><h4 id="官方属性配置解析"><a href="#官方属性配置解析" class="headerlink" title="官方属性配置解析:"></a>官方属性配置解析:</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># log4cpp.properties</span><br><span class="hljs-comment"># 设置根日志器配置,并设置其附加器为rootAppender,日志等级为DEBUG</span><br><span class="hljs-attr">log4cpp.rootCategory</span>=<span class="hljs-string">DEBUG, rootAppender</span><br><span class="hljs-comment"># 配置名为sub1的子日志器, 并设置附加器为A1, A2, 日志等级为DEBUG</span><br><span class="hljs-attr">log4cpp.category.sub1</span>=<span class="hljs-string">DEBUG, A1, A2</span><br><span class="hljs-comment"># 配置sub2为sub1的子日志器,并设置附加器A3, 日志等级也为DEBUG</span><br><span class="hljs-attr">log4cpp.category.sub1.sub2</span>=<span class="hljs-string">DEBUG, A3</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 设置rootAppender的附加器,并设置其输出位置为控制台和自定义布局模式</span><br><span class="hljs-attr">log4cpp.appender.rootAppender</span>=<span class="hljs-string">ConsoleAppender</span><br><span class="hljs-attr">log4cpp.appender.rootAppender.layout</span>=<span class="hljs-string">PatternLayout</span><br><span class="hljs-attr">log4cpp.appender.rootAppender.layout.ConversionPattern</span>=<span class="hljs-string">%d [%p] %m%n </span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 设置A1这个附加器输出到名为A1.log的文件中, 布局为基本布局</span><br><span class="hljs-attr">log4cpp.appender.A1</span>=<span class="hljs-string">FileAppender</span><br><span class="hljs-attr">log4cpp.appender.A1.fileName</span>=<span class="hljs-string">A1.log</span><br><span class="hljs-attr">log4cpp.appender.A1.layout</span>=<span class="hljs-string">BasicLayout</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 设置A2这个附加器也是文件附加,级别为WARN, 输出到文件A2.log, 并且自定义布局</span><br><span class="hljs-attr">log4cpp.appender.A2</span>=<span class="hljs-string">FileAppender</span><br><span class="hljs-attr">log4cpp.appender.A2.threshold</span>=<span class="hljs-string">WARN</span><br><span class="hljs-attr">log4cpp.appender.A2.fileName</span>=<span class="hljs-string">A2.log</span><br><span class="hljs-attr">log4cpp.appender.A2.layout</span>=<span class="hljs-string">PatternLayout</span><br><span class="hljs-attr">log4cpp.appender.A2.layout.ConversionPattern</span>=<span class="hljs-string">%d [%p] %m%n </span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 设置A3附加模式为写入文件的滚动附加,日志名为A3.log,日志最多200字节</span><br><span class="hljs-comment"># 同时保留一份备份日志文件,使用自定义布局</span><br><span class="hljs-attr">log4cpp.appender.A3</span>=<span class="hljs-string">RollingFileAppender</span><br><span class="hljs-attr">log4cpp.appender.A3.fileName</span>=<span class="hljs-string">A3.log</span><br><span class="hljs-attr">log4cpp.appender.A3.maxFileSize</span>=<span class="hljs-string">200</span><br><span class="hljs-attr">log4cpp.appender.A3.maxBackupIndex</span>=<span class="hljs-string">1</span><br><span class="hljs-attr">log4cpp.appender.A3.layout</span>=<span class="hljs-string">PatternLayout</span><br><span class="hljs-attr">log4cpp.appender.A3.layout.ConversionPattern</span>=<span class="hljs-string">%d [%p] %m%n </span><br></code></pre></td></tr></table></figure><h4 id="官方源文件"><a href="#官方源文件" class="headerlink" title="官方源文件"></a>官方源文件</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// main.cpp</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;log4cpp/Category.hh&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;log4cpp/PropertyConfigurator.hh&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>std::string initFileName = <span class="hljs-string">&quot;log4cpp.properties&quot;</span>;<br>log4cpp::PropertyConfigurator::<span class="hljs-built_in">configure</span>(initFileName);<br><br>log4cpp::Category&amp; root = log4cpp::Category::<span class="hljs-built_in">getRoot</span>();<br><br>log4cpp::Category&amp; sub1 = <br>log4cpp::Category::<span class="hljs-built_in">getInstance</span>(std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;sub1&quot;</span>));<br><br>log4cpp::Category&amp; sub2 = <br>log4cpp::Category::<span class="hljs-built_in">getInstance</span>(std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;sub1.sub2&quot;</span>));<br><br>root.<span class="hljs-built_in">warn</span>(<span class="hljs-string">&quot;Storm is coming&quot;</span>);<br><br>sub<span class="hljs-number">1.</span><span class="hljs-built_in">debug</span>(<span class="hljs-string">&quot;Received storm warning&quot;</span>);<br>sub<span class="hljs-number">1.</span><span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;Closing all hatches&quot;</span>);<br><br>sub<span class="hljs-number">2.</span><span class="hljs-built_in">debug</span>(<span class="hljs-string">&quot;Hiding solar panels&quot;</span>);<br>sub<span class="hljs-number">2.</span><span class="hljs-built_in">error</span>(<span class="hljs-string">&quot;Solar panels are blocked&quot;</span>);<br>sub<span class="hljs-number">2.</span><span class="hljs-built_in">debug</span>(<span class="hljs-string">&quot;Applying protective shield&quot;</span>);<br>sub<span class="hljs-number">2.</span><span class="hljs-built_in">warn</span>(<span class="hljs-string">&quot;Unfolding protective shield&quot;</span>);<br>sub<span class="hljs-number">2.</span><span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;Solar panels are shielded&quot;</span>);<br><br>sub<span class="hljs-number">1.</span><span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;All hatches closed&quot;</span>);<br><br>root.<span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;Ready for storm.&quot;</span>);<br><br>log4cpp::Category::<span class="hljs-built_in">shutdown</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="结果"><a href="#结果" class="headerlink" title="结果:"></a>结果:</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">2012</span><span class="hljs-number">-11</span><span class="hljs-number">-14</span> <span class="hljs-number">18</span>:<span class="hljs-number">44</span>:<span class="hljs-number">58</span>,<span class="hljs-number">163</span> [WARN] Storm is coming<br><span class="hljs-number">2012</span><span class="hljs-number">-11</span><span class="hljs-number">-14</span> <span class="hljs-number">18</span>:<span class="hljs-number">44</span>:<span class="hljs-number">58</span>,<span class="hljs-number">166</span> [DEBUG] Received storm warning<br><span class="hljs-number">2012</span><span class="hljs-number">-11</span><span class="hljs-number">-14</span> <span class="hljs-number">18</span>:<span class="hljs-number">44</span>:<span class="hljs-number">58</span>,<span class="hljs-number">170</span> [INFO] Closing all hatches<br><span class="hljs-number">2012</span><span class="hljs-number">-11</span><span class="hljs-number">-14</span> <span class="hljs-number">18</span>:<span class="hljs-number">44</span>:<span class="hljs-number">58</span>,<span class="hljs-number">172</span> [DEBUG] Hiding solar panels<br><span class="hljs-number">2012</span><span class="hljs-number">-11</span><span class="hljs-number">-14</span> <span class="hljs-number">18</span>:<span class="hljs-number">44</span>:<span class="hljs-number">58</span>,<span class="hljs-number">175</span> [ERROR] Solar panels are blocked<br>A<span class="hljs-number">3.l</span>og<span class="hljs-number">.1</span><br><span class="hljs-number">2012</span><span class="hljs-number">-11</span><span class="hljs-number">-14</span> <span class="hljs-number">18</span>:<span class="hljs-number">44</span>:<span class="hljs-number">58</span>,<span class="hljs-number">179</span> [DEBUG] Applying protective shield<br><span class="hljs-number">2012</span><span class="hljs-number">-11</span><span class="hljs-number">-14</span> <span class="hljs-number">18</span>:<span class="hljs-number">44</span>:<span class="hljs-number">58</span>,<span class="hljs-number">183</span> [WARN] Unfolding protective shield<br><span class="hljs-number">2012</span><span class="hljs-number">-11</span><span class="hljs-number">-14</span> <span class="hljs-number">18</span>:<span class="hljs-number">44</span>:<span class="hljs-number">58</span>,<span class="hljs-number">186</span> [INFO] Solar panels are shielded<br><span class="hljs-number">2012</span><span class="hljs-number">-11</span><span class="hljs-number">-14</span> <span class="hljs-number">18</span>:<span class="hljs-number">44</span>:<span class="hljs-number">58</span>,<span class="hljs-number">190</span> [INFO] All hatches closed<br><span class="hljs-number">2012</span><span class="hljs-number">-11</span><span class="hljs-number">-14</span> <span class="hljs-number">18</span>:<span class="hljs-number">44</span>:<span class="hljs-number">58</span>,<span class="hljs-number">192</span> [INFO] Ready <span class="hljs-keyword">for</span> storm.<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++日志库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++</title>
    <link href="/2024/07/31/c++/"/>
    <url>/2024/07/31/c++/</url>
    
    <content type="html"><![CDATA[<p><strong>《总之，好记性不如烂笔头！把你遗忘的都记下来吧！》</strong></p><h2 id="C-基础语法拾遗"><a href="#C-基础语法拾遗" class="headerlink" title="C++基础语法拾遗"></a>C++基础语法拾遗</h2><h4 id="引用的本质"><a href="#引用的本质" class="headerlink" title="引用的本质"></a>引用的本质</h4><p>引用可以理解为变量的别名，不能超脱变量而存在。</p><p>在底层上，引用变量由指针按照指针常量的方式实现。</p><p>（1）在内存中都是占用4个字节（32bits系统中）的存储空间，存放的都是被引用对象的地址，都必须在定义的同时进行初始化。</p><p>（2）指针常量本身（以p为例）允许寻址，即&amp;p返回指针常量（常变量）本身的地址，被引用对象用*p表示；引用变量本身（以r为例）不允许寻址，&amp;r返回的是被引用对象的地址，而不是变量r的地址（r的地址由编译器掌握，程序员无法直接对它进行存取），被引用对象直接用r表示。</p><p>（3）凡是使用了引用变量的代码，都可以转换成使用指针常量的对应形式的代码，只不过书写形式上要繁琐一些。反过来，由于对引用变量使用方式上的限制，使用指针常量能够实现的功能，却不一定能够用引用来实现。<br>例如，下面的代码是合法的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i=<span class="hljs-number">5</span>, j=<span class="hljs-number">6</span>;<br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> array[]=&#123;&amp;i,&amp;j&#125;;<br></code></pre></td></tr></table></figure><p>而如下代码是非法的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i=<span class="hljs-number">5</span>, j=<span class="hljs-number">6</span>;<br><span class="hljs-type">int</span>&amp; array[]=&#123;i,j&#125;;<br></code></pre></td></tr></table></figure><p>也就是说，数组元素允许是指针常量，却不允许是引用。C++语言机制如此规定，原因是避免C++语法变得过于晦涩。假如定义一个“引用的数组”，那么array[0]&#x3D;8;这条语句该如何理解？是将数组元素array[0]本身的值变成8呢，还是将array[0]所引用的对象的值变成8呢?</p><h4 id="static标识符"><a href="#static标识符" class="headerlink" title="static标识符"></a>static标识符</h4><p><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240628132441037.png" alt="image-20240628132441037"></p><h4 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h4><ul><li><h5 id="std-funciton-类对象"><a href="#std-funciton-类对象" class="headerlink" title="std::funciton&lt;&gt; 类对象"></a>std::funciton&lt;&gt; 类对象</h5><p>std::function模板类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::function&lt;<span class="hljs-type">void</span>*(<span class="hljs-type">void</span>)&gt; create_object;<br></code></pre></td></tr></table></figure></li><li><h5 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h5><p>捕获 [&#x3D;, &amp;],</p><p><strong>返回类型推断的规则</strong>：</p><p>编译器在推断lambda表达式的返回类型时，主要依据返回语句的类型。<strong>如果lambda表达式中存在多个返回语句或含有其他非返回语句而未显式指定返回类型，编译器会假定返回类型为</strong> <code>void</code>。<strong>（此时需要尾置返回类型）;</strong></p><p>然而，当lambda表达式的返回类型可以从单一的返回语句中明确推断时，编译器能够自动确定正确的返回类型。</p><p>lambda表达式等价为一个匿名的函数对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// lambda表达式</span><br><span class="hljs-type">int</span> factor = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">auto</span> lambda = [factor](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> x * factor; &#125;;<br><span class="hljs-type">int</span> result = <span class="hljs-built_in">lambda</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// result is 10</span><br><span class="hljs-comment">// 等价的匿名对象</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AnonymousFunctor</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">AnonymousFunctor</span>(<span class="hljs-type">int</span> factor) : <span class="hljs-built_in">factor</span>(factor) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> x * factor;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> factor;<br>&#125;;<br><br><span class="hljs-type">int</span> factor = <span class="hljs-number">2</span>;<br><span class="hljs-function">AnonymousFunctor <span class="hljs-title">lambda</span><span class="hljs-params">(factor)</span></span>;<br><span class="hljs-type">int</span> result = <span class="hljs-built_in">lambda</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// result is 10</span><br></code></pre></td></tr></table></figure></li><li><h5 id="函数对象（仿函数）"><a href="#函数对象（仿函数）" class="headerlink" title="函数对象（仿函数）"></a>函数对象（仿函数）</h5><p>重载了()运算符的类</p></li><li><h5 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h5></li></ul><p>定义一个函数指针，它的名字是create_object，指向返回值为void*，参数为void的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span>* (*create_object)(<span class="hljs-type">void</span>);<br></code></pre></td></tr></table></figure><p>由于<strong>使用了typedef</strong>，它定义一个指向返回值为void*，接收参数为void的<strong>函数指针类型</strong>，并将它重命名为create_object</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">void</span>* (*create_object)(<span class="hljs-type">void</span>);<br></code></pre></td></tr></table></figure><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>回调函数是一个函数指针，通过参数传递给另一个函数。当这个参数函数在某个特定的事件或条件满足时被调用时，这个函数就是回调函数。回调函数广泛应用于事件驱动编程、异步操作和处理某些操作完成后的后续步骤。</p><p>为什么要使用回调：</p><p><strong>解耦逻辑</strong>: 回调函数可以将代码逻辑分离，使得代码更模块化、更易读、更易维护。</p><p><strong>异步操作</strong>: 在处理异步操作（如I&#x2F;O操作、网络请求）时，<strong>回调函数可以在操作完成后执行特定的逻辑，而无需阻塞主程序</strong>。</p><p><strong>事件处理</strong>: <strong>在事件驱动编程中，回调函数用于响应特定的事件（如按钮点击、鼠标移动）</strong>。</p><p><strong>可复用性</strong>: 回调函数可以传递不同的函数，从而实现不同的行为。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 简单的实现</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">// 定义一个回调函数类型</span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*CallbackFunc)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-comment">// 一个执行回调函数的函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">performOperation</span><span class="hljs-params">(<span class="hljs-type">int</span> x, CallbackFunc callback)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Performing operation with value: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>    <span class="hljs-comment">// 调用回调函数</span><br>    <span class="hljs-built_in">callback</span>(x);<br>&#125;<br><span class="hljs-comment">// 回调函数的定义</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myCallback</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Callback called with value: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 调用performOperation并传递回调函数</span><br>    <span class="hljs-built_in">performOperation</span>(<span class="hljs-number">5</span>, myCallback);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h4><h5 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h5><h5 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h5><h5 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a>std::weak_ptr</h5><h5 id="std-make-shared"><a href="#std-make-shared" class="headerlink" title="std::make_shared"></a><strong>std::make_shared</strong></h5><p><a href="https://www.cnblogs.com/leijiangtao/p/12046333.html">C++11使用make_shared的优势和劣势 - 南哥的天下 - 博客园 (cnblogs.com)</a></p><h4 id="std-tuple"><a href="#std-tuple" class="headerlink" title="std::tuple"></a>std::tuple</h4><h4 id="区分初始化和赋值"><a href="#区分初始化和赋值" class="headerlink" title="区分初始化和赋值"></a>区分初始化和赋值</h4><p><strong>初始化</strong>是<strong>创建对象并为其设置初始值的过程</strong>，在这个过程中构造函数，（包括拷贝构造函数和移动构造函数）会被调用。共有两种初始化的方式</p><p>1、直接初始化，利用()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Base <span class="hljs-title">a</span><span class="hljs-params">(b)</span></span>;<br></code></pre></td></tr></table></figure><p>2、复制（拷贝）初始化，利用&#x3D;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Base a = b;<br></code></pre></td></tr></table></figure><p><strong>赋值</strong>是<strong>已经存在</strong>的对象<strong>赋新值</strong>的过程，在这个过程中赋值运算符，（包括拷贝赋值运算符和移动赋值运算符）会被调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 拷贝赋值</span><br>a = b;<br><span class="hljs-comment">// 移动赋值</span><br>a = std::<span class="hljs-built_in">move</span>(b);<br></code></pre></td></tr></table></figure><h4 id="拷贝构造产生的情况"><a href="#拷贝构造产生的情况" class="headerlink" title="拷贝构造产生的情况"></a>拷贝构造产生的情况</h4><ul><li>使用&#x3D;定义变量的时候；</li><li>将对象作为实参传递给一个非引用类型的实参；</li><li>从返回类型为非引用类型的函数中返回一个对象；</li><li>使用花括号列表初始化数组元素或者聚合类成员；</li></ul><p><strong>拷贝构造参数为 const &amp;的原因：</strong></p><ul><li>对于const类型的参数也能传递</li><li>在没有移动构造的情况下能够使用拷贝构造</li></ul><p>一个类的拷贝构造被删除了，那么其移动构造也不会存在</p><h4 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h4><p>1、<strong>算数类型隐式转化：</strong></p><ul><li>在条件中。非布尔值转化为布尔值</li><li>整型提升</li><li>有符号转化为无符号，但不改变内存</li></ul><p>2、<strong>类类型隐式转换：</strong></p><p>如果构造函数只接受一个参数或者接受一个参数其余参数都存在默认值，它实际定义了此类类型隐式类型转换机制，这种构造函数叫做：<strong>转换构造函数</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 支持隐式类型转换的构造函数</span><br>    <span class="hljs-built_in">Rational</span>(<span class="hljs-type">int</span> numerator = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> denominator = <span class="hljs-number">1</span>) <br>        : <span class="hljs-built_in">numerator_</span>(numerator), <span class="hljs-built_in">denominator_</span>(denominator) &#123;<br>        <span class="hljs-keyword">if</span> (denominator_ == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Denominator cannot be zero&quot;</span>);<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> numerator_;<br>    <span class="hljs-type">int</span> denominator_;<br> &#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Rational r = <span class="hljs-number">5</span>;<span class="hljs-comment">// 将int 5隐式转化为Rational</span><br></code></pre></td></tr></table></figure><h4 id="类型转化运算符"><a href="#类型转化运算符" class="headerlink" title="类型转化运算符"></a>类型转化运算符</h4><p>通过实现类型转化运算符来实现，可以实现隐式类型转化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Complex</span>(<span class="hljs-type">double</span> r, <span class="hljs-type">double</span> i) : <span class="hljs-built_in">real</span>(r), <span class="hljs-built_in">imag</span>(i) &#123;&#125;<br>    <span class="hljs-comment">// 类型转换函数：将 Complex 对象转换为 double（表示模）</span><br>    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">sqrt</span>(real * real + imag * imag);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> real;<br>    <span class="hljs-type">double</span> imag;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Complex <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>)</span></span>; <span class="hljs-comment">// 3 + 4i</span><br>    <span class="hljs-type">double</span> magnitude = c; <span class="hljs-comment">// 隐式调用类型转换函数</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Magnitude: &quot;</span> &lt;&lt; magnitude &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="operator-new-delete"><a href="#operator-new-delete" class="headerlink" title="operator new &#x2F; delete"></a>operator new &#x2F; delete</h4><h4 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h4><p>通过将构造函数声明为explicit加以阻止隐式转化，关键字explicit只对一个实参的构造函数有效，需要多个实参的构造函数不能用于执行隐式转换（参数存在默认值的情况除外），也无需将它们声明为explicit的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 不支持隐式类型转换的构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Rational</span><span class="hljs-params">(<span class="hljs-type">int</span> numerator = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> denominator = <span class="hljs-number">1</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>再次尝试进行隐式转化，可以看到被禁止了。</p><p><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240620000907126.png" alt="image-20240620000907126"></p><p>发生隐式转化的情况是我们使用了拷贝初始化，使用explicit禁止后靠被初始化就失效了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Rational <span class="hljs-title">r1</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<span class="hljs-comment">// 直接初始化，正确</span><br>Rational r2 = <span class="hljs-number">5</span>; <span class="hljs-comment">// 使用拷贝初始化，但explicit禁止，错误！</span><br></code></pre></td></tr></table></figure><h4 id="auto自动类型推导"><a href="#auto自动类型推导" class="headerlink" title="auto自动类型推导"></a>auto自动类型推导</h4><p>引用 auto &amp;，捕获指针 auto *</p><h4 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h4><p>内联函数的定义和实现必须在同一个文件下，也就是说inline函数定义放在头文件中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// MyClass.h------错误的内联实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>();<br>    ~<span class="hljs-built_in">MyClass</span>();<br>&#125;;<br><span class="hljs-comment">// MyClass.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-title">MyClass::MyClass</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// Constructor code</span><br>&#125;<br><span class="hljs-keyword">inline</span> MyClass::~<span class="hljs-built_in">MyClass</span>() &#123;<br>    <span class="hljs-comment">// Destructor code</span><br>&#125;<br><span class="hljs-comment">// AnotherFile.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;MyClass.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj; <span class="hljs-comment">// Error: undefined reference to `MyClass::MyClass()`</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><h4 id="重载、隐藏、重写（覆盖）"><a href="#重载、隐藏、重写（覆盖）" class="headerlink" title="重载、隐藏、重写（覆盖）"></a>重载、隐藏、重写（覆盖）</h4><p>1、<strong>重载</strong>：从overload翻译而来，代表具有不同参数列表的同名函数，根据参数列表选择调用哪个函数，不关心函数返回类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>; <span class="hljs-comment">// 参数个数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">double</span> b)</span></span>; <span class="hljs-comment">// 参数类型</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">double</span> a,<span class="hljs-type">int</span> a)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">test</span><span class="hljs-params">(string s)</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// const重载</span><br>...<br></code></pre></td></tr></table></figure><p>2、<strong>隐藏</strong>：对于存在继承关系，且派生类重新定义了基类的方法就会发生隐藏。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Basic</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Basic:Show(void)\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Show</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Basic:Show(int):&quot;</span> &lt;&lt; a &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derive</span> : <span class="hljs-keyword">public</span> Basic<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 重写了基类的show()</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span></span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Derive:Show(void)\n&quot;</span>;<br>    &#125;    <br>    <span class="hljs-comment">// 隐藏了基类的Show(int a)</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    Derive d;<br>    d.<span class="hljs-built_in">Show</span>();<br>    <span class="hljs-comment">// d.Show(3);  // 错误的调用，已经被隐藏</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>3、<strong>重写</strong>：从override翻译而来，又叫覆盖，指派生类中存在重新定义的与基类完全相同的同名函数，未被重写的同名函数将被隐藏，导致派生类不能访问，重写多出现在虚函数中，不是虚函数也可以发生重写。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Basic</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Basic:Show(void)\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Show</span><span class="hljs-params">(<span class="hljs-type">double</span> b, <span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Basic:virtual Show(double,int):&quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; a &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derive</span> : <span class="hljs-keyword">public</span> Basic<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Show</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Derive:Show(void)\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Show</span><span class="hljs-params">(<span class="hljs-type">double</span> b, <span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Derive:virtual Show(double,int):&quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; a &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//父类指正指向子类对象</span><br>    Basic *p = <span class="hljs-keyword">new</span> Derive;<br>    <span class="hljs-comment">//派生类重新定义的基类方法(基类和派生类都有的)</span><br>    p-&gt;<span class="hljs-built_in">Show</span>();            <br>    p-&gt;<span class="hljs-built_in">Show</span>(<span class="hljs-number">3.4</span>, <span class="hljs-number">7</span>);  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="早绑定，晚绑定"><a href="#早绑定，晚绑定" class="headerlink" title="早绑定，晚绑定"></a>早绑定，晚绑定</h4><h4 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h4><h4 id="final禁止继承"><a href="#final禁止继承" class="headerlink" title="final禁止继承"></a>final禁止继承</h4><h4 id="左值、右值、亡值、表达式"><a href="#左值、右值、亡值、表达式" class="headerlink" title="左值、右值、亡值、表达式"></a>左值、右值、亡值、表达式</h4><h4 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h4><blockquote><p>引用折叠只能应用于间接创建的引用的引用，如类型别名或模板参数</p></blockquote><ul><li>X&amp;  &amp;、X&amp;  &amp;&amp;、和X&amp;&amp;  &amp;都折叠成类型X&amp;</li><li>X&amp;&amp;  &amp;&amp; 折叠成类型X&amp;&amp;</li></ul><h4 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h4><p>显式的将一个左值转化为对应的右值引用类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> &amp;&amp;rr1 = <span class="hljs-number">42</span>;<br><span class="hljs-type">int</span> &amp;&amp;rr3 = std::<span class="hljs-built_in">move</span>(rr1);<br></code></pre></td></tr></table></figure><p>定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">typename</span> std::remove_reference&lt;T&gt;::<span class="hljs-function">type&amp;&amp; <span class="hljs-title">my_move</span><span class="hljs-params">(T &amp;&amp;t)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">typename</span> std::remove_reference&lt;T&gt;::type &amp;&amp;&gt;(t);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="std-ref"><a href="#std-ref" class="headerlink" title="std::ref"></a>std::ref</h4><h4 id="std-bind"><a href="#std-bind" class="headerlink" title="std::bind"></a>std::bind</h4><p>为函数绑定参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-comment">// args参数列表 _1,_2 定义在命名空间std::placeholders下可以使用using简化</span><br><span class="hljs-comment">/*绑定参数args的四种情况：</span><br><span class="hljs-comment">第1种情况：引用包装; 第2种情况：绑定表达式; 第3种情况：占位符; 第4种情况：通常参数*/</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::placeholders;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check_size</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;s, std::string::size_type sz)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">size</span>() &lt; sz;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><span class="hljs-comment">// for_each()打印的函数替换版本</span><br><span class="hljs-function">std::ostream &amp;<span class="hljs-title">print</span><span class="hljs-params">(std::ostream &amp;os,<span class="hljs-type">const</span> std::string&amp;str,<span class="hljs-type">char</span> c)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> os &lt;&lt; str &lt;&lt; c &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>&#125; <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shorter_words</span><span class="hljs-params">(std::vector&lt;std::string&gt; &amp;vec_str)</span></span>&#123;<br>    <span class="hljs-keyword">auto</span> it = std::<span class="hljs-built_in">stable_partition</span>(vec_str.<span class="hljs-built_in">begin</span>(), vec_str.<span class="hljs-built_in">end</span>(), std::<span class="hljs-built_in">bind</span>(check_size,_1,<span class="hljs-number">6</span>));<br>    std::for_each(vec_str.<span class="hljs-built_in">cbegin</span>(), vec_str.<span class="hljs-built_in">cend</span>(), [](<span class="hljs-type">const</span> std::string &amp;str)<br>                  &#123; std::cout &lt;&lt; str &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>; &#125;);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">auto</span> size = it - vec_str.<span class="hljs-built_in">cbegin</span>();<br>    std::cout &lt;&lt;<span class="hljs-string">&quot;words less than 6 count is:&quot;</span>&lt;&lt; size;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 绑定参数的check_size函数</span><br>    <span class="hljs-keyword">auto</span> check_6 = std::<span class="hljs-built_in">bind</span>(check_size, _1, <span class="hljs-number">6</span>); <span class="hljs-comment">// 对应函数 bool check_6(_1);</span><br>    std::string a = <span class="hljs-string">&quot;hello12&quot;</span>;<br>    std::cout &lt;&lt; <span class="hljs-built_in">check_6</span>(a) &lt;&lt; std::endl;<br>    <span class="hljs-comment">// 可以用bind掉转参数</span><br>    <span class="hljs-keyword">auto</span> u_sum = std::<span class="hljs-built_in">bind</span>(sum, _2, _1);<br>    std::cout &lt;&lt; <span class="hljs-built_in">u_sum</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)&lt;&lt;std::endl;<br>    <span class="hljs-comment">// 绑定引用参数 ref(),cref()</span><br>    std::vector&lt;std::string&gt; words = &#123;<span class="hljs-string">&quot;haha&quot;</span>, <span class="hljs-string">&quot;funcking&quot;</span>, <span class="hljs-string">&quot;bind&quot;</span>, <span class="hljs-string">&quot;is&quot;</span>,<span class="hljs-string">&quot;so&quot;</span>, <span class="hljs-string">&quot;learning!&quot;</span>&#125;;<br>    <span class="hljs-function">std::ostream <span class="hljs-title">os</span><span class="hljs-params">(std::cout.rdbuf())</span></span>;<br>    <span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>;<br>    std::for_each(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>(), [&amp;os, c](<span class="hljs-type">const</span> std::string &amp;str)<br>                  &#123; os &lt;&lt; str&lt;&lt; c&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>; &#125;);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">auto</span> print_bind = std::<span class="hljs-built_in">bind</span>(print, <span class="hljs-built_in">ref</span>(os), _1, c);<br>    std::for_each(words.<span class="hljs-built_in">begin</span>(), words.<span class="hljs-built_in">end</span>(), print_bind);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-comment">// 单词计数</span><br>    <span class="hljs-built_in">shorter_words</span>(words);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>绑定类的成员函数必须传递类对象或者类对象指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">BindTestClass <span class="hljs-title">bindTestClass</span><span class="hljs-params">(<span class="hljs-number">33</span>, <span class="hljs-string">&quot;zack&quot;</span>)</span></span>;<br><span class="hljs-comment">// 绑定类的成员函数,一定要传递对象给bind的第二个参数，可以是类对象，也可以是类对象的指针</span><br><span class="hljs-comment">// 如果要修改类成员，必须传递类对象的指针</span><br><span class="hljs-keyword">auto</span> memberbind = <span class="hljs-built_in">bind</span>(&amp;BindTestClass::MemberFun, &amp;bindTestClass, placeholders::_1, placeholders::_2);<br></code></pre></td></tr></table></figure><h3 id="模板编程"><a href="#模板编程" class="headerlink" title="模板编程"></a>模板编程</h3><h4 id="std-forward完美转发"><a href="#std-forward完美转发" class="headerlink" title="std::forward完美转发"></a>std::forward完美转发</h4><p>通常情况下，使用forward传递定位为模板类型的右值引用的函数参数。通过返回类型上的引用折叠，forward可以保持给定实参的左值&#x2F;右值属性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Type&gt;<br><span class="hljs-built_in">intermediary</span>(Type &amp;&amp;arg)&#123;<br><span class="hljs-built_in">finalFcn</span>(std::forward&lt;Type&gt;(arg));<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>源码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> _Tp&gt;<span class="hljs-function">_GLIBCXX_NODISCARD</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> _Tp&amp;&amp;</span><br><span class="hljs-function"><span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp; <span class="hljs-type">__t</span>)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="hljs-type">__t</span>); &#125;<br></code></pre></td></tr></table></figure><h4 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">std::ostream &amp;<span class="hljs-title">print</span><span class="hljs-params">(std::ostream &amp;os, <span class="hljs-type">const</span> T &amp;t)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> os &lt;&lt; t;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function">std::ostream &amp;<span class="hljs-title">print</span><span class="hljs-params">(std::ostream &amp;os, <span class="hljs-type">const</span> T &amp;t, <span class="hljs-type">const</span> Args&amp;... rest)</span></span>&#123;<br>    os &lt;&lt; t &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">print</span>(os, rest...);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">print</span>(std::cout, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">42</span>,<span class="hljs-string">&quot; good &quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>sizeof…运算符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 当需要知道包中的参数个数时，使用sizeof...</span><br>cout&lt;&lt; <span class="hljs-keyword">sizeof</span>...(args)&lt;&lt;endl;<br></code></pre></td></tr></table></figure><p><strong>折叠表达式优化C++17</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function">std::ostream&amp; <span class="hljs-title">print2</span><span class="hljs-params">(std::ostream &amp;os, <span class="hljs-type">const</span> Args&amp;... args)</span></span>&#123;<br>    <span class="hljs-comment">// 使用折叠表达式对每一个参数进行操作</span><br>    ((os &lt;&lt; args &lt;&lt; <span class="hljs-string">&quot; &quot;</span>), ...);<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="模板特化"><a href="#模板特化" class="headerlink" title="模板特化"></a>模板特化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-comment">// 函数模板的特化</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1,<span class="hljs-keyword">typename</span> T2&gt;</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> T1 &amp;v1, <span class="hljs-type">const</span> T2&amp; v2)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(v1&lt;v2)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span>(v2&lt;v2)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;v1, <span class="hljs-type">const</span> std::string &amp;v2)</span></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;特化版本&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(v<span class="hljs-number">1.</span><span class="hljs-built_in">c_str</span>(), v<span class="hljs-number">2.</span><span class="hljs-built_in">c_str</span>());<br>&#125;<br><span class="hljs-comment">// 类模板的特化</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Data</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;Data&lt;T1, T2&gt;&quot;</span> &lt;&lt; endl; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    T1 _d1;<br>    T2 _d2;<br>&#125;;<br><br><span class="hljs-comment">//全特化&lt;int,char&gt;</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Data</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Data&lt;int, char&gt;&quot;</span> &lt;&lt; std::endl; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> _d1;<br>    <span class="hljs-type">char</span> _d2;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TestVector</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Data&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; d1;<br>    Data&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt; d2;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-built_in">compare</span>(std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;he&quot;</span>), std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;he&quot;</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;exception&gt;</span> <span class="hljs-comment">//属于标准命名空间</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myExpection</span>: <span class="hljs-keyword">public</span> std::exception<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-title">what</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;C++ expection&quot;</span>;<br>    &#125;<br><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimerExpection</span>: <span class="hljs-keyword">public</span> std::exception&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TimerExpection</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">TimerExpection</span>(<span class="hljs-type">unsigned</span> code, <span class="hljs-type">const</span> std::string &amp;msg) : <span class="hljs-built_in">m_code</span>(code), <span class="hljs-built_in">m_errorMsg</span>(msg)&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">what</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> <span class="hljs-keyword">override</span></span>&#123;<br>        <span class="hljs-type">const</span> std::string msg = <span class="hljs-string">&quot;error code : &quot;</span>;<br>        <span class="hljs-keyword">return</span> msg.<span class="hljs-built_in">c_str</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">unsigned</span> m_code;<br>    std::string m_errorMsg;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">myExpection</span>();<br>    &#125;<span class="hljs-built_in">catch</span>(myExpection &amp;e)&#123;<br>        std::cout &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><h2 id="C-机制"><a href="#C-机制" class="headerlink" title="C++机制"></a>C++机制</h2><h3 id="前置声明"><a href="#前置声明" class="headerlink" title="前置声明"></a>前置声明</h3><p><strong>前向声明的适用情况</strong></p><ol><li><p><strong>指向未定义类型的指针或引用</strong>： 如果一个类仅使用另一个类的指针或引用，并不需要访问该类的成员，可以使用前向声明。这可以减少不必要的头文件包含。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Session</span>; <span class="hljs-comment">// 前向声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LogicNode</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::shared_ptr&lt;Session&gt; <span class="hljs-title">getSession</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">// 其他成员函数和变量</span><br><span class="hljs-keyword">private</span>:<br>    std::shared_ptr&lt;Session&gt; p_session; <span class="hljs-comment">// 仅使用指针</span><br>    <span class="hljs-comment">// 其他成员变量</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><strong>避免循环依赖</strong>： 当两个类互相包含对方的实例时，前向声明可以打破这种循环依赖。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cpp复制代码<span class="hljs-comment">// A.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> A_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> A_H</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>; <span class="hljs-comment">// 前向声明</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomethingWithB</span><span class="hljs-params">(B* b)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    B* bInstance; <span class="hljs-comment">// 使用指针</span><br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// A_H</span></span><br><br><span class="hljs-comment">// B.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> B_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> B_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;A.h&quot;</span> <span class="hljs-comment">// 包含A.h，因为需要访问A的成员</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomethingWithA</span><span class="hljs-params">(A* a)</span></span>;<br><span class="hljs-keyword">private</span>:<br>    A* aInstance; <span class="hljs-comment">// 使用指针</span><br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">// B_H</span></span><br></code></pre></td></tr></table></figure></li></ol><p><strong>前向声明的限制</strong></p><ol><li><strong>不能定义成员变量</strong> </li><li><strong>不能调用成员函数</strong></li></ol><h3 id="RAII机制"><a href="#RAII机制" class="headerlink" title="RAII机制"></a>RAII机制</h3><p>​RAII是Resource Acquisition Is Initialization的缩写，即“资源获取即初始化”。它是C++语言的一种管理资源、避免资源泄漏的惯用法，利用栈的特点来实现，这一概念最早由Bjarne Stroustrup提出。在函数中由栈管理的临时对象，在函数结束时会自动析构，从而自动释放资源，因此，我们可以通过构造函数获取资源，通过析构函数释放资源。即：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">Object</span>() &#123;<br>    <span class="hljs-comment">// acquire resource in constructor</span><br>&#125;<br><br>~<span class="hljs-built_in">Object</span>() &#123;<br>    <span class="hljs-comment">// release resource in destructor</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="RVO、NRVO编译器优化"><a href="#RVO、NRVO编译器优化" class="headerlink" title="RVO、NRVO编译器优化"></a>RVO、NRVO编译器优化</h3><p>GCC 中使用 <code>-fno-elide-constructors</code>可以禁用RVO、NRVO优化 </p><p><strong>RVO(未命名的局部变量返回值优化)&#x2F;NRVO（命名的局部变量返回值优化）</strong>: 编译器会尝试应用返回值优化。如果成功，局部变量将直接在调用者的存储空间中构造，不会调用拷贝或移动构造函数。</p><p>如果禁止了RVO&#x2F;NRVO优化，返回局部变量应该优先使用移动构造函数，如果没有移动构造函数就使用拷贝构造函数。如果开启RVO&#x2F;NRVO优化就不使用任何构造函数。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><h3 id="C-反射"><a href="#C-反射" class="headerlink" title="C++反射"></a>C++反射</h3><p>反射机制允许程序在运行时借助API取得任何类的内部信息，并能直接操作对象的内部属性和方法。</p><p>C++不支持反射，PRC，WEB MVC，对象序列化 都依赖反射。</p><p>1、类对象反射</p><p><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240706174644802.png" alt="image-20240706174644802"></p><p>2、类成员数据反射</p><p>3、类成员函数反射</p><h3 id="CRTP机制"><a href="#CRTP机制" class="headerlink" title="CRTP机制"></a>CRTP机制</h3><p>奇异递归模板方法，通过继承实例为自身的模板方法</p><h2 id="std-chrono"><a href="#std-chrono" class="headerlink" title="std::chrono"></a>std::chrono</h2><p>其定于都是在std::chrono这个命名空间下的</p><h4 id="1、Time-Points-时间点"><a href="#1、Time-Points-时间点" class="headerlink" title="1、Time Points 时间点"></a>1、Time Points 时间点</h4><p>表示一个特定的时间点，类模板，需要传递采用的时钟信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 获取当前所在的时间点/时间戳</span><br><span class="hljs-type">const</span> std::chrono::time_point&lt;std::chrono::system_clock&gt; now = std::chrono::system_clock::<span class="hljs-built_in">now</span>();<br></code></pre></td></tr></table></figure><h5 id="time-since-epoch"><a href="#time-since-epoch" class="headerlink" title="time_since_epoch()"></a>time_since_epoch()</h5><p>返回当前时间到时间纪元开始的durations</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::hours&gt;(p<span class="hljs-number">1.</span><span class="hljs-built_in">time_since_epoch</span>()).<span class="hljs-built_in">count</span>() <br></code></pre></td></tr></table></figure><h4 id="2、Durations-时间长度"><a href="#2、Durations-时间长度" class="headerlink" title="2、Durations 时间长度"></a>2、Durations 时间长度</h4><p>表示时间的长度。</p><blockquote><p>1 秒 &#x3D; 1000 毫秒 &#x3D; 1000 * 1000 微秒 &#x3D; 1000<em>1000</em>1000 纳秒 &#x3D; 1000<em>1000</em>1000*1000 </p></blockquote><table><thead><tr><th>类型</th><th>定义</th></tr></thead><tbody><tr><td><strong><code>std::chrono::nanoseconds</code></strong></td><td>std::chrono::duration&lt;*&#x2F;* int64 *&#x2F;*, <a href="http://zh.cppreference.com/w/cpp/numeric/ratio/ratio">std::nano</a>&gt;</td></tr><tr><td><strong><code>std::chrono::microseconds</code></strong></td><td>std::chrono::duration&lt;*&#x2F;* int55 *&#x2F;*, <a href="http://zh.cppreference.com/w/cpp/numeric/ratio/ratio">std::micro</a>&gt;</td></tr><tr><td><strong><code>std::chrono::milliseconds</code></strong></td><td>std::chrono::duration&lt;*&#x2F;* int45 *&#x2F;*, <a href="http://zh.cppreference.com/w/cpp/numeric/ratio/ratio">std::milli</a>&gt;</td></tr><tr><td><strong><code>std::chrono::seconds</code></strong></td><td>std::chrono::duration&lt;*&#x2F;* int35 *&#x2F;*&gt;</td></tr><tr><td><strong><code>std::chrono::minutes</code></strong></td><td>std::chrono::duration&lt;*&#x2F;* int29 *&#x2F;*, <a href="http://zh.cppreference.com/w/cpp/numeric/ratio/ratio">std::ratio</a>&lt;60&gt;&gt;</td></tr><tr><td><strong><code>std::chrono::hours</code></strong></td><td>std::chrono::duration&lt;*&#x2F;* int23 *&#x2F;*, <a href="http://zh.cppreference.com/w/cpp/numeric/ratio/ratio">std::ratio</a>&lt;3600&gt;&gt;</td></tr><tr><td><code>std::chrono::days</code> (C++20 起)</td><td>std::chrono::duration&lt;*&#x2F;* int25 *&#x2F;*, <a href="http://zh.cppreference.com/w/cpp/numeric/ratio/ratio">std::ratio</a>&lt;86400&gt;&gt;</td></tr><tr><td><code>std::chrono::weeks</code> (C++20 起)</td><td>std::chrono::duration&lt;*&#x2F;* int22 *&#x2F;*, <a href="http://zh.cppreference.com/w/cpp/numeric/ratio/ratio">std::ratio</a>&lt;604800&gt;&gt;</td></tr><tr><td><code>std::chrono::months</code> (C++20 起)</td><td>std::chrono::duration&lt;*&#x2F;* int20 *&#x2F;*, <a href="http://zh.cppreference.com/w/cpp/numeric/ratio/ratio">std::ratio</a>&lt;2629746&gt;&gt;</td></tr><tr><td><code>std::chrono::years</code> (C++20 起)</td><td>std::chrono::duration&lt;*&#x2F;* int17 *&#x2F;*, <a href="http://zh.cppreference.com/w/cpp/numeric/ratio/ratio">std::ratio</a>&lt;31556952&gt;&gt;</td></tr></tbody></table><h5 id="std-chrono-duration-cast"><a href="#std-chrono-duration-cast" class="headerlink" title="std::chrono::duration_cast&lt;&gt;"></a>std::chrono::duration_cast&lt;&gt;</h5><p>转化时间的单位；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(std::chrono::system_clock::<span class="hljs-built_in">now</span>().<span class="hljs-built_in">time_since_epoch</span>()).<span class="hljs-built_in">count</span>()<br></code></pre></td></tr></table></figure><h5 id="count"><a href="#count" class="headerlink" title="count()"></a>count()</h5><p>返回时长计数次数的有符号算数类型；</p><h4 id="3、Clocks-时钟"><a href="#3、Clocks-时钟" class="headerlink" title="3、Clocks 时钟"></a>3、Clocks 时钟</h4><p>获取当前的时间点。</p><ul><li><strong>system_clock</strong> 表示系统的实际时间，不会受到系统时间调整的影响</li><li><strong>steady_clock</strong> 稳定的时钟，时间不调整</li><li><strong>high_resolution_clock</strong> 提供最小可表示的时间间隔</li></ul><p><strong>成员函数</strong></p><h5 id="now"><a href="#now" class="headerlink" title="now()"></a>now()</h5><p>返回表示时间中的当前时间点Time_Point</p><h3 id="应用实例："><a href="#应用实例：" class="headerlink" title="应用实例："></a>应用实例：</h3><p><strong>定时器类</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Timer</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(m_timeRuning)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">TimerExpection</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;计时器被重复启动&quot;</span>);<br>        &#125;<br>        m_timeRuning = <span class="hljs-literal">true</span>;<br>        m_begin = std::chrono::system_clock::<span class="hljs-built_in">now</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!m_timeRuning)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">TimerExpection</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;计时器还没有启动&quot;</span>);<br>        &#125;<br>        m_timeRuning = <span class="hljs-literal">false</span>;<br>        m_end = std::chrono::system_clock::<span class="hljs-built_in">now</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">elapsed</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(m_timeRuning)&#123;<br>            <span class="hljs-keyword">return</span> std::chrono::<span class="hljs-built_in">duration</span>&lt;<span class="hljs-type">double</span>&gt;(std::chrono::system_clock::<span class="hljs-built_in">now</span>() - m_begin).<span class="hljs-built_in">count</span>();<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span> (m_begin == std::chrono::time_point &lt;std::chrono::system_clock&gt;())&#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-built_in">TimerExpection</span>(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;计时器还未启动&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> std::chrono::<span class="hljs-built_in">duration</span>&lt;<span class="hljs-type">double</span>&gt;(m_end - m_begin).<span class="hljs-built_in">count</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">bool</span> m_timeRuning = <span class="hljs-literal">false</span>;<br>    std::chrono::time_point&lt;std::chrono::system_clock&gt; m_begin;<br>    std::chrono::time_point&lt;std::chrono::system_clock&gt; m_end;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    Timer time;<br>    time.<span class="hljs-built_in">start</span>();<br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">3</span>));<br>    time.<span class="hljs-built_in">stop</span>();<br>    std::cout &lt;&lt; time.<span class="hljs-built_in">elapsed</span>() &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="C风格时间日期"><a href="#C风格时间日期" class="headerlink" title="C风格时间日期"></a>C风格时间日期</h3><h3 id="std-time-t"><a href="#std-time-t" class="headerlink" title="std::time_t"></a>std::time_t</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 获取当前时间点</span><br><span class="hljs-keyword">auto</span> now = std::chrono::system_clock::<span class="hljs-built_in">now</span>();<br><br><span class="hljs-comment">// 转换为time_t类型</span><br>std::<span class="hljs-type">time_t</span> <span class="hljs-type">now_time_t</span> = std::chrono::system_clock::<span class="hljs-built_in">to_time_t</span>(now);<br><br><span class="hljs-comment">// 将time_t类型的时间转换为tm结构</span><br>std::tm* now_tm = std::<span class="hljs-built_in">localtime</span>(&amp;<span class="hljs-type">now_time_t</span>);<br><br><span class="hljs-comment">// 使用std::put_time格式化输出时间</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Current time: &quot;</span> &lt;&lt; std::<span class="hljs-built_in">put_time</span>(now_tm, <span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>) &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><h2 id="外部库"><a href="#外部库" class="headerlink" title="外部库"></a>外部库</h2><h3 id="Boost"><a href="#Boost" class="headerlink" title="Boost"></a>Boost</h3><h3 id="jsoncpp"><a href="#jsoncpp" class="headerlink" title="jsoncpp"></a>jsoncpp</h3><h4 id="json格式解析"><a href="#json格式解析" class="headerlink" title="json格式解析"></a>json格式解析</h4><p>json中仅支持两种数据结构</p><ul><li><strong>对象（object）</strong>：以<code>&#123;</code>开头</li><li><strong>数组（array）</strong>：以<code>[</code>开头</li></ul><p><strong>pair键值对：</strong></p><p>一个pair键值对的结构通常是： <code>string(key) : value(value)</code>，其中<strong>key一般使用字符串</strong>，也可以使用数字，建议key只使用字符串。<strong>value取值</strong>较为随意，可以是json支持的任意类型：<strong>object，array，string，number，true，false，null</strong>，这说明了可以嵌套类型。</p><p><strong>对象object：</strong></p><p><strong>object是多个pair的集合</strong>，以{开始,}作为结束，不同的pair之间用英文逗号来分割。object之间的pairt数据是无序的。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;nick&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;age&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-number">18</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>数组array：</strong></p><p><strong>array是value的有序集合</strong>，以[开始，]作为结束，不同array元素之间也用英文逗号来分割。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">[</span><br><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;nick&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">18</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;domin&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;cn&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><h4 id="从文件中解析json："><a href="#从文件中解析json：" class="headerlink" title="从文件中解析json："></a>从文件中解析json：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// color.json</span><br>&#123;<br>    <span class="hljs-string">&quot;name&quot;</span> : <span class="hljs-string">&quot;nick&quot;</span>,<br>    <span class="hljs-string">&quot;age&quot;</span> : <span class="hljs-number">18</span><br>&#125;<br><span class="hljs-comment">// testJson.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;jsoncpp.cpp&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">parse_from_file</span><span class="hljs-params">()</span></span>&#123;<br>    std::ifstream ifs;<br>    ifs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;color.json&quot;</span>);<br>    Json::Reader reader;<br>    Json::Value root;<br>    <span class="hljs-comment">// 从reader中反序列化</span><br>    <span class="hljs-keyword">if</span>(!reader.<span class="hljs-built_in">parse</span>(ifs, root, <span class="hljs-literal">false</span>))&#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;parse failed \n&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    std::string name = root[<span class="hljs-string">&quot;name&quot;</span>].<span class="hljs-built_in">asString</span>();<br>    <span class="hljs-type">int</span> age = root[<span class="hljs-string">&quot;age&quot;</span>].<span class="hljs-built_in">asInt</span>();<br>    std::cout&lt;&lt;name &lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;age;<br>    ifs.<span class="hljs-built_in">close</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">parse_from_file</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="protobuf"><a href="#protobuf" class="headerlink" title="protobuf"></a>protobuf</h3><h3 id="grpc"><a href="#grpc" class="headerlink" title="grpc"></a>grpc</h3><h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><p>启动redis</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">.\redis-server.exe .\redis.windows.conf<br></code></pre></td></tr></table></figure><p><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240728084005178.png" alt="image-20240728084005178"></p><h4 id="字符串String"><a href="#字符串String" class="headerlink" title="字符串String"></a>字符串String</h4><p>设置一个键值对：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">SET</span> key <span class="hljs-comment">value</span><br></code></pre></td></tr></table></figure><p>当键不存在时，设置键的值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">SETNX name value<br></code></pre></td></tr></table></figure><p>获取一个值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">GET key<br></code></pre></td></tr></table></figure><p>Redis默认不支持中文显示，值作为中文将显示为二进制字符串，使用–raw可以显示原始数据</p><p>设置一个键的过期时间，单位秒：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">EXPIRE key <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>设置一个带有过期时间的键值：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SETEX</span> key <span class="hljs-number">10</span> value<br></code></pre></td></tr></table></figure><p>查看一个键的过期时间：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TTL key<br></code></pre></td></tr></table></figure><h4 id="List列表"><a href="#List列表" class="headerlink" title="List列表"></a>List列表</h4><p>将元素添加到头部</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">LPUSH ListName value</span><br></code></pre></td></tr></table></figure><p>从列表尾部添加元素</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">RPUSH ListName value</span><br></code></pre></td></tr></table></figure><p>删除列表头部&#x2F;尾部中的指定数量的元素</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">LPOP</span> ListName 元素数<br>RPOP ListName 元素数<br></code></pre></td></tr></table></figure><p>查看列表中的所有元素，-1代表列表中的最后一个元素位置</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">LRANGE</span> ListName 起始位置 -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>查看列表的长度</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">LLEN ListName</span><br></code></pre></td></tr></table></figure><p>删除范围之外的元素</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">LTRIM</span> ListName 范围<span class="hljs-number">1</span> 范围<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>不可重复的元素集合</p><p>添加元素，重复添加将返回false</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">SADD</span> SetName value<br></code></pre></td></tr></table></figure><p>查看集合中的内容</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">SMEMBERS SetName</span><br></code></pre></td></tr></table></figure><p>判断元素是否在集合中</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">SISMEMBER SetName value</span><br></code></pre></td></tr></table></figure><p>删除元素</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">SERM SetName value</span><br></code></pre></td></tr></table></figure><p>同时Reids支持集合之间的运算。</p><h4 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h4><p>有序集合操作</p><p><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240728091116901.png" alt="image-20240728091116901"></p><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>记录键值对的集合</p><p>添加键值对</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">HSET HashName key value</span><br></code></pre></td></tr></table></figure><p>获取值</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">HGET HashName key</span><br></code></pre></td></tr></table></figure><p>获取所有键值对</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">HGETALL HashName</span><br></code></pre></td></tr></table></figure><p>删除键值对</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">HDEL HashName key</span><br></code></pre></td></tr></table></figure><p>判断键是否存在</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">HEXISTS HashName key</span><br></code></pre></td></tr></table></figure><h4 id="订阅者模式"><a href="#订阅者模式" class="headerlink" title="订阅者模式"></a>订阅者模式</h4><h4 id="消息队列Stream"><a href="#消息队列Stream" class="headerlink" title="消息队列Stream"></a>消息队列Stream</h4><h2 id="杂谈："><a href="#杂谈：" class="headerlink" title="杂谈："></a>杂谈：</h2><p>linux高性能服务器，单例模式，工厂模式，木朵网络库，一个方向深挖，opengl， opencv</p>]]></content>
    
    
    
    <tags>
      
      <tag>c++基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++</title>
    <link href="/2024/07/31/Effective/"/>
    <url>/2024/07/31/Effective/</url>
    
    <content type="html"><![CDATA[<p><strong>《总之，好记性不如烂笔头！把你遗忘的都记下来吧！》</strong></p><h1 id="Effective-C-改善程序和设计的55个具体做法"><a href="#Effective-C-改善程序和设计的55个具体做法" class="headerlink" title="Effective C++ 改善程序和设计的55个具体做法"></a>Effective C++ 改善程序和设计的55个具体做法</h1><h2 id="01：视C-为一个语言联邦"><a href="#01：视C-为一个语言联邦" class="headerlink" title="01：视C++为一个语言联邦"></a>01：视C++为一个语言联邦</h2><ul><li>C。C++以C为基础；</li><li>Object-Oriented C++。包括类、封装、继承、多态、动态绑定等；</li><li>Template C++。 C++泛型编程的基础；</li><li>STL库。包括容器、算法、迭代器、配置器、仿函数；</li></ul><h2 id="02：尽量以const，enum，inline替代-define"><a href="#02：尽量以const，enum，inline替代-define" class="headerlink" title="02：尽量以const，enum，inline替代#define"></a>02：尽量以const，enum，inline替代#define</h2><h3 id="1、使用const-enum替换-define"><a href="#1、使用const-enum替换-define" class="headerlink" title="1、使用const&#x2F;enum替换#define"></a>1、使用const&#x2F;enum替换#define</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ASPECT_RATIO 1.653</span><br></code></pre></td></tr></table></figure><p>ASPECT_RATIO不能被编译器所看到，导致错误信息可能只是数字。</p><p>使用常量来替换宏：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">double</span> ASPECTRATIO = <span class="hljs-number">1.653</span><br></code></pre></td></tr></table></figure><p>使用常量来替换宏的两种特殊情况：</p><p>第一：<strong>定义常量指针</strong></p><p>由于常量定义式常放在头文件内，有必要将指针声明为const。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> authorName = <span class="hljs-string">&quot;Scott Meyers&quot;</span>;<br></code></pre></td></tr></table></figure><p>第二：<strong>类的静态常量</strong></p><p>为了将常量的作用域限制在类中，必须声明为类的成员</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GamePlayer</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 在类内声明和初始化，是编译时常量，没有内存地址</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> NumTurns = <span class="hljs-number">5</span>;  <span class="hljs-comment">// 常量的声明式并初始化（C++11）</span><br><span class="hljs-type">int</span> scores[NumTurns]; <span class="hljs-comment">// 使用常量</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>只要不取地址就可以声明并使用它们而无须提供定义，但是要取类静态常量的地址，就必须提供定义式！</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> GamePlayer::NumTurns; <span class="hljs-comment">//定义式，由于声明已经获得初值，定义可以不设置初值</span><br></code></pre></td></tr></table></figure><p>顺便的#define在类内不提供任何封装性。</p><p>如果不支持静态常量类内初始化，将初值放在定义式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CostEstimate</span>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">double</span> FudgeFactor;<span class="hljs-comment">// 类内声明</span><br>&#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> CostEstimate::FudgeFactor = <span class="hljs-number">1.35</span>; <span class="hljs-comment">// 静态常量类外定义并初始化 </span><br></code></pre></td></tr></table></figure><p>但是这样做不能在类内使用这个常量，可以使用“ the enum hack”的补偿做法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GamePlayer</span>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">enum</span> &#123; NumTurns = <span class="hljs-number">5</span> &#125;;<br><span class="hljs-type">int</span> scores[NumTurns];<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2、改写-define形似函数的宏"><a href="#2、改写-define形似函数的宏" class="headerlink" title="2、改写#define形似函数的宏"></a>2、改写#define形似函数的宏</h3><p>对于像是这样的形似函数的宏：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b))</span><br></code></pre></td></tr></table></figure><p>使用这样的宏，必须为宏上的所有实参加上括号。</p><p>应该使用<strong>template inline</strong>来替代这样的宏，它具有和宏一般的效率，且更加安全</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">callWithMax</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; a, <span class="hljs-type">const</span> T&amp;b)</span></span>&#123;<br><span class="hljs-built_in">f</span>(a &gt; b ? a : b);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="03：尽可能的使用const"><a href="#03：尽可能的使用const" class="headerlink" title="03：尽可能的使用const"></a>03：尽可能的使用const</h2><p>const可以和函数返回值、参数、函数自身产生关联。</p><h3 id="const作用于函数返回值："><a href="#const作用于函数返回值：" class="headerlink" title="const作用于函数返回值："></a><strong>const作用于函数返回值：</strong></h3><p>令函数返回一个常量值，可以降低因错误而产生的意外。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span>&#123; ... &#125;;<br><span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>* (<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs);<br><span class="hljs-comment">// 返回const对象可以防止下面的错误</span><br>Rational a, b, c;<br>(a * b) = c;<br><span class="hljs-comment">// 从而产生像是</span><br><span class="hljs-keyword">if</span>( a * b = c) <span class="hljs-comment">// 因为错误写==而导致的逻辑错误</span><br></code></pre></td></tr></table></figure><h3 id="const参数："><a href="#const参数：" class="headerlink" title="const参数："></a><strong>const参数：</strong></h3><p>对于在函数中不改变的参数，应当将它们声明为const的。</p><h3 id="const成员函数："><a href="#const成员函数：" class="headerlink" title="const成员函数："></a><strong>const成员函数：</strong></h3><p>将const作于成员函数是为了const对象能够使用这个成员函数，存在两方面：1、使得接口容易被理解，因为可以很容易看出这个接口不改变对象内容；2、能够被const对象使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextBlock</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TextBlock</span>(std::string txt):<span class="hljs-built_in">text</span>(txt)&#123;&#125;;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-type">size_t</span> position) <span class="hljs-type">const</span>&#123;  <span class="hljs-comment">// 使用常成员函数重载的[]</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;this is use the const&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> text[position];<br>    &#125;<br>    <span class="hljs-type">char</span> &amp;<span class="hljs-keyword">operator</span>[](std::<span class="hljs-type">size_t</span> position)&#123;<span class="hljs-comment">// 使用普通成员函数重载的[]</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;this is use the non-const&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> text[position];<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>  std::string text;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">TextBlock <span class="hljs-title">tb</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>)</span></span>;<br>    std::cout &lt;&lt; tb[<span class="hljs-number">0</span>]&lt;&lt;std::endl;<br>    <span class="hljs-function">TextBlock <span class="hljs-title">ctb</span><span class="hljs-params">(<span class="hljs-string">&quot;haha&quot;</span>)</span></span>;<br>    std::cout &lt;&lt; ctb[<span class="hljs-number">1</span>]&lt;&lt;std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>const成员函数的bitwise constness 和 logical constness</strong></p><p>bitwise const：成员函数只有在不改变对象内的任何成员变量时才可以说是const的。一个更改了”指针所指向之物“的成员函数仍算数bitwise const，不会引发编译异常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CTextBlock</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// bitwise const声明，在函数内并不修改成员变量</span><br>    <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-type">size_t</span> position)<span class="hljs-type">const</span>&#123;<br>        <span class="hljs-keyword">return</span> pText[position];<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">char</span> *pText; <span class="hljs-comment">// 文本长度，可能是随时变化的， 如果变换文本记录长度失效</span><br>&#125;;<br><span class="hljs-comment">// 但是利用返回的引用，仍可能修改成员变量</span><br><span class="hljs-function"><span class="hljs-type">const</span> CTextBlock <span class="hljs-title">cctb</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello&quot;</span>)</span></span>;<br><span class="hljs-type">char</span> *pc = &amp;cctb[<span class="hljs-number">0</span>];<br>*pc = <span class="hljs-string">&#x27;J&#x27;</span>; <span class="hljs-comment">// 将&#x27;H&#x27;修改为了&#x27;J&#x27;</span><br></code></pre></td></tr></table></figure><p>logical const:  一个const成员函数可以修改它所处理的的对象的某些bits，但是只有在客户端侦测不出的情况下。</p><p>为了确保能够在const成员函数中修改成员变量，需要将需要修改的成员变量声明为<strong>mutable</strong>的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CTextBlock</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!lengthIsValid)&#123;<br>        <span class="hljs-comment">// 即使是在const成员函数中也能修改，因为其被定义为mutable的了</span><br>        textLength = std::<span class="hljs-built_in">strlen</span>(pText);<br>        lengthIsValid = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> textLength;<br>  &#125;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">char</span> *pText; <span class="hljs-comment">// 文本长度，可能是随时变化的， 如果变换文本记录长度失效</span><br>  <span class="hljs-keyword">mutable</span> std::<span class="hljs-type">size_t</span> textLength; <span class="hljs-comment">// 记录当前的文本长度</span><br>  <span class="hljs-keyword">mutable</span> <span class="hljs-type">bool</span> lengthIsValid;   <span class="hljs-comment">// 当前文本长度是否失效</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>避免const和non-const成员函数的重复：</strong></p><p>运用const成员函数来实现出其non-const成员函数的方法。因为在non-const中对象可能被改动，因此使用const成员函数调用non-const成员函数是一种错误的行为。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CTextBlock2</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-type">size_t</span> position)<span class="hljs-type">const</span>&#123;<br>        <span class="hljs-comment">// ......</span><br>        <span class="hljs-comment">// ......</span><br>        <span class="hljs-comment">// 很长的代码</span><br>        <span class="hljs-keyword">return</span> pText[position]; <br>    &#125;<br>    <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-type">size_t</span> position) &#123;<br>        <span class="hljs-comment">// 转调用const版本的operator[]</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span> &amp;&gt;(<span class="hljs-comment">// 利用const_cast&lt;&gt;()去除返回值的const性质</span><br>            <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> TextBlock &amp;&gt;(*<span class="hljs-keyword">this</span>)[position]);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">char</span> *pText; <br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="04：确定对象使用前已先被初始化"><a href="#04：确定对象使用前已先被初始化" class="headerlink" title="04：确定对象使用前已先被初始化"></a>04：确定对象使用前已先被初始化</h2><h3 id="使用内置型对象进行手工初始化"><a href="#使用内置型对象进行手工初始化" class="headerlink" title="使用内置型对象进行手工初始化"></a>使用内置型对象进行手工初始化</h3><p>因为C++不保证初始化它们，读取未初始化的值会导致不明确的行为。</p><h3 id="使用初始化成员列表"><a href="#使用初始化成员列表" class="headerlink" title="使用初始化成员列表"></a>使用<strong>初始化成员列表</strong></h3><p><strong>不要混淆赋值和初始化</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ABEntry::<span class="hljs-built_in">ABEntry</span>(<span class="hljs-type">const</span> std;:string &amp;name)&#123;<br>    <span class="hljs-comment">// 赋值操作</span><br>theName = name;<br>&#125;<br></code></pre></td></tr></table></figure><p>对象的初始化在进入构造函数本体之前，在构造函数内不是初始化而是赋值。</p><p>改用初始化能够减少一次赋值动作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ABEntry::<span class="hljs-built_in">ABEntry</span>(<span class="hljs-type">const</span> std;:string &amp;name):<span class="hljs-built_in">theName</span>(name)<br>&#123;&#125;<br></code></pre></td></tr></table></figure><p>规定总是在初值列中列出所有成员变量，C++有十分固定的成员初始化次序，基类早于继承类初始化，成员变量总是按照生命次序被初始化。在初始化成员列表中，最好以声明次序列出各个成员。</p><h3 id="不同编译单元（不同文件）的non-local-static对象的初始化次序"><a href="#不同编译单元（不同文件）的non-local-static对象的初始化次序" class="headerlink" title="不同编译单元（不同文件）的non-local static对象的初始化次序"></a><strong>不同编译单元（不同文件）的non-local static对象的初始化次序</strong></h3><blockquote><p>函数内的static对象成为local static对象，其它static对象称为non-local static对象</p></blockquote><p>由于C++对于不同编译单元内的non-local static对象的初始化次序没有明确定义，导致一个编译单元的non-local static对象使用另一个编译单元的non-local static对象可能未初始化。</p><p>解决方法：</p><p>将non-local static对象搬到自己的专属函数中使之变为local static，在函数内部被声明为static，函数返回一个reference指向它所含的对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileSystem</span> &#123; ... &#125;;<br><span class="hljs-function">FileSystem&amp; <span class="hljs-title">tfs</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">static</span> FileSystem fs;<br><span class="hljs-keyword">return</span> fs;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="05：了解C-默默编写并调用哪些函数"><a href="#05：了解C-默默编写并调用哪些函数" class="headerlink" title="05：了解C++默默编写并调用哪些函数"></a>05：了解C++默默编写并调用哪些函数</h2><p>对于一个类如果没有声明，编译器就会自动生成一个<strong>copy构造函数</strong>，一个<strong>copy赋值运算符</strong>和一个<strong>析构函数</strong>，如果没有声明默认构造函数，同时也会生成一个默认构造函数。所有这些函数都是<strong>public</strong>且<strong>inline</strong>的。</p><p>**对于内含引用、const类型的成员变量，编译器会拒绝为class生成operator&#x3D;**。</p><p>如果一个基类将拷贝赋值运算符声明为private，那么编译器会拒绝为派生类生成拷贝赋值运算符。</p><h2 id="06：若不想使用编译器自动生成的函数，就应该明确拒绝"><a href="#06：若不想使用编译器自动生成的函数，就应该明确拒绝" class="headerlink" title="06：若不想使用编译器自动生成的函数，就应该明确拒绝"></a>06：若不想使用编译器自动生成的函数，就应该明确拒绝</h2><p>1、声明一个具有private类型的拷贝赋值运算符作为基类，并继承；</p><p>2、使用&#x3D;delete直接删除；</p><h2 id="07：为多态基类声明virtual析构函数"><a href="#07：为多态基类声明virtual析构函数" class="headerlink" title="07：为多态基类声明virtual析构函数"></a>07：为多态基类声明virtual析构函数</h2><p>使用factory工厂方法，返回一个基类指针，指向新生成的继承类对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 工厂方法的简化定义</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">Product</span>()&#123;&#125;  <span class="hljs-comment">// 正确的定义：virtual ~Product()&#123;&#125;</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteProduct1</span> : <span class="hljs-keyword">public</span> Product&#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteProduct2</span> : <span class="hljs-keyword">public</span> Product&#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Creator</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">Creator</span>()&#123;&#125;  <span class="hljs-comment">// 正确的定义：virtual ~Creator()&#123;&#125;</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Product *<span class="hljs-title">FactoryMethod</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SomeOperation</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>        <span class="hljs-comment">// 在此处返回一个基类指针指向了派生类</span><br>        Product *product = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">FactoryMethod</span>();<br><span class="hljs-comment">// 未定义！释放基类指针，避免资源泄漏</span><br>        <span class="hljs-keyword">delete</span> product;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteCreator1</span> : <span class="hljs-keyword">public</span> Creator&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">Product *<span class="hljs-title">FactoryMethod</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreteProduct1</span>(); &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteCreator2</span> : <span class="hljs-keyword">public</span> Creator&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">Product *<span class="hljs-title">FactoryMethod</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreteProduct2</span>(); &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>C++指出，当继承对象经由一个基类指针被删除，而基类指针带有一个<strong>non-virtual析构函数</strong>其结果是<strong>未定义</strong>的。产生的结果是基类部分被析构，而派生类的部分没有被析构，导致资源泄露，破坏数据结构。</p><p><strong>任何类中只要带有virtual函数几乎确定也应该有一个virtual析构函数。</strong>反之亦然。</p><p>声明一个带纯虚析构函数的抽象类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 抽象类，不能实例化对象</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AMOV</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 声明为纯虚析构函数</span><br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">AWOV</span>() = <span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-comment">// 必须为纯虚析构函数提供一份定义</span><br>AMOV::~<span class="hljs-built_in">AMOV</span>()&#123; &#125;<br></code></pre></td></tr></table></figure><p>析构函数从最深层的派生类开始调用其析构函数，然后每一个基类的析构函数被调用。编译器会在AMOV的继承类的析构函数中创建一个对~AMOV的调用动作，因此必须为这个函数提供一份定义。</p><h2 id="08：别让异常逃离析构函数"><a href="#08：别让异常逃离析构函数" class="headerlink" title="08：别让异常逃离析构函数"></a>08：别让异常逃离析构函数</h2><p>在析构函数中必须执行一个动作，但该动作会在失败时抛出异常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DBConn</span>&#123;<br><span class="hljs-keyword">public</span>:<br>...<br>    ~<span class="hljs-built_in">DBConn</span>()&#123;<br>        <span class="hljs-comment">// 确保数据库连接总是会关闭，但是会抛出异常</span><br>    db.<span class="hljs-built_in">close</span>();<br>    &#125;<br> <span class="hljs-keyword">private</span>:<br> DBConnection db;<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果调用导致异常，析构函数将传播异常，允许其离开这个析构函数。</p><p>解决方法：</p><p>1、通过调用abort终止</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">DBConn::~<span class="hljs-built_in">DBConn</span>()&#123;<br><span class="hljs-keyword">try</span> &#123; db.<span class="hljs-built_in">close</span>();&#125;<br><span class="hljs-built_in">catch</span>(...)&#123;<br>std::<span class="hljs-built_in">abort</span>();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法将导致程序被强迫结束。</p><p>2、记录close的失败调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">DBConn::~<span class="hljs-built_in">DBConn</span>()&#123;<br><span class="hljs-keyword">try</span> &#123; db.<span class="hljs-built_in">close</span>();&#125;<br><span class="hljs-built_in">catch</span>(...)&#123;<br>记录失败调用。<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、 在新接口中操作，将责任从析构函数中转移</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DBConn</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span>&#123;<br>db.<span class="hljs-built_in">close</span>();<br>closed = <span class="hljs-literal">true</span>;<br>&#125;<br>    ~<span class="hljs-built_in">DBConn</span>()&#123;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">closed</span>())&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>    db.<span class="hljs-built_in">close</span>();<br>    &#125;<span class="hljs-built_in">catch</span>(...)&#123;<br>    记录close失败调用。<br>    &#125;<br>    &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>将close责任从析构函数中转移到DBConn的用户手中。</p><p><strong>如果某个操作可能在失败时抛出异常，而又必须处理该异常，这个异常必须来自析构函数之外</strong>，析构函数抛出异常会带来”过早结束程序“和”不明确行为“的风险。</p><h2 id="09：绝不在析构和构造函数过程中调用virtual函数"><a href="#09：绝不在析构和构造函数过程中调用virtual函数" class="headerlink" title="09：绝不在析构和构造函数过程中调用virtual函数"></a>09：绝不在析构和构造函数过程中调用virtual函数</h2><h2 id="10：令operator-返回一个reference-to-this"><a href="#10：令operator-返回一个reference-to-this" class="headerlink" title="10：令operator&#x3D;返回一个reference to *this"></a>10：令operator&#x3D;返回一个reference to *this</h2><p>为类实现赋值操作符时应该遵守的协议：赋值操作符必须返回一个reference指向操作符的左侧实参（左值）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>&#123;<br><span class="hljs-keyword">public</span>:<br>...<br>Widget&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)&#123;<br>...<br><span class="hljs-comment">// 返回左侧对象</span><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-comment">// 对其他符号也适用</span><br>Widget&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> Widget&amp; rhs)&#123;<br>... <br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="11：在operator-中处理“自我赋值”"><a href="#11：在operator-中处理“自我赋值”" class="headerlink" title="11：在operator&#x3D;中处理“自我赋值”"></a>11：在operator&#x3D;中处理“自我赋值”</h2><p>自我赋值发生在对象赋值给自己，这种情况可能会隐式发生。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// px和py指向同一个对象</span><br>*px = *py;<br></code></pre></td></tr></table></figure><p>为了防止自我赋值时销毁自身</p><p><strong>1、自我检验</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> == &amp;rhs) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br><span class="hljs-keyword">delete</span> pb;<br>pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 这样做存在潜在的隐患：如果new失败会导致pb指向一片被删除的Bitmap</p><p><strong>2、使用拷贝实现自我赋值</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)&#123;<br>Bitmap* pOrig = pb;<br>pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.bp);<br><span class="hljs-keyword">delete</span> pOrig;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样即使new失败也能保证pb的指向是安全的。但是这样会导致多一次拷贝构造，影响效率。</p><p><strong>3、使用copy and swap技术</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>&#123;<br>...<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Widget &amp;rhs)</span></span>;<br>...<br>&#125;;<br>Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget &amp;rhs)&#123;<br> Widget <span class="hljs-built_in">temp</span>(rhs);<br> <span class="hljs-built_in">swap</span>(temp);<br> <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="12：复制对象时勿忘其每一个成分"><a href="#12：复制对象时勿忘其每一个成分" class="headerlink" title="12：复制对象时勿忘其每一个成分"></a>12：复制对象时勿忘其每一个成分</h2><p>为一个类增加一个成员变量，必须同时修改拷贝函数。</p><p>在继承类的拷贝函数中，必须小心的复制其基类的部分，通常它们是private的，需要通过派生类调用基类的拷贝构造函数&#x2F;拷贝赋值运算符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">PriorityCustomer::<span class="hljs-built_in">PriorityCustomer</span>(<span class="hljs-type">const</span> PriorityCustomer &amp;rhs)<br>:<span class="hljs-built_in">Customer</span>(rhs), <span class="hljs-built_in">priority</span>(rhs.priority)<br>&#123;<br><span class="hljs-built_in">logCall</span>(<span class="hljs-string">&quot;PriorityCustomer copy constructor&quot;</span>);<br>&#125;<br>PriorityCustomer&amp; PriorityCustomer::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> PriorityCustomer &amp;rhs)&#123;<br><span class="hljs-built_in">logCall</span>(<span class="hljs-string">&quot;PriorityCustomer copy assignment operator&quot;</span>);<br>Customer::<span class="hljs-keyword">operator</span>=(rhs);<span class="hljs-comment">// 对基类成分进行赋值操作</span><br>priority = rhs.priority;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="13：以对象管理资源"><a href="#13：以对象管理资源" class="headerlink" title="13：以对象管理资源"></a>13：以对象管理资源</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//在工厂模式中</span><br><span class="hljs-function">Investment* <span class="hljs-title">createInvestment</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;<br>Invesetment *pInv = <span class="hljs-built_in">creatInvestment</span>();<br>... <span class="hljs-comment">// 可能存在过早的退出，或者异常</span><br><span class="hljs-keyword">delete</span> pInv;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于在…代码块中过早的退出，或者触发异常以及人为的遗忘delete到会导致内存泄漏。</p><p>为了确保<code>createInvestment()</code>返回的资源总是被释放，我们需要将资源放入对象内，依靠析构函数自动调用确保资源正确被释放（即为RAII对象）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">// 使用auto_ptr管理</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-function">std::auto_ptr&lt;Investment&gt; <span class="hljs-title">pInv</span><span class="hljs-params">(createInvestment())</span></span>;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>以对象管理资源的两个关键想法：</p><ul><li>获得资源后立即放入管理对象内。“以对象管理资源”的观念常被称为 RAII（Resource Acquisition Is Initialization);</li><li>管理对象运用析构函数确保资源被释放。</li></ul><p>由于<code>std::auto_ptr</code>不能同时指向同一个对象。如果通过copy构造函数或者copy assignmen操作符复制它们，它们将变成null</p><p>使用<code>std::shared_ptr</code>就不会有这个问题，因此建议使用<code>std::shared_ptr</code></p><h2 id="14：在资源管理类中小心copy行为"><a href="#14：在资源管理类中小心copy行为" class="headerlink" title="14：在资源管理类中小心copy行为"></a>14：在资源管理类中小心copy行为</h2><p>当需要建立自己的RAII对象时，需要明确对象被复制后发生的行为，多数情况下有以下两种选择：</p><ul><li><strong>禁止复制</strong>。许多时候允许RAII对象被复制并不合理。如果复制动作对RAII对象不合理，应该明确禁止；</li><li><strong>对底层资源使用引用计数法</strong>。当希望保有资源直到最后一个使用对象被销毁，这时候复制RAII对象应该将资源的引用计数递增；</li></ul><p>通常只需要内含一个<code>std::shared_ptr</code>成员变量，RAII类就可以实现引用计数复制行为。通过<strong>自定义<code>std::shared_ptr</code> 的删除器</strong>，就可以实现指定的删除。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lock</span><span class="hljs-params">(Mutex *pm)</span></span>;<span class="hljs-comment">// 锁住pm</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">(Mutex *pm)</span></span>; <span class="hljs-comment">// 解锁pm</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Lock</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// unlock是指定的删除器，mutexPtr析构函数将在引用计数为0时调用unlock</span><br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Lock</span><span class="hljs-params">(Mutex* pm)</span>:mutexPtr(pm, unlock)&#123;</span><br><span class="hljs-built_in">lock</span>(mutexPtr.<span class="hljs-built_in">get</span>());<br>&#125;<br><span class="hljs-keyword">private</span>:<br>std::shared_ptr&lt;Mutex&gt; mutexPtr;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其它的选择：</p><ul><li>复制底部资源。在此情况下复制资源管理对象，应该同时复制其包含的资源。</li><li>转移底部资源的拥有权。在某些罕见场合下需要确保永远只有一个RAII对象指向一个未加工资源，即使发生了复制。如<code>std::auto_ptr</code></li></ul><h2 id="15：在资源管理类中提供对原始资源的访问"><a href="#15：在资源管理类中提供对原始资源的访问" class="headerlink" title="15：在资源管理类中提供对原始资源的访问"></a>15：在资源管理类中提供对原始资源的访问</h2><p>有些时候需要直接访问原始资源，需要有一个函数将RAII对象转化为原始资源，通过以下两个方法：</p><p><strong>1、显示转化：</strong></p><p>如<code>std::shared_ptr</code>提供了<code>get()</code>成员函数，用来执行显示转化。</p><p><strong>2、隐式转化：</strong></p><p><code>std::shared_ptr</code>同时重载了操作符operator-&gt;和operator*，它们允许隐式转化至底部原始指针。</p><p>有时还是必须取得RAII对象内的原始资源，提供隐式转换函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">FontHandle <span class="hljs-title">getFont</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">releaseFont</span><span class="hljs-params">(FontHandle fh)</span></span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Font</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Font</span><span class="hljs-params">(FontHandle fh)</span>:f(fh)&#123;</span>&#125;<br>~<span class="hljs-built_in">Font</span>()&#123;<br><span class="hljs-built_in">releaseFont</span>(f);<br>&#125;<br><span class="hljs-comment">// 显示转化函数</span><br><span class="hljs-function">FontHandle <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br><span class="hljs-keyword">return</span> f;<br>&#125;<br><span class="hljs-comment">// 隐式转化函数</span><br><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">FontHandle</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br><span class="hljs-keyword">return</span> f;<br>&#125;<br><span class="hljs-keyword">private</span>:<br>FontHandle f;<br>&#125;;<br></code></pre></td></tr></table></figure><p>但是隐式转化函数会增加错误发生的机率。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Font <span class="hljs-title">f1</span><span class="hljs-params">(getFont())</span></span>;<br>...<br>FontHandle f2 = f1; <span class="hljs-comment">// 将f1隐式转化为FontHandle后复制它</span><br></code></pre></td></tr></table></figure><p>当f1被销毁，字体释放，f2就会成为悬垂的。</p><p>​                                                                  </p><h2 id="16：成对使用new和delete时要采取相同形式"><a href="#16：成对使用new和delete时要采取相同形式" class="headerlink" title="16：成对使用new和delete时要采取相同形式"></a>16：成对使用new和delete时要采取相同形式</h2><p>使用new，有两件事发生。第一，内存被名为operator new的函数分配出来；第二，针对内存会有构造函数被调用。对于delete，先调用析构函数，然后使用operator delete释放内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string *stringPtr1 = <span class="hljs-keyword">new</span> std::string;<br>std::string *stringPtr2 = <span class="hljs-keyword">new</span> std::string[<span class="hljs-number">100</span>];<br>...<br><span class="hljs-keyword">delete</span> stringPtr1;<br><span class="hljs-comment">//delete [] stringptr1  错误，未定义的行为 </span><br><span class="hljs-keyword">delete</span> [] stringPtr2;<br><span class="hljs-comment">//delete stringPtr2;  错误，未定义的行为</span><br></code></pre></td></tr></table></figure><p>如果调用new时使用[],必须在delete时也使用[]，反之亦然。</p><h2 id="17：以独立语句将newed对象置入智能指针"><a href="#17：以独立语句将newed对象置入智能指针" class="headerlink" title="17：以独立语句将newed对象置入智能指针"></a>17：以独立语句将newed对象置入智能指针</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">// 说明C++参数的构建顺序是不确定的</span><br><span class="hljs-comment">// 函数定义</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">priority</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processWidget</span><span class="hljs-params">(std::shared_ptr&lt;Widget&gt; pw, <span class="hljs-type">int</span> priority)</span></span>;<br><br><span class="hljs-comment">// 调用</span><br><span class="hljs-comment">//processWidget(new Widget, priority());// 调用将失败，由于不存在Widget*到std::shared_ptr&lt;Widget&gt; </span><br><span class="hljs-built_in">processWidget</span>(std::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;(<span class="hljs-keyword">new</span> Widet), <span class="hljs-built_in">priority</span>());<span class="hljs-comment">// 成功的调用，但是可能导致资源泄露</span><br></code></pre></td></tr></table></figure><p>执行上面的函数有三件事：1、调用new Widget 2、调用<code>std::shared_ptr</code>构造函数 3、 调用priority()</p><p>但是它们的顺序确是不确定的，存在new Widget调用后，再调用priority()导致异常，从而智能指针接受不到的情况。</p><p>解决的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">// 先创建Widget放入智能指针，再作为参数</span><br><span class="hljs-function">std::shared_ptr&lt;Widget&gt; <span class="hljs-title">pw</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget)</span></span>;<br><span class="hljs-built_in">processWidget</span>(pw, <span class="hljs-built_in">priority</span>());<br></code></pre></td></tr></table></figure><h2 id="18：让接口容易被正确使用，不易被误用"><a href="#18：让接口容易被正确使用，不易被误用" class="headerlink" title="18：让接口容易被正确使用，不易被误用"></a>18：让接口容易被正确使用，不易被误用</h2><h2 id="19：设计class犹如设计type"><a href="#19：设计class犹如设计type" class="headerlink" title="19：设计class犹如设计type"></a>19：设计class犹如设计type</h2><p>C++中，当你定义了一个新class，也就定义了一个新type。如何设计高效的类，必须了解下面的问题：</p><ul><li>新type的对象应该如何被创建和销毁？</li><li>对象的初始化和对象的赋值该有什么样的差别？</li><li>新type的对象如果被passed by value，意味着什么？</li><li>什么是新type的“合法值”</li><li>你的新type需要配合某个继承系吗？</li><li>你的新type需要什么样的转化？</li><li>什么样的操作符和函数对此新type而言是合理的？</li><li>什么样的标准函数应该驳回？</li><li>谁该取用新的type成员？</li><li>什么是新type的“未声明接口”？</li><li>新type有多么一般化？</li><li>你真需要一个新type吗？</li></ul><h2 id="20：宁以pass-by-reference-to-const替换pass-by-value"><a href="#20：宁以pass-by-reference-to-const替换pass-by-value" class="headerlink" title="20：宁以pass-by-reference-to-const替换pass-by-value"></a>20：宁以pass-by-reference-to-const替换pass-by-value</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>();<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Person</span>();<br><span class="hljs-keyword">private</span>:<br>std::string name; <span class="hljs-comment">// 成员变量</span><br>std::string address;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>: <span class="hljs-keyword">public</span> Person&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Student</span>();<br>~<span class="hljs-built_in">Student</span>();<br><span class="hljs-keyword">private</span>:<br>std::string schoolName;   <span class="hljs-comment">// 成员变量</span><br>std::string schoolAddress;<br>&#125;;<br><span class="hljs-comment">// 调用</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">validateStudent</span><span class="hljs-params">(Student s)</span></span>;<span class="hljs-comment">// 函数声明</span><br>Student plato;<br><span class="hljs-type">bool</span> platoIsOk = <span class="hljs-built_in">validateStudent</span>(plato); <span class="hljs-comment">// 以pass by value方式调用函数</span><br></code></pre></td></tr></table></figure><p>使用by value方式会导致一次Student拷贝构造，一次Person拷贝构造，四次string拷贝构造，六次析构函数！</p><p>而使用传递<strong>const引用参数能够避免这些构造和析构</strong>动作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">validateStudent</span><span class="hljs-params">(<span class="hljs-type">const</span> Student&amp; s)</span></span>;<br></code></pre></td></tr></table></figure><p>使用引用作为参数同时可以避免对象切割的问题</p><blockquote><p>对象切割：当继承类对象以值传递方式被视为基类对象，基类构造函数将被调用，造成继承类的特化性质被切割，仅仅留下一个基类对象。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">std::string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WindowWithScrollBars</span>: <span class="hljs-keyword">public</span> Window&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br><span class="hljs-comment">// 打印函数               使用const Window&amp; w参数就不会被切割</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printNameAndDisplay</span><span class="hljs-params">(Window w)</span></span>&#123;<br>    std::cout&lt;&lt;w.<span class="hljs-built_in">name</span>();<br>    w.<span class="hljs-built_in">display</span>();<br>&#125;<br><span class="hljs-comment">// 传递WindowWithScrollBars</span><br>WindowWithScrollBars wwsb;<br><span class="hljs-built_in">printNameAndDisplay</span>(wwsb);<span class="hljs-comment">// 总是调用Window::display</span><br></code></pre></td></tr></table></figure><p>一般而言，可以合理假设”pass by value”并不昂贵的对象为内置类型，STL迭代器和函数对象，其它都需要传递常量引用。</p><h2 id="21：必须返回对象时，别妄想返回其reference"><a href="#21：必须返回对象时，别妄想返回其reference" class="headerlink" title="21：必须返回对象时，别妄想返回其reference"></a>21：必须返回对象时，别妄想返回其reference</h2><p>并不是所有情况传递引用都是合理的。任何情况下看到一个reference声明式，都应该询问它的另一个名字是什么？</p><p>函数中创建新对象的途径有两种：在stack空间或者在heap空间创建。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 尝试在栈空间创建对象并返回引用，错误！</span><br><span class="hljs-type">const</span> Rational&amp; <span class="hljs-keyword">operator</span>* (<span class="hljs-type">const</span> Rational &amp;lhs, <span class="hljs-type">const</span> Rational &amp;rhs)&#123;<br><span class="hljs-function">Rational <span class="hljs-title">result</span><span class="hljs-params">(lhs.n * rhs.n, lhs.d * rhs.d)</span></span>;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>local对象将在函数返回前销毁，其引用将无定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 尝试在堆空间创建对象并返回引用，同样错误！</span><br><span class="hljs-type">const</span> Rational&amp; <span class="hljs-keyword">operator</span>* (<span class="hljs-type">const</span> Rational &amp;lhs, <span class="hljs-type">const</span> Rational &amp;rhs)&#123;<br>Rational *result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Rational</span>(lhs.n * rhs.n, lhs.d * rhs.d);<span class="hljs-comment">// 内存泄露</span><br><span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>没有办法取得reference背后的隐藏指针，导致无法释放new开辟的内存空间。</p><p>一个必须返回新对象的函数就应该让函数返回一个新对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 正确的写法</span><br><span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>* (<span class="hljs-type">const</span> Rational &amp;lhs, <span class="hljs-type">const</span> Rational &amp;rhs)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(lhs.n * rhs.n, lhs.d * rhs.d);<br>&#125;<br></code></pre></td></tr></table></figure><p>在现在的编译器中：编译器会进行RVO&#x2F;NRVO优化，直接构造出返回的对象，避免了拷贝构造。</p><h2 id="22：将成员变量声明为private"><a href="#22：将成员变量声明为private" class="headerlink" title="22：将成员变量声明为private"></a>22：将成员变量声明为private</h2><ul><li><p>语法一致性：客户唯一访问对象的方法就是通过成员函数。</p></li><li><p>实现访问控制：如果将成员变量声明为public，每个人都能读写；声明为private变量，通过成员函数来取得设定其值，可以实现“出准访问”，“只读访问”，“读写访问”。</p></li><li><p>封装：隐藏成员变量，只有成员函数可以影响它们，保留了日后变更实现的权利。如果不隐藏它们，当改变public类型变量将破坏大多数客户代码。从封装的角度观察：只有两种访问权限：private（提供封装）和其他（不提供封装）。</p></li></ul><h2 id="23：宁以non-member、non-friend替换member函数"><a href="#23：宁以non-member、non-friend替换member函数" class="headerlink" title="23：宁以non-member、non-friend替换member函数"></a>23：宁以non-member、non-friend替换member函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WebBrowser</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearCache</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearHistory</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeCookies</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 成员函数一次性调用清理</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearEverything</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">clearCache</span>();<br><span class="hljs-built_in">clearHistory</span>();<br><span class="hljs-built_in">removeCookies</span>();<br>&#125;<br>&#125;;<br><span class="hljs-comment">// 非成员函数一次性调用清理</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearBrowser</span><span class="hljs-params">(WebBrowser &amp;wb)</span></span>&#123;<br>wb.<span class="hljs-built_in">clearCache</span>();<br>wb.<span class="hljs-built_in">clearHistory</span>();<br>wb.<span class="hljs-built_in">removeCookies</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>采用哪一个版本的函数更好？</p><p>从封装的角度考虑：如果某些东西额被封装，它就不在可见。愈多的东西被封装，愈少的人能够看见。我们就能有愈大的弹性来改变它。我们计算能够访问数据的函数的数量，作为粗糙的度量。<strong>愈多的函数可访问它，数据的封装性愈低。</strong></p><p>因此：由于能够访问private成员变量的函数只有类的成员函数和友元函数，提供较大封装性的是non-member non-friend函数。</p><p>值得注意的是，只在意封装性让函数成为class的non-member并不意味着它不可以是另一个class的member</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 让non-member函数位于class的同一个命名空间</span><br><span class="hljs-keyword">namespace</span> WebBrowserStuff&#123;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WebBrowser</span>&#123; ... &#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearBrowser</span><span class="hljs-params">(WebBrowser &amp;wb)</span></span>;<br>&#125;<br><span class="hljs-comment">// 头文件&quot;webbrowserbookmarks.h&quot;</span><br><span class="hljs-keyword">namespace</span> WebBrowserStuff&#123;<br>    ...<span class="hljs-comment">// 与书签相关的便利函数</span><br>&#125;<br><span class="hljs-comment">// 头文件“webbrowsercookies.h&quot;</span><br><span class="hljs-keyword">namespace</span> WebBrowserStuff&#123;<br>    ...<span class="hljs-comment">// 与cookie相关的便利函数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>将所有便利函数放在多个头文件内但属于同一个命名空间，意味着客户可以轻松拓展便利函数。通过添加更多的non-member non-friend函数到此命名空间。</p><h2 id="24：若所有参数皆需类型转换，请为此采用non-member函数"><a href="#24：若所有参数皆需类型转换，请为此采用non-member函数" class="headerlink" title="24：若所有参数皆需类型转换，请为此采用non-member函数"></a>24：若所有参数皆需类型转换，请为此采用non-member函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 将operator*写成成员函数的写法</span><br><span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>* (<span class="hljs-type">const</span> Rational &amp;rhs) <span class="hljs-type">const</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>当需要混合运算就会出现错误</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Ratinoal <span class="hljs-title">oneHalf</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>Rational result = oneHalf * <span class="hljs-number">2</span>;<span class="hljs-comment">// 正确 2被隐式类型转化了</span><br>Rational result = <span class="hljs-number">2</span> * oneHalf;<span class="hljs-comment">// 错误 2不在*参数内，不能隐式转化</span><br></code></pre></td></tr></table></figure><p>只有当参数被列于参数列内，这个参数才是隐式类型转化的合格参与者。</p><p>将operator*成为一个non-member函数，让编译器在每一个实参上进行隐式类型转化：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-keyword">const</span> <span class="hljs-built_in">Rational</span> operator*(<span class="hljs-keyword">const</span> <span class="hljs-built_in">Rational</span>&amp; lhs, <span class="hljs-keyword">const</span> <span class="hljs-built_in">Rational</span> &amp;rhs)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator());<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Rational result <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * oneHalf<span class="hljs-comment">;// 这样就能通过编译了</span><br></code></pre></td></tr></table></figure><p>本例中operator操作都能够通过共有接口来实现，因此就不需要将这个函数声明为friend函数了。</p><h2 id="25：考虑写出一个不抛出异常的swap函数"><a href="#25：考虑写出一个不抛出异常的swap函数" class="headerlink" title="25：考虑写出一个不抛出异常的swap函数"></a>25：考虑写出一个不抛出异常的swap函数</h2><p>当</p><h2 id="26：尽可能延后变量定义式出现的时间"><a href="#26：尽可能延后变量定义式出现的时间" class="headerlink" title="26：尽可能延后变量定义式出现的时间"></a>26：尽可能延后变量定义式出现的时间</h2><p>不应该只延后变量的定义，尝试延后定义直到能够赋予它初值为止。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 对于下面两个方法</span><br><span class="hljs-comment">// 方法A：定义在循环外</span><br>Widget w;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)&#123;<br>w = 取决于i的值；<br>&#125;<br><span class="hljs-comment">// 方法B：定义于循环内</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)&#123;<br>Widget <span class="hljs-built_in">w</span>(取决于i的值);<br>&#125;<br></code></pre></td></tr></table></figure><p>除非效率优先否则应该尽量使用方法B。</p><h2 id="27：尽量少做转型动作"><a href="#27：尽量少做转型动作" class="headerlink" title="27：尽量少做转型动作"></a>27：尽量少做转型动作</h2><h2 id="28：避免返回handles指向对象内部部分"><a href="#28：避免返回handles指向对象内部部分" class="headerlink" title="28：避免返回handles指向对象内部部分"></a>28：避免返回handles指向对象内部部分</h2><h2 id="29：为”异常安全“而努力是值得的"><a href="#29：为”异常安全“而努力是值得的" class="headerlink" title="29：为”异常安全“而努力是值得的"></a>29：为”异常安全“而努力是值得的</h2><h2 id="30：透彻了解inlining的里里外外"><a href="#30：透彻了解inlining的里里外外" class="headerlink" title="30：透彻了解inlining的里里外外"></a>30：透彻了解inlining的里里外外</h2><p>在做出任何有关inline的决定之前，都应该注意这个条款。</p><h2 id="31：将文件间的编译依存关系降至最低"><a href="#31：将文件间的编译依存关系降至最低" class="headerlink" title="31：将文件间的编译依存关系降至最低"></a>31：将文件间的编译依存关系降至最低</h2><p><a href="https://www.cnblogs.com/jerry19880126/p/3551836.html">读书笔记_Effective_C++_条款三十一：将文件间的编译依存关系降至最低（第一部分） - Jerry19880126 - 博客园 (cnblogs.com)</a></p><h2 id="32：确定你的public继承塑模出is-a关系"><a href="#32：确定你的public继承塑模出is-a关系" class="headerlink" title="32：确定你的public继承塑模出is-a关系"></a>32：确定你的public继承塑模出is-a关系</h2><h2 id="33：避免遮掩继承而带来的名称"><a href="#33：避免遮掩继承而带来的名称" class="headerlink" title="33：避免遮掩继承而带来的名称"></a>33：避免遮掩继承而带来的名称</h2><h2 id="34：区分接口继承和接口实现"><a href="#34：区分接口继承和接口实现" class="headerlink" title="34：区分接口继承和接口实现"></a>34：区分接口继承和接口实现</h2><h2 id="35：考虑virtual函数以外的其它选择"><a href="#35：考虑virtual函数以外的其它选择" class="headerlink" title="35：考虑virtual函数以外的其它选择"></a>35：考虑virtual函数以外的其它选择</h2><h2 id="36：绝不重新定义继承而来的non-virtual函数"><a href="#36：绝不重新定义继承而来的non-virtual函数" class="headerlink" title="36：绝不重新定义继承而来的non-virtual函数"></a>36：绝不重新定义继承而来的non-virtual函数</h2><h2 id="37：绝不重新定义继承而来的缺省参数值"><a href="#37：绝不重新定义继承而来的缺省参数值" class="headerlink" title="37：绝不重新定义继承而来的缺省参数值"></a>37：绝不重新定义继承而来的缺省参数值</h2><h2 id="38：通过复合塑模出has-a或”根据某物实现出“"><a href="#38：通过复合塑模出has-a或”根据某物实现出“" class="headerlink" title="38：通过复合塑模出has-a或”根据某物实现出“"></a>38：通过复合塑模出has-a或”根据某物实现出“</h2><p>复合是类型之间的一种关系，当某种类型的对象内含它种类型对象就是复合。</p><p>复合同义词：分层、内含、聚合、内嵌。</p><p>复合有两个意义：意味着<strong>has-a</strong>或者<strong>根据某物实现出</strong></p><p>区分is-a和根据某物实现出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 例如set可以根据一个list实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Set</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">member</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;item)</span> <span class="hljs-type">const</span></span>;<br>...<br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// 内含list，根据list实现</span><br>std::list&lt;T&gt; rep;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="39：明智而审慎地使用private继承"><a href="#39：明智而审慎地使用private继承" class="headerlink" title="39：明智而审慎地使用private继承"></a>39：明智而审慎地使用private继承</h2><h2 id="40：明智而审慎地使用多重继承"><a href="#40：明智而审慎地使用多重继承" class="headerlink" title="40：明智而审慎地使用多重继承"></a>40：明智而审慎地使用多重继承</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Qt</title>
    <link href="/2024/07/31/Qt/"/>
    <url>/2024/07/31/Qt/</url>
    
    <content type="html"><![CDATA[<p><strong>《总之，好记性不如烂笔头！把你遗忘的都记下来吧！》</strong></p><h3 id="Qt基础"><a href="#Qt基础" class="headerlink" title="Qt基础"></a>Qt基础</h3><h4 id="Qt元对象编辑器moc"><a href="#Qt元对象编辑器moc" class="headerlink" title="Qt元对象编辑器moc"></a>Qt元对象编辑器moc</h4><p>元对象编辑器moc是负责解析c++中不存在的例如：signals、slot、emit等关键字，moc通过解析包含Q_OBJECT宏的类，生成能够处理信号和槽连接代码。</p><p>解析属性宏，生成相应的代码。</p><p>能使得Qt在运行时进行反射操作，比如查找类的方法、属性以及信号的槽。</p><h4 id="Qt元对象系统："><a href="#Qt元对象系统：" class="headerlink" title="Qt元对象系统："></a>Qt元对象系统：</h4><p>元对象系统是Qt框架中独特的拓展，用来增强C++语言动态特性。</p><p>使用元对象系统必须包括以下三个方面：</p><p>1、QObject类是所有使用元对象系统的类的基类</p><p>2、必须在一个类的开头部分插入宏Q_OBJECT，这样这个类才能使用元对象系统的特性。</p><p>3、MOC为每个QObject的子类提供必要的代码实现元对象系统的特性。</p><p>支持的特性：</p><ul><li>动态属性系统</li><li>信号和槽机制</li><li>反射机制</li><li>动态类型信息</li></ul><h2 id="坐标系统"><a href="#坐标系统" class="headerlink" title="坐标系统"></a>坐标系统</h2><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240528103326318.png" alt="image-20240528103326318" style="zoom: 80%;" /><p>获取当前标签位置:</p><p>pos()函数返回的是子窗口的左上角相对于父窗口的位置：</p><p><code>QPoint pos = ui-&gt;pushButton-&gt;pos();</code></p><p>mapToGlobal()函数返回控件的左上角坐标相对于整个屏幕的坐标</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">QPoint pos <span class="hljs-operator">=</span> ui-&gt;pushButton-&gt;pos()<span class="hljs-comment">; </span><br>QPoint posLeftUp <span class="hljs-operator">=</span> w.mapToGlobal(pos)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>而对于事件QEvent，通过gloPos()函数可以直接获取事件的屏幕坐标</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">QPoint point <span class="hljs-operator">=</span> event-&gt;globalPos()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h2 id="类继承关系"><a href="#类继承关系" class="headerlink" title="类继承关系"></a>类继承关系</h2><p><img src="https://img-blog.csdnimg.cn/20200618175807591.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyOTU2MTc5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="QWidget"><a href="#QWidget" class="headerlink" title="QWidget"></a>QWidget</h2><p>属性：</p><blockquote><p>sizePolicy 类型 QSizePolicy定义了组件在水平和垂直方向上的尺寸变化策略</p></blockquote><blockquote><p>QSizePolicy::fixed: 固定尺寸， QWidget的sizeHint()函数返回组件的建议尺寸作为组件的固定尺寸，即使使用了布局管理，组件也不会被放大或者缩小</p></blockquote><p>作为窗口：</p><blockquote><p>windowOpacity  设置窗口的透明度</p></blockquote><p>信号：</p><blockquote><p>void customContextMenuRequested(const QPoint &amp;pos) 在组件上点击鼠标右键时发射，可以用于创建组件的快捷菜单</p></blockquote><h2 id="QPushButton"><a href="#QPushButton" class="headerlink" title="QPushButton"></a>QPushButton</h2><p>设置按钮背景图的方式</p><p>​0、通过设置图标Icon来设置图片背景</p><p>​1、通过QSS 设置 border-image</p><p>​2、自定义继承按钮类，通过重写paintEvent,重画背景图片</p><h2 id="QAction"><a href="#QAction" class="headerlink" title="QAction"></a>QAction</h2><h2 id="QMenu"><a href="#QMenu" class="headerlink" title="QMenu"></a>QMenu</h2><h2 id="QLineEdit"><a href="#QLineEdit" class="headerlink" title="QLineEdit"></a>QLineEdit</h2><h2 id="QToolButton"><a href="#QToolButton" class="headerlink" title="QToolButton"></a>QToolButton</h2><h2 id="QTimer"><a href="#QTimer" class="headerlink" title="QTimer"></a>QTimer</h2><p>创建定时器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">QTime *m_timeWait = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QTimer</span>(<span class="hljs-keyword">this</span>);<br><span class="hljs-comment">// 定时器时间</span><br>m_timeWait-&gt;<span class="hljs-built_in">setInterval</span>(<span class="hljs-number">5000</span>);<br><span class="hljs-comment">// 开启定时器</span><br>m_timeWait-&gt;<span class="hljs-built_in">start</span>();<br><span class="hljs-comment">// 定时结束绑定事件处理</span><br><span class="hljs-built_in">connect</span>(m_timeWait, <span class="hljs-built_in">SIGNAL</span>(<span class="hljs-built_in">timeout</span>()), <span class="hljs-keyword">this</span>, <span class="hljs-built_in">SLOT</span>(<span class="hljs-built_in">doTimeSwitch</span>()));<br></code></pre></td></tr></table></figure><p>创建单次定时器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">m_animWait = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QTimer</span>(<span class="hljs-keyword">this</span>);<br>m_animWait-&gt;<span class="hljs-built_in">singleShot</span>(m_animContinue, Qt::PreciseTimer, <span class="hljs-keyword">this</span>, [<span class="hljs-keyword">this</span>]()&#123;<br>m_isAllowedLR = <span class="hljs-literal">true</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="QTreeWidget"><a href="#QTreeWidget" class="headerlink" title="QTreeWidget"></a>QTreeWidget</h2><p>一个QTreeWidget组件显示内容分为表头和目录树两部分，表头和目录树结点都是QTreeWidgetItem对象</p><p><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240707225650834.png" alt="image-20240707225650834"></p><p><strong>顶层节点：</strong>目录树中一行就是一个节点，目录树中最上层的节点成为顶层节点，<strong>顶层节点没有父节点，一个目录树中可以有多个顶层节点</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addTopLevelItem</span><span class="hljs-params">(QTreeWidgetItem *item)</span></span>;<span class="hljs-comment">// 添加一个顶层节点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">indexOfTopLevelItem</span><span class="hljs-params">(QTreeWidgetItem *item)</span></span>; <span class="hljs-comment">// 返回一个顶层节点的序列号</span><br></code></pre></td></tr></table></figure><p>**次级节点:**所有次级节点都直接或者间接挂在某个顶层节点下面。</p><p><strong>隐藏的根节点：</strong>目录树中有一个隐藏的根节点，是所有顶层节点的父节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">QTreeWidgetItem *<span class="hljs-title">QTreeWidget::invisibleRootItem</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 获取隐藏的根节点</span><br></code></pre></td></tr></table></figure><h3 id="QTreeWidgetItem"><a href="#QTreeWidgetItem" class="headerlink" title="QTreeWidgetItem"></a>QTreeWidgetItem</h3><p><strong>构造QTreeWidgetItem</strong>：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">QTreeWidgetItem(int <span class="hljs-keyword">type</span> <span class="hljs-type">= </span><span class="hljs-keyword">Type</span>);<br></code></pre></td></tr></table></figure><p>可以传递一个整数表示节点类型，这个类型是自定义的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">TreeItemType</span>&#123;<br>    TreeItemPro = <span class="hljs-number">1</span>,<br>    TreeItemDir = <span class="hljs-number">2</span>,<br>    TreeItemPic = <span class="hljs-number">3</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后可以通过<code>QTreeWidget::addTopLevelItem()</code>添加到顶层节点，或者通过<code>QTreeWidgetItem::addChild()</code>将其添加为一个节点的子节点。</p><p><strong>设置节点中每一列数据：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">item-&gt;<span class="hljs-built_in">setText</span>(<span class="hljs-number">0</span>, name);<br>item-&gt;<span class="hljs-built_in">setIcon</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">QIcon</span>(<span class="hljs-string">&quot;:/icon/icon/dir.png&quot;</span>));<br>item-&gt;<span class="hljs-built_in">setToolTip</span>(<span class="hljs-number">0</span>, src_path);<br><span class="hljs-comment">// 使用另一种方式    </span><br>item-&gt;<span class="hljs-built_in">setData</span>(<span class="hljs-number">0</span>, Qt::DisplayRole, name); <span class="hljs-comment">// 使用DisplayRole设置文本</span><br>item-&gt;<span class="hljs-built_in">setData</span>(<span class="hljs-number">0</span>, Qt::DecorationRole, <span class="hljs-built_in">QIcon</span>(<span class="hljs-string">&quot;:/icon/icon/dir.png&quot;</span>)); <span class="hljs-comment">// 使用DecorationRole设置图标</span><br>item-&gt;<span class="hljs-built_in">setData</span>(<span class="hljs-number">0</span>, Qt::ToolTipRole, src_path); <span class="hljs-comment">// 使用ToolTipRole设置提示</span><br></code></pre></td></tr></table></figure><h2 id="QLayout"><a href="#QLayout" class="headerlink" title="QLayout"></a>QLayout</h2><p><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240602003656723.png" alt="image-20240602003656723"></p><p><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240602003920702.png" alt="image-20240602003920702"><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240602003951337.png" alt="image-20240602003951337"></p><blockquote><p>setMargins();</p></blockquote><blockquote><p>setContentMargins();</p><p>作用：将多个控件当作一个整体，保证这个整体离布局的距离为(Left, Top, Right, Bottom)这几个参数。</p></blockquote><p>控件间距调整：</p><blockquote><p>setSpacing()</p><p>作用：设置某个布局下各个控件之间的间距</p></blockquote><p>弹簧布局：</p><blockquote><p>addStretch() setStretch()</p><p>作用：增加弹簧布局，参数大小代表弹簧弹力，不同的弹力大小代表控件比例，同类型的函数还有 setStretchFactor()。</p></blockquote><h4 id="QHBoxLayout"><a href="#QHBoxLayout" class="headerlink" title="QHBoxLayout"></a>QHBoxLayout</h4><p>水平布局</p><h4 id="QVBoxLayout"><a href="#QVBoxLayout" class="headerlink" title="QVBoxLayout"></a>QVBoxLayout</h4><p>垂直布局</p><h4 id="QGridLayout"><a href="#QGridLayout" class="headerlink" title="QGridLayout"></a>QGridLayout</h4><p>网格布局</p><h4 id="QFromLayout"><a href="#QFromLayout" class="headerlink" title="QFromLayout"></a>QFromLayout</h4><p>表单布局，适用于两列管理的布局</p><h4 id="QStackedLayout"><a href="#QStackedLayout" class="headerlink" title="QStackedLayout"></a>QStackedLayout</h4><p>堆叠布局，适用于多个页面切换的布局</p><h3 id="QSpacerItem"><a href="#QSpacerItem" class="headerlink" title="QSpacerItem"></a>QSpacerItem</h3><p>布局中的占位符，可以用来填充剩余空间</p><h3 id="QSplitter"><a href="#QSplitter" class="headerlink" title="QSplitter"></a>QSplitter</h3><p>分割条组件类，用来水平或者竖直的分割两个界面组件，使得两个控件所占空间能够随时改变</p><h2 id="QEvent"><a href="#QEvent" class="headerlink" title="QEvent"></a>QEvent</h2><p>什么情况是事件接受，什么情况是事件被接受</p><p>event-&gt;button()</p><p>返回单次按下的按键，不包括按下</p><p>event-&gt;buttons()</p><p>返回按下的组合按键，包括之前已经按下但未松开的按钮</p><p>Event-&gt;buttons()的返回是 Qt::MouseButton<br>返回值为以下几种类型：</p><table><thead><tr><th align="center">Qt::NoButton</th><th align="center">0x00000000</th></tr></thead><tbody><tr><td align="center">Qt::LeftButton</td><td align="center">0x00000001</td></tr><tr><td align="center">Qt::RightButton</td><td align="center">0x00000002</td></tr><tr><td align="center">Qt::MidButton</td><td align="center">0x00000004</td></tr></tbody></table><p>当左键按下时，返回值是1   右键 2    中键 4    左+右 3     左+中 5     右+中 6   左右中 7</p><h2 id="QMimeData"><a href="#QMimeData" class="headerlink" title="QMimeData"></a>QMimeData</h2><h2 id="QDialog"><a href="#QDialog" class="headerlink" title="QDialog"></a>QDialog</h2><h3 id="窗口类的重要特性设置"><a href="#窗口类的重要特性设置" class="headerlink" title="窗口类的重要特性设置"></a>窗口类的重要特性设置</h3><p>窗口显示或运行的一些特性可以通过QWidget的一些函数设置，如setAttribute() , setWindowFlag(), setWindowState()</p><p>模态（modal）窗口：窗口弹出后，没关闭之前，<strong>不可以</strong>对同一应用程序的其他窗口进行操作；<br>非模态（modeless）窗口：窗口弹出后，没关闭之前，<strong>可以</strong>对同一应用程序的其他窗口进行操作，可以同时和多个窗口进行交互；</p><h4 id="setAttribute"><a href="#setAttribute" class="headerlink" title="setAttribute()"></a>setAttribute()</h4><p>![1717816731342](D:\Documents\Tencent Files\2920611818\FileRecv\MobileFile\1717816731342.jpg)</p><h4 id="setWindowFlag"><a href="#setWindowFlag" class="headerlink" title="setWindowFlag()"></a>setWindowFlag()</h4><p>![1717816795244](D:\Documents\Tencent Files\2920611818\FileRecv\MobileFile\1717816795244.jpg)</p><img src="D:\Documents\Tencent Files\2920611818\FileRecv\MobileFile\1717817924752.jpg" alt="1717817924752" style="zoom: 67%;" /><h4 id="setWindowState"><a href="#setWindowState" class="headerlink" title="setWindowState()"></a>setWindowState()</h4><p>![1717817721460](D:\Documents\Tencent Files\2920611818\FileRecv\MobileFile\1717817721460.jpg)</p><h4 id="setWindowModality"><a href="#setWindowModality" class="headerlink" title="setWindowModality()"></a>setWindowModality()</h4><p>![1717817816783](D:\Documents\Tencent Files\2920611818\FileRecv\MobileFile\1717817816783.jpg)</p><h3 id="QFileDialog文件对话框"><a href="#QFileDialog文件对话框" class="headerlink" title="QFileDialog文件对话框"></a>QFileDialog文件对话框</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>QString getOpenFileName()</td><td>选择打开一个文件，返回选择文件的文件名</td></tr><tr><td>QStringList getOpenFileName()</td><td>选择打开多个文件，返回选择的所有文件的文件名列表</td></tr><tr><td>QString getSaveFileName()</td><td>选择保存一个文件，返回保存的文件的文件名</td></tr><tr><td>QString getExistingDirectory()</td><td>选择一个已有的目录，返回所选目录的完整路径</td></tr><tr><td>QUrl getOpenFileUrl()</td><td>选择打开一个文件，可选择打开远程网络文件</td></tr><tr><td>void SaveFileContent()</td><td>将一个QByteArray类型的字节数据数组的内容保存为文件</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 使用过滤的方法打开一个文件</span><br>QString curPath = QDir::<span class="hljs-built_in">currentPath</span>();<br>QString filter = <span class="hljs-string">&quot;程序文件(*.h *.cpp);;文本文件(*.txt);;所有文件(*.*)&quot;</span>;<br>QString fileLog = QFileDialog::<span class="hljs-built_in">getOpenFileName</span>(<span class="hljs-keyword">this</span>,<span class="hljs-string">&quot;选择一个文件 &quot;</span>,curPath, filter);<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 保存一个文件</span><br>QString curPath = QDir::<span class="hljs-built_in">currentPath</span>();<br>QString filter = <span class="hljs-string">&quot;h 文件(*.h);;C++文件(*.cpp);;文本文件(*.txt);;所有文件(*.*)&quot;</span>;<br>QString aFileName = QFileDialog::<span class="hljs-built_in">getSaveFileName</span>(<span class="hljs-keyword">this</span>,<span class="hljs-string">&quot;另存文件夹 &quot;</span>,curPath,filter);<br><span class="hljs-keyword">if</span>(aFileName.<span class="hljs-built_in">isEmpty</span>())<br><span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// 设置当前目录为打开的另存目录</span><br><span class="hljs-function">QFileInfo <span class="hljs-title">fileInfo</span><span class="hljs-params">(aFileName)</span></span>;<br>QDir::<span class="hljs-built_in">setCurrent</span>(fileInfo.<span class="hljs-built_in">absolutePath</span>());<br><span class="hljs-function">QFile <span class="hljs-title">aFile</span><span class="hljs-params">(aFileName)</span></span>;<br><span class="hljs-keyword">if</span>(!aFile.<span class="hljs-built_in">open</span>(QIODevice::WriteOnly | QIODevice::Text))<br><span class="hljs-keyword">return</span> ;<br>QString str = ui-&gt;plainTextEdit-&gt;<span class="hljs-built_in">toPlainText</span>();<br>QByteArray strBytes = str.<span class="hljs-built_in">toUtf8</span>();<br>aFile.<span class="hljs-built_in">close</span>();<br></code></pre></td></tr></table></figure><h3 id="QColorDialog颜色对话框"><a href="#QColorDialog颜色对话框" class="headerlink" title="QColorDialog颜色对话框"></a>QColorDialog颜色对话框</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 使用静态函数打开颜色对话框</span><br><span class="hljs-function">QColor <span class="hljs-title">QColorDialog::getColor</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><h3 id="QFontDialog字体对话框"><a href="#QFontDialog字体对话框" class="headerlink" title="QFontDialog字体对话框"></a>QFontDialog字体对话框</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 打开字体对话框</span><br><span class="hljs-function">QFont <span class="hljs-title">QFontDialog::getFont</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><h3 id="QInputDialog标准输入对话框"><a href="#QInputDialog标准输入对话框" class="headerlink" title="QInputDialog标准输入对话框"></a>QInputDialog标准输入对话框</h3><h3 id="QMessageBox消息对话框"><a href="#QMessageBox消息对话框" class="headerlink" title="QMessageBox消息对话框"></a>QMessageBox消息对话框</h3><h2 id="QIODevice"><a href="#QIODevice" class="headerlink" title="QIODevice"></a>QIODevice</h2><h3 id="QCoreApplicaton"><a href="#QCoreApplicaton" class="headerlink" title="QCoreApplicaton"></a>QCoreApplicaton</h3><p>​为无UI应用程序提供事件循环的类，所有应用程序的基类，其子类QGuiApplication是具有GUI的应用程序类，具有主事件循环，能够处理和派发来自操作系统或者其他来源的事件。</p><p>QGuiApplication的子类QApplication为QWidget应用程序提供支持，包括界面的初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 设置应用程序组织名</span><br>QCoreApplication::<span class="hljs-built_in">setOrganizationName</span>(<span class="hljs-string">&quot;HAOKS&quot;</span>);<br><span class="hljs-comment">// 设置应用程序名</span><br>QCoreApplication::<span class="hljs-built_in">setApplicationName</span>(<span class="hljs-string">&quot;FILE TEST&quot;</span>);<br><span class="hljs-comment">// 获取可执行文件所在的完整文件目录</span><br>QString str = QCoreApplication::<span class="hljs-built_in">applicationDirPath</span>();<br><span class="hljs-comment">// 获取文件的完整执行目录</span><br>str.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;\n applicationFilePath: &quot;</span> + QApplication::<span class="hljs-built_in">applicationFilePath</span>());<br><span class="hljs-comment">// 获取文件名</span><br>str.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;\n applicationName: &quot;</span> + QApplication::<span class="hljs-built_in">applicationName</span>());<br>ui-&gt;plainTextEdit-&gt;<span class="hljs-built_in">appendPlainText</span>(str + <span class="hljs-string">&#x27;\n&#x27;</span>);<br><span class="hljs-comment">// 退出程序</span><br>QCoreApplication::<span class="hljs-built_in">exit</span>();<br></code></pre></td></tr></table></figure><h3 id="QFile"><a href="#QFile" class="headerlink" title="QFile"></a>QFile</h3><p>主要进行文件内容的读写，还可用于文件的操作，如复制文件，删除文件，重命名文件。</p><h3 id="QFileInfo"><a href="#QFileInfo" class="headerlink" title="QFileInfo"></a>QFileInfo</h3><p>用于获取文件的各种信息。</p><h3 id="QSaveFile"><a href="#QSaveFile" class="headerlink" title="QSaveFile"></a>QSaveFile</h3><p>QSaveFile专门用来保存文件，可以用来保存文本文件或二进制文件。</p><p>在保存文件时，QSaveFile会在目标问价所在的目录下创建一个临时文件，向文件写入数据是先写入临时文件，如果写入操作没有错误，调用QSaveFile的函数Commit()提交修改时临时文件里的内容才被移入目标文件，然后临时文件会被删除。</p><p>在调用函数commit()之间，如果写入操作产生异常导致程序异常结束，目标文件不会由损失，避免了破坏文件结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 利用QSaveFile保存文件</span><br>QString fileName = ui-&gt;lineEdit-&gt;<span class="hljs-built_in">text</span>();<br><span class="hljs-function">QSaveFile <span class="hljs-title">aFile</span><span class="hljs-params">(fileName)</span></span>;<br><span class="hljs-keyword">if</span>(!aFile.<span class="hljs-built_in">open</span>(QIODevice::WriteOnly | QIODevice::Text))<br><span class="hljs-built_in">qDebug</span>()&lt;&lt;<span class="hljs-string">&quot;open error&quot;</span>;<br>aFile.<span class="hljs-built_in">setDirectWriteFallback</span>(<span class="hljs-literal">false</span>);<br><span class="hljs-keyword">try</span>&#123;<br>QString str = ui-&gt;plainTextEdit-&gt;<span class="hljs-built_in">toPlainText</span>();<br>QByteArray strBytes = str.<span class="hljs-built_in">toUtf8</span>();<br>    <span class="hljs-comment">// 写入临时文件</span><br>aFile.<span class="hljs-built_in">write</span>(strBytes, strBytes.<span class="hljs-built_in">length</span>());<br>    <span class="hljs-comment">// 提交</span><br>aFile.<span class="hljs-built_in">commit</span>();<br>&#125;<span class="hljs-built_in">catch</span>(QException &amp;e)&#123;<br><span class="hljs-built_in">qDebug</span>()&lt;&lt;<span class="hljs-string">&quot;发生错误: &quot;</span>&lt;&lt;e.<span class="hljs-built_in">what</span>();<br>    <span class="hljs-comment">// 取消写入</span><br>aFile.<span class="hljs-built_in">cancelWriting</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="QDir"><a href="#QDir" class="headerlink" title="QDir"></a>QDir</h3><p>进行目录操作的类，在构造函数中传递一个目录字符串作为当前目录，或者使用setPath()设置目录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">QDir <span class="hljs-title">dir</span><span class="hljs-params">(<span class="hljs-string">&quot;C:/Users/web&quot;</span>)</span></span>;<br>dir.<span class="hljs-built_in">setPath</span>(<span class="hljs-string">&quot;C:/Users/web&quot;</span>);<br></code></pre></td></tr></table></figure><p>获取当前目录路径：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QString curPath = QDir::<span class="hljs-built_in">currentPath</span>();<br></code></pre></td></tr></table></figure><p>返回当前目录下的文件fileName的含有绝对路径的文件名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QString dist_path = dir.<span class="hljs-built_in">absoluteFilePath</span>(fileName);<br></code></pre></td></tr></table></figure><h3 id="QTemporaryDir"><a href="#QTemporaryDir" class="headerlink" title="QTemporaryDir"></a>QTemporaryDir</h3><p>用于创建临时目录</p><h3 id="QTemporaryFile"><a href="#QTemporaryFile" class="headerlink" title="QTemporaryFile"></a>QTemporaryFile</h3><p>用于创建临时文件，临时文件可以保存在系统的临时目录、指定目录或者应用程序当前目录下。QTemporaryFile的父类为QFile。</p><h3 id="QFileSystemWatcher"><a href="#QFileSystemWatcher" class="headerlink" title="QFileSystemWatcher"></a>QFileSystemWatcher</h3><p>对目录和文件进行监视的类，父类为QObject。把某些目录或者文件添加到QFileSystemWatcher对象的监视列表后；</p><p>当目录发生新建、删除文件等操作时，QFileSystemWatcher会发射directoryChanged()信号；</p><p>当所监视的文件发生修改、重命名等操作时，QFileSystemWatcher会发射fileChanged()信号。</p><h3 id="读写文本文件"><a href="#读写文本文件" class="headerlink" title="读写文本文件"></a>读写文本文件</h3><h4 id="1、使用QFile"><a href="#1、使用QFile" class="headerlink" title="1、使用QFile"></a>1、使用QFile</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 进行文件的读取</span><br><span class="hljs-function">QFile <span class="hljs-title">aFile</span><span class="hljs-params">(ui-&gt;lineEdit-&gt;text())</span></span>;<br><span class="hljs-keyword">if</span>(!aFile.<span class="hljs-built_in">exists</span>())<br><span class="hljs-keyword">return</span> ;<br><span class="hljs-keyword">if</span>(!aFile.<span class="hljs-built_in">open</span>(QIODevice::ReadOnly | QIODevice::WriteOnly))<br><span class="hljs-keyword">return</span> ;<br>QByteArray info = aFile.<span class="hljs-built_in">readAll</span>();<br>QString text = QString::<span class="hljs-built_in">fromUtf8</span>(info);<br>ui-&gt;plainTextEdit-&gt;<span class="hljs-built_in">appendPlainText</span>(text);<br>aFile.<span class="hljs-built_in">close</span>();<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 文件写入并保存</span><br>QString curPath = QDir::<span class="hljs-built_in">currentPath</span>();<br>QString filter = <span class="hljs-string">&quot;h 文件(*.h);;C++文件(*.cpp);;文本文件(*.txt);;所有文件(*.*)&quot;</span>;<br>QString aFileName = QFileDialog::<span class="hljs-built_in">getSaveFileName</span>(<span class="hljs-keyword">this</span>,<span class="hljs-string">&quot;另存文件夹 &quot;</span>,curPath,filter);<br><span class="hljs-keyword">if</span>(aFileName.<span class="hljs-built_in">isEmpty</span>())<br>    <span class="hljs-keyword">return</span>;<br><span class="hljs-comment">// *设置当前目录为打开的另存目录 （关键）</span><br><span class="hljs-function">QFileInfo <span class="hljs-title">fileInfo</span><span class="hljs-params">(aFileName)</span></span>;<br>QDir::<span class="hljs-built_in">setCurrent</span>(fileInfo.<span class="hljs-built_in">absolutePath</span>());<br><span class="hljs-function">QFile <span class="hljs-title">aFile</span><span class="hljs-params">(aFileName)</span></span>;<br><span class="hljs-keyword">if</span>(!aFile.<span class="hljs-built_in">open</span>(QIODevice::WriteOnly | QIODevice::Text))<br>    <span class="hljs-keyword">return</span> ;<br>QString str = ui-&gt;plainTextEdit-&gt;<span class="hljs-built_in">toPlainText</span>();<br>QByteArray strBytes = str.<span class="hljs-built_in">toUtf8</span>();<br><span class="hljs-comment">// 写入文件</span><br>aFile.<span class="hljs-built_in">write</span>(strBytes, strBytes.<span class="hljs-built_in">length</span>());<br>aFile.<span class="hljs-built_in">close</span>();<br></code></pre></td></tr></table></figure><h4 id="2、使用QFile和QTextStream"><a href="#2、使用QFile和QTextStream" class="headerlink" title="2、使用QFile和QTextStream"></a>2、使用QFile和QTextStream</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// QTextStream读取文件</span><br>QString fileName = ui-&gt;lineEdit-&gt;<span class="hljs-built_in">text</span>();<br><span class="hljs-function">QFile <span class="hljs-title">aFile</span><span class="hljs-params">(fileName)</span></span>;<br><span class="hljs-keyword">if</span>(!aFile.<span class="hljs-built_in">open</span>(QIODevice::ReadOnly | QIODevice::Text))<br><span class="hljs-built_in">qDebug</span>()&lt;&lt;<span class="hljs-string">&quot;open error&quot;</span>;<br><span class="hljs-function">QTextStream <span class="hljs-title">aStream</span><span class="hljs-params">(&amp;aFile)</span></span>;<br><span class="hljs-comment">// 自动检测Unicode</span><br>aStream.<span class="hljs-built_in">setAutoDetectUnicode</span>(<span class="hljs-literal">true</span>);<br>QString str = aStream.<span class="hljs-built_in">readAll</span>();<br>ui-&gt;plainTextEdit-&gt;<span class="hljs-built_in">setPlainText</span>(str);<br>aFile.<span class="hljs-built_in">close</span>();<br></code></pre></td></tr></table></figure><h3 id="读写二进制文件"><a href="#读写二进制文件" class="headerlink" title="读写二进制文件"></a>读写二进制文件</h3><p>可以单使用QFile读写二进制文件，一般结合使用QFile和QDataStream读写二进制文件。</p><h2 id="Qt-SQL"><a href="#Qt-SQL" class="headerlink" title="Qt SQL"></a>Qt SQL</h2><table><thead><tr><th>数据库连接</th><th>QSqlDataBase</th><th>用于建立与数据库连接</th></tr></thead><tbody><tr><td><strong>数据库中的对象</strong></td><td><strong>QSqlRecord</strong></td><td>表示数据表中一项记录的类</td></tr><tr><td></td><td><strong>QSqlField</strong></td><td>表示数据库或视图的字段的类</td></tr><tr><td></td><td><strong>QSqlIndex</strong></td><td>表示数据库中索引的类</td></tr><tr><td><strong>模型类</strong></td><td><strong>QSqlTableModel</strong></td><td>表示单个数据表的模型类</td></tr><tr><td></td><td><strong>QSqlQueryModel</strong></td><td>表示SQL查询结果数据的只读模型类</td></tr><tr><td><strong>其它功能类</strong></td><td><strong>QSqlQuery</strong></td><td>运行各种SQL语句的类</td></tr><tr><td></td><td><strong>QDataWidgetMapper</strong></td><td>用于建立界面组件与字段的映射关系的类</td></tr><tr><td></td><td><strong>QSqlError</strong></td><td>用于表示数据库错误信息的类，访问上一次的错误信息</td></tr><tr><td><strong>关系模型类</strong></td><td>QSqlRelationalTableModel</td><td>表示关系数据表的模型类</td></tr><tr><td></td><td>QSqlRelationalDelegate</td><td>用于QSqlRelationalTableModel模型的一个编辑字段的代理类，这个代理类提供一个QComboxBox组件作为编辑器</td></tr><tr><td></td><td>QSqlRelation</td><td>用于表示数据表外键信息的类</td></tr></tbody></table><h4 id="以ODBC为例连接MySQL数据库"><a href="#以ODBC为例连接MySQL数据库" class="headerlink" title="以ODBC为例连接MySQL数据库"></a><strong>以ODBC为例连接MySQL数据库</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 连接Mysql数据库</span><br>QSqlDatabase DB;<br>DB = QSqlDatabase::<span class="hljs-built_in">addDatabase</span>(<span class="hljs-string">&quot;QODBC&quot;</span>);<br>DB.<span class="hljs-built_in">setHostName</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br>DB.<span class="hljs-built_in">setPort</span>(<span class="hljs-number">3306</span>);<br>DB.<span class="hljs-built_in">setUserName</span>(<span class="hljs-string">&quot;root&quot;</span>);<br>DB.<span class="hljs-built_in">setPassword</span>(<span class="hljs-string">&quot;123456&quot;</span>);<br>DB.<span class="hljs-built_in">setDatabaseName</span>(<span class="hljs-string">&quot;hotel&quot;</span>);<br><span class="hljs-keyword">if</span>(!DB.<span class="hljs-built_in">open</span>())&#123;<br>    ui-&gt;labelDataBase-&gt;<span class="hljs-built_in">setText</span>(<span class="hljs-string">&quot;数据库连接失败！&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 创建数据模型，打开数据表</span><br>tabModel = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QSqlTableModel</span>(<span class="hljs-keyword">this</span>,DB);<br><span class="hljs-comment">// 设置数据表</span><br>tabModel-&gt;<span class="hljs-built_in">setTable</span>(<span class="hljs-string">&quot;user&quot;</span>);<br><span class="hljs-comment">// 设置数据保存方式</span><br>tabModel-&gt;<span class="hljs-built_in">setEditStrategy</span>(QSqlTableModel::OnManualSubmit);<br><span class="hljs-comment">// 数据排序方式</span><br>tabModel-&gt;<span class="hljs-built_in">setSort</span>(tabModel-&gt;<span class="hljs-built_in">fieldIndex</span>(<span class="hljs-string">&quot;account&quot;</span>),Qt::AscendingOrder);<br><span class="hljs-comment">// 利用数据排序规则和过滤规则刷新数据模型</span><br><span class="hljs-keyword">if</span>(!(tabModel-&gt;<span class="hljs-built_in">select</span>()))&#123;<br><span class="hljs-built_in">qDebug</span>()&lt;&lt;<span class="hljs-string">&quot;错误信息：&quot;</span>&lt;&lt;tabModel-&gt;<span class="hljs-built_in">lastError</span>().<span class="hljs-built_in">text</span>();<br><span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-comment">// 设置显示字段标题</span><br>tabModel-&gt;<span class="hljs-built_in">setHeaderData</span>(tabModel-&gt;<span class="hljs-built_in">fieldIndex</span>(<span class="hljs-string">&quot;id&quot;</span>), Qt::Horizontal, <span class="hljs-string">&quot;身份证号&quot;</span>);<br>tabModel-&gt;<span class="hljs-built_in">setHeaderData</span>(tabModel-&gt;<span class="hljs-built_in">fieldIndex</span>(<span class="hljs-string">&quot;account&quot;</span>),Qt::Horizontal,<span class="hljs-string">&quot;手机号&quot;</span>);<br>tabModel-&gt;<span class="hljs-built_in">setHeaderData</span>(tabModel-&gt;<span class="hljs-built_in">fieldIndex</span>(<span class="hljs-string">&quot;pwd&quot;</span>),Qt::Horizontal, <span class="hljs-string">&quot;密码&quot;</span>);<br>tabModel-&gt;<span class="hljs-built_in">setHeaderData</span>(tabModel-&gt;<span class="hljs-built_in">fieldIndex</span>(<span class="hljs-string">&quot;username&quot;</span>),Qt::Horizontal,<span class="hljs-string">&quot;姓名&quot;</span>);<br>tabModel-&gt;<span class="hljs-built_in">setHeaderData</span>(tabModel-&gt;<span class="hljs-built_in">fieldIndex</span>(<span class="hljs-string">&quot;permission&quot;</span>),Qt::Horizontal, <span class="hljs-string">&quot;权限&quot;</span>);<br>tabModel-&gt;<span class="hljs-built_in">setHeaderData</span>(tabModel-&gt;<span class="hljs-built_in">fieldIndex</span>(<span class="hljs-string">&quot;ava&quot;</span>),Qt::Horizontal,<span class="hljs-string">&quot;头像&quot;</span>);<br>tabModel-&gt;<span class="hljs-built_in">setHeaderData</span>(tabModel-&gt;<span class="hljs-built_in">fieldIndex</span>(<span class="hljs-string">&quot;gender&quot;</span>),Qt::Horizontal, <span class="hljs-string">&quot;性别&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="选择模型"><a href="#选择模型" class="headerlink" title="选择模型"></a>选择模型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 创建选择模型</span><br>selModel = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QItemSelectionModel</span>(tabModel, <span class="hljs-keyword">this</span>);<br><span class="hljs-comment">// 在此处绑定选择模型变化的信号和槽</span><br></code></pre></td></tr></table></figure><h4 id="模型-视图结构"><a href="#模型-视图结构" class="headerlink" title="模型&#x2F;视图结构"></a>模型&#x2F;视图结构</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 构建模型视图结构 视图为：QTableView</span><br>ui-&gt;tableViewUser-&gt;<span class="hljs-built_in">setModel</span>(tabModel);          <span class="hljs-comment">// 设置数据模型</span><br> <span class="hljs-comment">// 设置选择模型</span><br>ui-&gt;tableViewUser-&gt;<span class="hljs-built_in">setSelectionModel</span>(selModel);<br><span class="hljs-comment">// 隐藏列</span><br>ui-&gt;tableViewUser-&gt;<span class="hljs-built_in">setColumnHidden</span>(tabModel-&gt;<span class="hljs-built_in">fieldIndex</span>(<span class="hljs-string">&quot;ava&quot;</span>),<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><h4 id="数据到界面组件映射"><a href="#数据到界面组件映射" class="headerlink" title="数据到界面组件映射"></a>数据到界面组件映射</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 创建数据映射 </span><br>QDataWidgetMapper   *dataMapper;  <br>dataMapper= <span class="hljs-keyword">new</span> <span class="hljs-built_in">QDataWidgetMapper</span>(<span class="hljs-keyword">this</span>);<br>dataMapper-&gt;<span class="hljs-built_in">setSubmitPolicy</span>(QDataWidgetMapper::AutoSubmit);<br>dataMapper-&gt;<span class="hljs-built_in">setModel</span>(qryModel);<br><br><span class="hljs-comment">// 界面组件与数据模型的具体字段之间的映射</span><br>dataMapper-&gt;<span class="hljs-built_in">addMapping</span>(ui-&gt;dbSpinEmpNo, rec.<span class="hljs-built_in">indexOf</span>(<span class="hljs-string">&quot;empNo&quot;</span>));<br>dataMapper-&gt;<span class="hljs-built_in">addMapping</span>(ui-&gt;dbEditName,  rec.<span class="hljs-built_in">indexOf</span>(<span class="hljs-string">&quot;Name&quot;</span>));<br>dataMapper-&gt;<span class="hljs-built_in">addMapping</span>(ui-&gt;dbComboSex,  rec.<span class="hljs-built_in">indexOf</span>(<span class="hljs-string">&quot;Gender&quot;</span>));<br>dataMapper-&gt;<span class="hljs-built_in">addMapping</span>(ui-&gt;dbEditBirth, rec.<span class="hljs-built_in">indexOf</span>(<span class="hljs-string">&quot;Birthday&quot;</span>));<br><br>dataMapper-&gt;<span class="hljs-built_in">toFirst</span>();  <span class="hljs-comment">//移动到首记录</span><br></code></pre></td></tr></table></figure><h4 id="单个数据记录QSqlRecord"><a href="#单个数据记录QSqlRecord" class="headerlink" title="单个数据记录QSqlRecord"></a>单个数据记录QSqlRecord</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 获取只有字段信息的单个数据记录</span><br>QSqlRecord rec = tabModelRoom-&gt;<span class="hljs-built_in">record</span>();<br><span class="hljs-comment">// 将单个数据记录插入数据模型</span><br>tabModelRoom-&gt;<span class="hljs-built_in">insertRecord</span>(tabModelRoom-&gt;<span class="hljs-built_in">rowCount</span>(), rec);<br><span class="hljs-comment">// 提交所有未更新的修改到数据库</span><br>tabModelRoom-&gt;<span class="hljs-built_in">submitAll</span>();<br><span class="hljs-comment">// 获取第i个数据记录</span><br>QSqlRecord curRec = tabModelRoom-&gt;<span class="hljs-built_in">record</span>(i);<br></code></pre></td></tr></table></figure><h4 id="执行SQL语句"><a href="#执行SQL语句" class="headerlink" title="执行SQL语句"></a>执行SQL语句</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp">QSqlQuery resultPwd;<br><span class="hljs-comment">// 设置SQL语句，:account为参数占位符</span><br>resultPwd.<span class="hljs-built_in">prepare</span>(<span class="hljs-string">&quot;select pwd, permission from user where user.account = :account&quot;</span>);<br><span class="hljs-comment">// 绑定占位符参数</span><br>resultPwd.<span class="hljs-built_in">bindValue</span>(<span class="hljs-string">&quot;:account&quot;</span>,account);<br><span class="hljs-comment">// 执行SQL语句</span><br>resultPwd.<span class="hljs-built_in">exec</span>();<br><span class="hljs-comment">// 向下移动一个记录</span><br>resultPwd.<span class="hljs-built_in">next</span>();<br>LoginAttri res;<br><span class="hljs-comment">// 只会处理返回的第一条结果</span><br><span class="hljs-keyword">if</span>(resultPwd.<span class="hljs-built_in">value</span>(<span class="hljs-string">&quot;pwd&quot;</span>).<span class="hljs-built_in">toString</span>() != pwd)&#123;<br>    QMessageBox::<span class="hljs-built_in">information</span>(<span class="hljs-keyword">this</span>,<span class="hljs-string">&quot;info&quot;</span>,<span class="hljs-string">&quot;密码错误&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">// 处理每一条记录的方法</span><br><span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">next</span>()) &#123;<br>    QString username = q.<span class="hljs-built_in">value</span>(<span class="hljs-string">&quot;username&quot;</span>).<span class="hljs-built_in">toString</span>();<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;Username:&quot;</span> &lt;&lt; username;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="QPainter绘图"><a href="#QPainter绘图" class="headerlink" title="QPainter绘图"></a>QPainter绘图</h2><p>使用QPainter在绘图设备上绘图，绘图设备见类继承关系，注意：当绘图设备为QWidget时，QPainter只能在paintEvent()内部使用。</p><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240606155743409.png" alt="image-20240606155743409" style="zoom:150%;" /><h3 id="QPainter"><a href="#QPainter" class="headerlink" title="QPainter"></a>QPainter</h3><p>绘图主要是利用QPainter接口函数在绘图设备上绘制各种基本的图形</p><h3 id="QPen"><a href="#QPen" class="headerlink" title="QPen"></a>QPen</h3><p>设置绘图时的线条特性，主要包括线宽，颜色，线形状等。</p><h3 id="QBrush"><a href="#QBrush" class="headerlink" title="QBrush"></a>QBrush</h3><p>定义QPainter绘图时的一个区域的填充特性，包括填充颜色，填充样式，材质填充时的材质图片等。</p><h3 id="渐变填充效果"><a href="#渐变填充效果" class="headerlink" title="渐变填充效果"></a>渐变填充效果</h3><ul><li>QLinearGradient：线性渐变</li><li>QRadioGradient：辐射渐变</li><li>QConicalGradient：圆锥形渐变</li></ul><p>使用QPainter绘制图形举例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Widget::paintEvent</span><span class="hljs-params">(QPaintEvent *event)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">QPainter <span class="hljs-title">painter</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;<br>    <span class="hljs-comment">// 渲染抗锯齿</span><br>    painter.<span class="hljs-built_in">setRenderHints</span>(QPainter::Antialiasing | QPainter::TextAntialiasing);<br>    <span class="hljs-type">int</span> W = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">width</span>();<br>    <span class="hljs-type">int</span> H = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">height</span>();<br>    <span class="hljs-function">QRect <span class="hljs-title">rect</span><span class="hljs-params">(W/<span class="hljs-number">4</span>, H/<span class="hljs-number">4</span>, W/<span class="hljs-number">2</span>, H/<span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-comment">// 设置画笔</span><br>    QPen pen;<br>    pen.<span class="hljs-built_in">setWidth</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-comment">// 画笔颜色</span><br>    pen.<span class="hljs-built_in">setColor</span>(Qt::blue);<br>    <span class="hljs-comment">// 设置线条样式</span><br>    pen.<span class="hljs-built_in">setStyle</span>(Qt::SolidLine);<br>    <span class="hljs-comment">// 设置线条断点样式</span><br>    pen.<span class="hljs-built_in">setCapStyle</span>(Qt::FlatCap);<br>    <span class="hljs-comment">// 设置线条连接样式</span><br>    pen.<span class="hljs-built_in">setJoinStyle</span>(Qt::BevelJoin);<br>    painter.<span class="hljs-built_in">setPen</span>(pen);<br>    <span class="hljs-function">QPixmap <span class="hljs-title">texturePixmap</span><span class="hljs-params">(<span class="hljs-string">&quot;:/209ab910dba69ea54d89a31e10bf82d6_4983283784718022512.png&quot;</span>)</span></span>;<br>    <span class="hljs-comment">// 画刷（填充）</span><br>    QBrush brush;<br>    <span class="hljs-comment">// 设置画刷填充样式</span><br>    brush.<span class="hljs-built_in">setStyle</span>(Qt::TexturePattern);<br>    <span class="hljs-comment">// 设置QPixmap作为画刷图片</span><br>    brush.<span class="hljs-built_in">setTexture</span>(texturePixmap);<br>    <span class="hljs-comment">//   设置画刷颜色</span><br>    <span class="hljs-comment">//    brush.setColor(Qt::yellow);</span><br>    <span class="hljs-comment">//    brush.setStyle(Qt::SolidPattern);</span><br>    painter.<span class="hljs-built_in">setBrush</span>(brush);<br>    painter.<span class="hljs-built_in">drawRect</span>(rect);<br>    event-&gt;<span class="hljs-built_in">accept</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="QPainter绘制基本图形接口"><a href="#QPainter绘制基本图形接口" class="headerlink" title="QPainter绘制基本图形接口"></a>QPainter绘制基本图形接口</h3><p>通过函数接口绘制各种基本的图形，包括绘制图片，具体接口</p><p>可以用QPainterPath记录绘制图形的路径</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 使用QPaitner在QPixmap上绘图</span><br><span class="hljs-function">QPixmap <span class="hljs-title">splice</span><span class="hljs-params">(m_width * (m_imageCount + <span class="hljs-number">2</span>), m_height)</span></span>;<br><span class="hljs-function">QPainter <span class="hljs-title">painter</span><span class="hljs-params">(&amp;splice)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="坐标系统和坐标变化"><a href="#坐标系统和坐标变化" class="headerlink" title="坐标系统和坐标变化"></a>坐标系统和坐标变化</h3><p>1、平移</p><p>2、旋转</p><p>3、缩放</p><p>4、状态恢复和保存  </p><p><strong>视口</strong>和<strong>窗口</strong>定义：</p><p>视口是指绘图设备的任意一个矩形区域，使用物理坐标系。默认情况下，视口等于绘图设备的整个矩形区域。</p><p>窗口和视口是同一个矩形区域但是窗口是用逻辑坐标系定义的，窗口可以直接定义矩形区域的逻辑坐标范围。</p><p>物理坐标系叫做视口坐标系，逻辑坐标系也叫做窗口。通过内部坐标变化矩阵，QPainter能自动将逻辑坐标变化为绘图设备的物理坐标。</p><p><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240605121143415.png" alt="image-20240605121143415"></p><p>默认情况下视口等于绘图设备的整个矩形区域，它可以被设定为绘图设备的任意一个矩形区域，使用物理坐标系。</p><blockquote><p>QPainter::setViewPort(int x, int y, int width, int height);</p></blockquote><p>窗口可以任意定义矩形区域的逻辑坐标范围，在这个范围内显示个内容会映射到视口中。</p><blockquote><p>QPainter::serWindow(int x, int y, int width, int height);</p></blockquote><p>有关图片处理类</p><h3 id="QImage"><a href="#QImage" class="headerlink" title="QImage"></a>QImage</h3><p>类说明：与硬件无关的表示图片类，是为设备输入输出优化设计类，可以直接进行图片像素数据的访问和操作。</p><p>像素知识补充：</p><blockquote><p>像素<br>px（pixel），可以理解为一个最小图像单元（只能涂一个颜色）的小方块，就是1px，是一小块面积，但是一般并不强调面积的大小，只是说这是一个最小单元。</p><p>1px是一个小方块，但是这个小方块的边长却不是固定的，不同的图片、显示设备都可能是不同的，甚至这个小方块可以是长方形，就是说表示为1px的小方块的宽和高，真实对应的长度可能是不同的。我们可以把一个像素理解为一个点，因为我们经常会忽略像素的大小，平时关注更多的是像素数，也就是分辨率。想象有一个投影，或远或近的打到墙面上，大小会有变化，其实像素数没变。再想象显示器有不同尺寸的，分辨率（像素数）却是相同的。这些都可以理解为是像素大小不同导致的。</p></blockquote><blockquote><p>分辨率<br>像素是一个小方块，用这些小方块排成一个大的长方形，这个长方形就是图像，图像的分辨率为：图像宽排列的像素数 × 图像高排列的像素数。如果把像素想象成点，那么分辨率就是 宽像素数 × 高像素数。</p><p>4K分辨率：是指水平方向每行像素值达到或者接近4096个（4096×2160）</p></blockquote><blockquote><p>DPI（Dots Per Inch，每英寸点数），图像每英寸（1 英寸 &#x3D; 25.4 毫米）长度内的像素点数。</p><p>我们还是应该把像素理解为小方块，dpi就可以理解为是一英寸长度内排列的像素数。通过图像的dpi我们就可以计算出在这个图像中像素的边长，如果也知道图像的分辨率（宽高像素数），就可以知道该图像的真实尺寸了。</p></blockquote><blockquote><p>DPM（Dots Per Meter, 每米点数）, 1 DPI &#x3D; 0.0254 DPM</p></blockquote><blockquote><p>点距（dot pitch），就是把像素理解为点的时候，点距就是两个像素点的距离。我们把像素理解为小方块，那点距其实就是像素的边长</p><p>点距与DPI之间转换，点距一般用毫米表示，DPI表示1英寸（也就是25.4mm）长度内的像素数，所以点距（像素的边长）就等于 25.4 &#x2F; DPI（总长度&#x2F;个数&#x3D;每个长度）</p></blockquote><p>显示器规格：</p><table><thead><tr><th>属性</th><th>值</th></tr></thead><tbody><tr><td>分辨率</td><td>1366 * 768</td></tr><tr><td>尺寸</td><td>13寸（英寸，对角线长度）</td></tr><tr><td>计算过程</td><td></td></tr></tbody></table><blockquote><p>我们理解像素是个小正方形，所以显示器的宽高比例也是1366 : 768，</p><p>很容易求出，宽：11.33英寸，高：6.37英寸，</p><p>DPI ：1366 &#x2F; 11.33（或 768 &#x2F; 6.37）&#x3D; 120.55，</p><p>点距：25.4 &#x2F; 120.55 &#x3D; 0.2107 mm</p></blockquote><h3 id="QPixmap"><a href="#QPixmap" class="headerlink" title="QPixmap"></a>QPixmap</h3><p>类说明：为了在屏幕上显示图片而优化设计的类。</p><p>缩放到指定高度</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">scaledToHeight</span>(int);<br></code></pre></td></tr></table></figure><p>缩放到指定宽度 </p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">scaledToWidth</span>(int);<br></code></pre></td></tr></table></figure><p>缩放到指定宽度和高度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">scaled</span>(<span class="hljs-type">const</span> QSize &amp;size, Qt::AspectRatioMode aspectRatioMode = Qt::IgnoreAspectRatio, Qt::TransformationMode transformMode = Qt::FastTransformation) <br></code></pre></td></tr></table></figure><p><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240603115014949.png" alt="image-20240603115014949"></p><p><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240603115040219.png" alt="image-20240603115040219"></p><blockquote><h4 id="QImage与QPixmap的区别"><a href="#QImage与QPixmap的区别" class="headerlink" title="QImage与QPixmap的区别"></a>QImage与QPixmap的区别</h4><p>1、QPixmap主要是用于绘图，针对屏幕显示而最佳化设计，QImage主要是为图像I&#x2F;O、图片访问和像素修改而设计的</p><p>2、QPixmap依赖于所在的平台的绘图引擎，故例如反锯齿等一些效果在不同的平台上可能会有不同的显示效果，QImage使用Qt自身的绘图引擎，可在不同平台上具有相同的显示效果</p><p>3、目前的Qt会把QPixmap都存储在graphics memory中，QImage是存储在客户端的，是独立于硬件的。在 X11, Mac 以及 Symbian平台上，QPixmap 是存储在服务器端，而QImage则是存储在客户端，在Windows平台上，QPixmap和QImage都是存储在客户端，并不使用任何的GDI资源。</p><p>4、由于QImage是独立于硬件的，也是一种QPaintDevice，因此我们可以在另一个线程中对其进行绘制，而不需要在GUI线程中处理，使用这一方式可以很大幅度提高UI响应速度。</p><p>5、QImage可通过setPixpel()和pixel()等方法直接存取指定的像素。当图片较大时，我们可以先通过QImage将图片加载进来，然后把图片缩放成需要的尺寸，最后转换成QPixmap 进行显示。</p></blockquote><h3 id="QBitmap"><a href="#QBitmap" class="headerlink" title="QBitmap"></a>QBitmap</h3><p>是QPixmap的子类，用于表示一位色深的单色位图</p><h3 id="QPicture"><a href="#QPicture" class="headerlink" title="QPicture"></a>QPicture</h3><p>可以记录和重现QPainter的各条命令</p><h3 id="图形-视图架构"><a href="#图形-视图架构" class="headerlink" title="图形&#x2F;视图架构"></a>图形&#x2F;视图架构</h3><p>采用QPainter需要在绘图设备事件处理函数paintEvent()编写代码来实现绘图，绘制的是位图。<strong>对于绘制复杂可交互</strong>的图形使用图形&#x2F;视图架构，每个图像都是可选择的，可拖放，可修改的。</p><p>由三部分组成 1、<strong>场景</strong>  2、<strong>视图</strong> 3、<strong>图形项</strong></p><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240605164323154.png" alt="image-20240605164323154" style="zoom:80%;" /><h4 id="1、QGraphicsScene场景"><a href="#1、QGraphicsScene场景" class="headerlink" title="1、QGraphicsScene场景"></a>1、QGraphicsScene场景</h4><p>场景是一个抽象的管理图形的容器，可以向场景中添加图形项，可以获取场景中的图形项。</p><p>主要功能：</p><ul><li><p>提供管理大量图形项的快速接口</p></li><li><p>将事件传播给每个图形项</p></li><li><p>管理每个图形项的状态，如：选择状态，焦点状态</p></li><li><p>管理未经变换的渲染功能，主要用于打印</p></li></ul><p>场景中同时除了图形项还存在 <strong>背景层</strong>和 <strong>前景层</strong></p><blockquote><p>setBackgroundBrush() 设置背景层画刷</p><p>setForegroundBrush() 设置前景层画刷</p></blockquote><h4 id="2、QGraphicsView视图"><a href="#2、QGraphicsView视图" class="headerlink" title="2、QGraphicsView视图"></a>2、QGraphicsView视图</h4><p>间接父类为QWidget是一个界面组件，用于显示场景中的内容。可以为一个场景设置多个视图，用于对用一个场景提供不同的显示界面。默认情况下，视图大于场景时，场景在视图的中央显示，也可通过设置视图的Alignment属性控制场景在视图中显示的位置。</p><p>视图通过接受键盘和鼠标输入并转换为场景的事件，进行坐标变换后这些事件被传送给可视场景。</p><h4 id="3、QGraphicsItem图形项"><a href="#3、QGraphicsItem图形项" class="headerlink" title="3、QGraphicsItem图形项"></a>3、QGraphicsItem图形项</h4><p>所有的图像项都是从QGraphicsItem继承而来的，其没有父类。图形项相当于模型中的数据，<strong>一个图形项存储了绘制这个图形项的各种参数</strong>，<strong>场景管理所有图形项</strong>，<strong>视图组件负责绘制这些图形项</strong>。</p><p>支持的操作：</p><ul><li><p>鼠标响应事件</p></li><li><p>键盘输入，以及按键事件</p></li><li><p>拖放操作</p></li><li><p>组合，可以是父子图形项关系组合，也可以通过QGraphicsItemGroup类进行组合</p></li></ul><p>一个图形项还可以包含子图形项，图形项之间还支持碰撞检测。</p><h4 id="图形-视图架构坐标系"><a href="#图形-视图架构坐标系" class="headerlink" title="图形&#x2F;视图架构坐标系"></a>图形&#x2F;视图架构坐标系</h4><p>图形&#x2F;视图架构有三个有效的坐标系：<strong>场景坐标系</strong>，<strong>视图坐标系</strong>，<strong>图形项坐标系</strong></p><img src="D:\Documents\Tencent Files\2920611818\FileRecv\MobileFile\1717578701216.jpg" alt="1717578701216" style="zoom: 50%;" /><h4 id="1、场景坐标系"><a href="#1、场景坐标系" class="headerlink" title="1、场景坐标系"></a>1、场景坐标系</h4><p>场景坐标系定义了所有图形项的基础坐标, 场景坐标系描述了每个顶层图形项的位置．</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 定义一个左上角坐标为(-400, -300),宽度为800, 长度为600的场景</span><br>scene = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QGraphicsScene</span>(<span class="hljs-number">-400</span>, <span class="hljs-number">-300</span>, <span class="hljs-number">800</span>, <span class="hljs-number">600</span>);<br></code></pre></td></tr></table></figure><h4 id="2、视图坐标系"><a href="#2、视图坐标系" class="headerlink" title="2、视图坐标系"></a>2、视图坐标系</h4><p>视图坐标系就是视图组件的物理坐标系, 单位为像素, 视图坐标系只与视图组件和视口有关,与场景无关. QGraphicsview视口的左上角坐标总是(0, 0), 所有的鼠标事件,拖放事件的坐标首先是由视图坐标系定义, 然后用户将视图坐标映射为场景坐标, 和图形交互.</p><h4 id="3、图形坐标系"><a href="#3、图形坐标系" class="headerlink" title="3、图形坐标系"></a>3、图形坐标系</h4><p>图形项使用自己的局部坐标系, 以自己的中心为原点(0,0).</p><p>图形项的位置就是指其中心在父对象项坐标系中的坐标, 没有父图形项的图形项, 父对象就是场景. </p><blockquote><p>QGraphicsItem::pos()  返回图形项在父对象中的坐标</p></blockquote><h4 id="4、坐标映射"><a href="#4、坐标映射" class="headerlink" title="4、坐标映射"></a>4、坐标映射</h4><blockquote><p>QGraphicsView::mapToScene() 将视图坐标映射为场景坐标</p></blockquote><blockquote><p>QGraphicsScene::itemAt() 获取场景中鼠标光标处的图形项</p></blockquote><p>创建图形&#x2F;视图举例</p><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240605175741852.png" alt="image-20240605175741852"  /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 创建场景</span><br><span class="hljs-function">QRectF <span class="hljs-title">rect</span><span class="hljs-params">(<span class="hljs-number">-200</span>, <span class="hljs-number">-100</span>, <span class="hljs-number">400</span>, <span class="hljs-number">200</span>)</span></span>;<br>scene = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QGraphicsScene</span>(rect, <span class="hljs-keyword">this</span>);<br>ui-&gt;graphicsView-&gt;<span class="hljs-built_in">setScene</span>(scene);<br><span class="hljs-comment">// 新建图形项</span><br>QGraphicsRectItem *item = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QGraphicsRectItem</span>(rect);<br>item-&gt;<span class="hljs-built_in">setFlags</span>(QGraphicsItem::ItemIsSelectable | QGraphicsItem::ItemIsFocusable);<br>QPen pen;<br>pen.<span class="hljs-built_in">setWidth</span>(<span class="hljs-number">2</span>);<br>item-&gt;<span class="hljs-built_in">setPen</span>(pen);<br><span class="hljs-comment">// 在场景中添加图形项</span><br>scene-&gt;<span class="hljs-built_in">addItem</span>(item);<br>QGraphicsEllipseItem *item2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QGraphicsEllipseItem</span>(<span class="hljs-number">-100</span>, <span class="hljs-number">-50</span>, <span class="hljs-number">200</span>, <span class="hljs-number">100</span>);<br><span class="hljs-comment">// 设置图形项在父对象中的位置</span><br>item2-&gt;<span class="hljs-built_in">setPos</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>item2-&gt;<span class="hljs-built_in">setBrush</span>(<span class="hljs-built_in">QBrush</span>(Qt::blue));<br><span class="hljs-comment">// 设置图形项操作标志</span><br>item2-&gt;<span class="hljs-built_in">setFlag</span>(QGraphicsItem::ItemIsMovable);<br>item2-&gt;<span class="hljs-built_in">setFlag</span>(QGraphicsItem::ItemIsSelectable);<br>item2-&gt;<span class="hljs-built_in">setFlag</span>(QGraphicsItem::ItemIsFocusable);<br>scene-&gt;<span class="hljs-built_in">addItem</span>(item2);<br>QGraphicsEllipseItem *item3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QGraphicsEllipseItem</span>(<span class="hljs-number">-50</span>, <span class="hljs-number">-50</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);<br>item3-&gt;<span class="hljs-built_in">setPos</span>(rect.<span class="hljs-built_in">right</span>(),rect.<span class="hljs-built_in">bottom</span>());<br>item3-&gt;<span class="hljs-built_in">setBrush</span>(<span class="hljs-built_in">QBrush</span>(Qt::red));<br>item3-&gt;<span class="hljs-built_in">setFlags</span>(QGraphicsItem::ItemIsMovable | QGraphicsItem::ItemIsSelectable<br>|QGraphicsItem::ItemIsFocusable);<br>scene-&gt;<span class="hljs-built_in">addItem</span>(item3);<br><span class="hljs-comment">// 清除所有选择</span><br>scene-&gt;<span class="hljs-built_in">clearSelection</span>();<br></code></pre></td></tr></table></figure><h2 id="QChart绘图"><a href="#QChart绘图" class="headerlink" title="QChart绘图"></a>QChart绘图</h2><h2 id="QAnimation"><a href="#QAnimation" class="headerlink" title="QAnimation"></a>QAnimation</h2><h2 id="Qt常见功能类"><a href="#Qt常见功能类" class="headerlink" title="Qt常见功能类"></a>Qt常见功能类</h2><h3 id="QPagedPaintDevice"><a href="#QPagedPaintDevice" class="headerlink" title="QPagedPaintDevice"></a>QPagedPaintDevice</h3><h4 id="QPainter-1"><a href="#QPainter-1" class="headerlink" title="QPainter"></a>QPainter</h4><p>用于打印输出的类</p><h4 id="QPdfWriter"><a href="#QPdfWriter" class="headerlink" title="QPdfWriter"></a>QPdfWriter</h4><p>用于生成pdf文件的绘图设备类</p><h3 id="QGraphicsDropShadowEffect"><a href="#QGraphicsDropShadowEffect" class="headerlink" title="QGraphicsDropShadowEffect"></a>QGraphicsDropShadowEffect</h3><p>创建阴影效果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">QGraphicsDropShadowEffect *shadow_effect = <span class="hljs-keyword">new</span> <span class="hljs-built_in">QGraphicsDropShadowEffect</span>(<span class="hljs-keyword">this</span>);<br><span class="hljs-comment">// 设置阴影偏移量，x 轴方向和 y 轴方向</span><br>shadow_effect-&gt;<span class="hljs-built_in">setOffset</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-comment">// 阴影颜色，QColor 属性。默认情况为半透明的深灰色(QColor(63, 63, 63,180))</span><br>shadow_effect-&gt;<span class="hljs-built_in">setColor</span>(Qt::red);<br><span class="hljs-comment">// 阴影半径。使用较小的半径产生更清晰的阴影，而使用较大的半径产生更模糊的阴影</span><br>shadow_effect-&gt;<span class="hljs-built_in">setBlurRadius</span>(<span class="hljs-number">20</span>);<br><br><span class="hljs-comment">// 设置阴影</span><br>m_pLoginPhoneLabel-&gt;<span class="hljs-built_in">setGraphicsEffect</span>(shadow_effect);<br></code></pre></td></tr></table></figure><h2 id="常见问题："><a href="#常见问题：" class="headerlink" title="常见问题："></a>常见问题：</h2><p>字符串编码错误：</p><p>使用Qt的时候，时常会遇到中文乱码问题，qDebug打印日志乱码，或者Widget界面乱码等等。</p><p>原因呢，大多是因为使用MSVC编译器问题导致，而Qt 自带的MinGW一般不会出现乱码问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 定义宏强制编译后的执行文件采用UTF-8编码</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> _MSC_VER &gt;= 1600 <span class="hljs-comment">//VS2015&gt;VS&gt;VS2010, MSVC VER= 10.0 -14.0</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> execution_character_set(<span class="hljs-string">&quot;utf-8&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h2 id="QSS"><a href="#QSS" class="headerlink" title="QSS"></a>QSS</h2><p>QSS官方说明：<a href="https://doc.qt.io/qt-6/stylesheet-customizing.html">Customizing Qt Widgets Using Style Sheets | Qt Widgets 6.7.1</a></p><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><p>使用样式表时，每个widget都被视为包含<code>四个同心矩形的框</code>：<strong>边距矩形（margin rectangle）、边框矩形（border rectangle）、填充矩形（padding rectangle）和内容矩形（content rectangle）</strong>。</p><p><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240604235720014.png" alt="image-20240604235720014"></p><h3 id="常见样式举例："><a href="#常见样式举例：" class="headerlink" title="常见样式举例："></a>常见样式举例：</h3><h4 id="QPushButton-1"><a href="#QPushButton-1" class="headerlink" title="QPushButton"></a>QPushButton</h4><p><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240531110111671.png" alt="image-20240531110111671"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css">QPushButton &#123;<br><span class="hljs-attribute">border</span>:none;<br><span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;<br><span class="hljs-attribute">color</span>:<span class="hljs-built_in">rgb</span>(<span class="hljs-number">244</span>, <span class="hljs-number">216</span>, <span class="hljs-number">168</span>);<br><span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">57</span>, <span class="hljs-number">59</span>, <span class="hljs-number">64</span>);<br>&#125;<br>QPushButton::hover &#123;<br><span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">57</span>, <span class="hljs-number">59</span>, <span class="hljs-number">64</span>, <span class="hljs-number">200</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="QComboBox"><a href="#QComboBox" class="headerlink" title="QComboBox"></a>QComboBox</h4><p><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240605105400027.png" alt="image-20240605105400027"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs CSS">QComboBox &#123;<br><span class="hljs-attribute">border</span>:none;<br>    <span class="hljs-attribute">font</span>: normal normal <span class="hljs-number">16px</span> <span class="hljs-string">&quot;Microsoft YaHei&quot;</span>;<br><span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">243</span>, <span class="hljs-number">243</span>, <span class="hljs-number">243</span>);<br>&#125;<br><br>QComboBox::drop-down&#123;<br>    subcontrol-origin: padding;<br>    subcontrol-<span class="hljs-attribute">position</span>: top right;<br>    <span class="hljs-attribute">border-left-width</span>: <span class="hljs-number">1px</span>;<br>    <span class="hljs-attribute">border-left-color</span>: darkgray;<br><span class="hljs-attribute">width</span>: <span class="hljs-number">20px</span>;<br>&#125;<br><br>QComboBox::down-arrow&#123;<br><span class="hljs-selector-tag">image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">:/res/down.png</span>);<br><span class="hljs-attribute">width</span>: <span class="hljs-number">20px</span>;<br><span class="hljs-attribute">height</span>: <span class="hljs-number">20px</span><br><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="QCheckButton"><a href="#QCheckButton" class="headerlink" title="QCheckButton"></a>QCheckButton</h4><p><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240531120044731.png" alt="image-20240531120044731"><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240531120102467.png" alt="image-20240531120102467"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css">QCheckBox::indicator&#123;<br><span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;<br><span class="hljs-attribute">border</span>:none;<br><span class="hljs-attribute">width</span>:<span class="hljs-number">30px</span>;<br><span class="hljs-attribute">height</span>:<span class="hljs-number">30px</span>;<br>&#125;<br>QCheckBox::indicator:unchecked&#123;<br><span class="hljs-selector-tag">image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">:/new/bg/res/unchecked.png</span>);<br><span class="hljs-attribute">border</span>: <span class="hljs-number">0px</span>;<br>&#125;<br>QCheckBox::indicator:checked&#123;<br><span class="hljs-selector-tag">image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">:/new/bg/res/checked.png</span>);<br><span class="hljs-attribute">border</span>: <span class="hljs-number">0px</span>;<br><span class="hljs-attribute">background-color</span>:<span class="hljs-built_in">rgb</span>(<span class="hljs-number">57</span>, <span class="hljs-number">59</span>, <span class="hljs-number">64</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="QRadioButton"><a href="#QRadioButton" class="headerlink" title="QRadioButton"></a>QRadioButton</h4><p><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240531120346639.png" alt="image-20240531120346639"><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240531120358497.png" alt="image-20240531120358497"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css">`QRadioButton::indicator&#123;<br><span class="hljs-attribute">border</span>:none;<br><span class="hljs-attribute">width</span>:<span class="hljs-number">30px</span>;<br><span class="hljs-attribute">height</span>:<span class="hljs-number">30px</span>;<br>&#125;<br>QRadioButton::indicator:unchecked&#123;<br><span class="hljs-comment">/* 使用border-image会导致图片失真*/</span><br><span class="hljs-selector-tag">image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">:/new/bg/res/radio button unselect.png</span>);<br><span class="hljs-attribute">border</span>: <span class="hljs-number">0px</span>;<br>&#125;<br>QRadioButton::indicator:checked&#123;<br><span class="hljs-selector-tag">image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">:/new/bg/res/radio button select.png</span>);<br><span class="hljs-attribute">border</span>: <span class="hljs-number">0px</span>;<br>&#125;`<br></code></pre></td></tr></table></figure><h4 id="QToolButton-1"><a href="#QToolButton-1" class="headerlink" title="QToolButton"></a>QToolButton</h4><p><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240531120653964.png" alt="image-20240531120653964"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs css">QToolButton<br>&#123;<br>    <span class="hljs-attribute">color</span>:<span class="hljs-built_in">rgb</span>(<span class="hljs-number">112</span>, <span class="hljs-number">74</span>, <span class="hljs-number">29</span>);<br>    <span class="hljs-attribute">background-color</span>:<span class="hljs-built_in">rgb</span>(<span class="hljs-number">255</span>, <span class="hljs-number">202</span>, <span class="hljs-number">11</span>);<br><span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span>;<br><span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;<br>&#125;<br>QToolButton::menu-arrow&#123;<br><span class="hljs-selector-tag">image</span>:none;<br>&#125;<br><br>QToolButton::menu-button&#123;<br><span class="hljs-attribute">width</span>: <span class="hljs-number">35px</span>;<br><span class="hljs-selector-tag">image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">:/res/mession.png</span>);<br>&#125;<br><br>QToolButton::hover &#123;<br>    <span class="hljs-attribute">background-color</span>:<span class="hljs-built_in">rgb</span>(<span class="hljs-number">255</span>, <span class="hljs-number">206</span>, <span class="hljs-number">45</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="QScrollArea"><a href="#QScrollArea" class="headerlink" title="QScrollArea"></a>QScrollArea</h4><p><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240531104613496.png" alt="image-20240531104613496"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs css">QScrollArea&#123;<br><span class="hljs-attribute">border</span>: <span class="hljs-number">0px</span> solid;<br><span class="hljs-attribute">border-right-width</span>: <span class="hljs-number">1px</span>;<br><span class="hljs-attribute">border-right-color</span>: <span class="hljs-number">#dcdbdc</span>;<br><span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f5f5f7</span>;<br>&#125;<br>QScrollBar:vertical &#123;<br><span class="hljs-attribute">border</span>: none;<br><span class="hljs-attribute">background</span>: <span class="hljs-number">#ffffff</span>;<br><span class="hljs-attribute">width</span>: <span class="hljs-number">10px</span>;<br><span class="hljs-attribute">margin</span>: <span class="hljs-number">0px</span> <span class="hljs-number">0</span> <span class="hljs-number">0px</span> <span class="hljs-number">0</span>;<br>&#125;<br>QScrollBar::handle:vertical &#123;<br><span class="hljs-attribute">background</span>: Gainsboro;<br><span class="hljs-attribute">min-height</span>: <span class="hljs-number">20px</span>;<br><span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;<br><span class="hljs-attribute">border</span>: none;<br>&#125;<br>QScrollBar::add-line:vertical &#123;<br><span class="hljs-attribute">border</span>: <span class="hljs-number">0px</span> solid grey;<br><span class="hljs-attribute">background</span>: <span class="hljs-number">#32CC99</span>;<br><span class="hljs-attribute">height</span>: <span class="hljs-number">0px</span>;<br>subcontrol-<span class="hljs-attribute">position</span>: bottom;<br>subcontrol-origin: margin;<br>&#125;<br>QScrollBar::sub-line:vertical &#123;<br><span class="hljs-attribute">border</span>: <span class="hljs-number">0px</span> solid grey;<br><span class="hljs-attribute">background</span>: <span class="hljs-number">#32CC99</span>;<br><span class="hljs-attribute">height</span>: <span class="hljs-number">0px</span>;<br>subcontrol-<span class="hljs-attribute">position</span>: top;<br>subcontrol-origin: margin;<br>&#125;<br>QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical &#123;<br><span class="hljs-attribute">background</span>: none;<br><span class="hljs-attribute">width</span>: <span class="hljs-number">0px</span>;<br><span class="hljs-attribute">height</span>: <span class="hljs-number">0px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="QLineEdit-1"><a href="#QLineEdit-1" class="headerlink" title="QLineEdit"></a>QLineEdit</h4><p><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240605105528128.png" alt="image-20240605105528128"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs css">QLineEdit &#123;<br><span class="hljs-comment">/*border: 1px solid #A0A0A0; /* 边框宽度为1px，颜色为#A0A0A0 */</span><br><span class="hljs-attribute">border-radius</span>: <span class="hljs-number">3px</span>; <span class="hljs-comment">/* 边框圆角 */</span><br><span class="hljs-attribute">padding-left</span>: <span class="hljs-number">5px</span>; <span class="hljs-comment">/* 文本距离左边界有5px */</span><br><span class="hljs-attribute">background-color</span>:<span class="hljs-built_in">rgb</span>(<span class="hljs-number">243</span>, <span class="hljs-number">243</span>, <span class="hljs-number">243</span>);<br><span class="hljs-attribute">color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">/* 文本颜色 */</span><br>selection-<span class="hljs-attribute">background-color</span>: <span class="hljs-number">#A0A0A0</span>; <span class="hljs-comment">/* 选中文本的背景颜色 */</span><br>selection-<span class="hljs-attribute">color</span>: <span class="hljs-number">#F2F2F2</span>; <span class="hljs-comment">/* 选中文本的颜色 */</span><br><span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;Microsoft YaHei&quot;</span>; <span class="hljs-comment">/* 文本字体族 */</span><br><span class="hljs-attribute">font-size</span>: <span class="hljs-number">20px</span>; <span class="hljs-comment">/* 文本字体大小 */</span><br>&#125;<br><br>QLineEdit<span class="hljs-selector-pseudo">:hover</span> &#123; <span class="hljs-comment">/* 鼠标悬浮在QLineEdit时的状态 */</span><br><span class="hljs-attribute">border-radius</span>: <span class="hljs-number">3px</span>;<br>selection-<span class="hljs-attribute">color</span>: <span class="hljs-number">#F2F2F2</span>;<br>&#125;<br><br>QLineEdit<span class="hljs-selector-attr">[echoMode=<span class="hljs-string">&quot;2&quot;</span>]</span> &#123; <span class="hljs-comment">/* QLineEdit有输入掩码时的状态 */</span><br>lineedit-password-character: <span class="hljs-number">9679</span>;<br>lineedit-password-<span class="hljs-attribute">mask</span>-delay: <span class="hljs-number">2000</span>;<br>&#125;<br><br>QLineEdit<span class="hljs-selector-pseudo">:disabled</span> &#123; <span class="hljs-comment">/* QLineEdit在禁用时的状态 */</span><br><span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#CDCDCD</span>;<br><span class="hljs-attribute">background-color</span>: <span class="hljs-number">#CDCDCD</span>;<br><span class="hljs-attribute">color</span>: <span class="hljs-number">#B4B4B4</span>;<br>&#125;<br><br>QLineEdit<span class="hljs-selector-pseudo">:read-only</span> &#123; <span class="hljs-comment">/* QLineEdit在只读时的状态 */</span><br><span class="hljs-attribute">background-color</span>: <span class="hljs-number">#CDCDCD</span>;<br><span class="hljs-attribute">color</span>: <span class="hljs-number">#F2F2F2</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="QListWidget"><a href="#QListWidget" class="headerlink" title="QListWidget"></a>QListWidget</h4><h4 id="QTabWidget"><a href="#QTabWidget" class="headerlink" title="QTabWidget"></a>QTabWidget</h4><p><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240531120904547.png" alt="image-20240531120904547"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs css">QTabWidget::pane <br>&#123; <br><span class="hljs-attribute">border</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br>QTabBar::tab<br>&#123; <br><span class="hljs-attribute">background</span>: transparent;<br><span class="hljs-attribute">font-family</span>:<span class="hljs-string">&quot;微软雅黑&quot;</span>;<br><span class="hljs-attribute">color</span>:<span class="hljs-built_in">rgb</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>);<br><span class="hljs-attribute">font-size</span>:<span class="hljs-number">16px</span>;<br><span class="hljs-attribute">font</span>: bold;<br><span class="hljs-attribute">padding-left</span>:<span class="hljs-number">5px</span>;<br><span class="hljs-attribute">padding-right</span>:<span class="hljs-number">5px</span>;<br><span class="hljs-attribute">min-width</span>: <span class="hljs-number">85px</span>;<br><span class="hljs-attribute">min-height</span>:<span class="hljs-number">30px</span>;<br>&#125;<br> <br>QTabBar::tab:selected<br>&#123;<br><span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">3px</span> solid <span class="hljs-built_in">rgb</span>(<span class="hljs-number">255</span>, <span class="hljs-number">210</span>, <span class="hljs-number">132</span>);<br>&#125;<br>QTabBar::tab:hover<br>&#123;<br><span class="hljs-attribute">color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">255</span>, <span class="hljs-number">210</span>, <span class="hljs-number">132</span>);<br>&#125;<br>QStackedWidget &#123; <br><span class="hljs-attribute">background</span>: transparent;<br>&#125;<br>QStackedWidget &gt; QWidget &#123; <br><span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">20</span>,<span class="hljs-number">20</span>,<span class="hljs-number">20</span>,<span class="hljs-number">80</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构和算法</title>
    <link href="/2024/07/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <url>/2024/07/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><strong>《总之，好记性不如烂笔头！把你遗忘的都记下来吧！》</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2024/07/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2024/07/31/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><strong>《总之，好记性不如烂笔头！把你遗忘的都记下来吧！》</strong></p><h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p><img src="https://img-blog.csdnimg.cn/direct/72fd8f630e2848d6a1f7076dce14ffe5.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/direct/4a364a65517346519e02bc6c74eda064.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/direct/6e265fc8ede643388fef361cd9e7da60.png" alt="img"></p><ul><li><p>静态属性&#x2F;方法：加上下划线，如 -ClassAttribute: Long</p></li><li><p>抽象属性&#x2F;方法：使用斜体表示，如 +AbstractOperation()</p></li><li><p>职责：可以在操作部分的下面再添加一个区域，用来说明类的职责，即说明类或其它元素的契约或义务。</p></li><li><p>约束：指定了该类所要满足的一个或多个规则，用大括号表示，如 {Some Properties}</p></li></ul><p><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240629171715820.png" alt="image-20240629171715820"></p><h4 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h4><img src="https://img-blog.csdnimg.cn/img_convert/bc8821a3d19e006cf8ac3959314cb4fe.jpeg" alt="img" style="zoom: 50%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span>&#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Truck</span> : <span class="hljs-keyword">public</span> Vehicle&#123;&#125;;<br></code></pre></td></tr></table></figure><h4 id="实现关系"><a href="#实现关系" class="headerlink" title="实现关系"></a>实现关系</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/c0611ff2aff17caf814b944ac94c46d9.jpeg" alt="img" style="zoom:67%;" /><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240629233149588.png" alt="image-20240629233149588"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">IUser</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">walk</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">walk</span>()&#123;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">VipUser</span> : <span class="hljs-keyword">public</span> IUser&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">walk</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>&#123;<br>std::cout&lt;&lt;<span class="hljs-string">&quot;do walk&quot;</span>&lt;&lt;std::endl;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h4><img src="https://img-blog.csdnimg.cn/img_convert/50a2bd10c48ee3c0d962cfeca3238763.jpeg" alt="img" style="zoom:67%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Move</span><span class="hljs-params">()</span></span>&#123;&#125;;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Travel</span><span class="hljs-params">(Car &amp;car)</span></span>&#123; car.<span class="hljs-built_in">Move</span>(); &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h4><img src="https://img-blog.csdnimg.cn/img_convert/72857e2ed7fc29624cb188c14ec74da8.jpeg" alt="img" style="zoom:67%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Department</span>&#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span>&#123;<br>Department depart;<br>&#125;;<br></code></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/img_convert/cf426df7ec3c9a1e61fec96dd93cc203.jpeg" alt="img" style="zoom:50%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span>&#123;<br><span class="hljs-keyword">public</span>:<br>Student aLearner;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>Teacher alnstructor;<br>&#125;;<br></code></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/direct/f197e2df6d6340e682a5f5c26066b1f9.png" alt="img" style="zoom:67%;" /><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><h4 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h4><p><strong>聚合关联：</strong></p><img src="https://img-blog.csdnimg.cn/img_convert/6fae8ff1629c7169ebbc8adfbf6383f1.jpeg" alt="img" style="zoom: 67%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">University</span>&#123;<br><span class="hljs-keyword">public</span>:<br>std::list&lt;College&gt; colleges;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">College</span>&#123;<br>University university;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>单向聚合：</strong><img src="https://img-blog.csdnimg.cn/img_convert/926cd32aa26e5a9b1fdec675af122729.jpeg" alt="img" style="zoom:67%;" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">College</span>&#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">University</span>&#123;<br>std::list&lt;College&gt; colleges;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h4><img src="https://img-blog.csdnimg.cn/img_convert/3bb020be39fc153f70eb4725f66cbdda.jpeg" alt="img" style="zoom: 67%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Side</span>&#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Triangle</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addSide</span><span class="hljs-params">(<span class="hljs-type">const</span> Side&amp; side)</span></span>&#123;<br>        m_sides.<span class="hljs-built_in">push_back</span>(side);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>std::list&lt;Side&gt; m_sides;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>可复用面向对象软件基础</p><p>底层思维：将机器底层从微观理解对象构造</p><p>抽象思维：向上将世界逻辑抽象为代码</p><p>解决变化</p><p>结构化和面向对象</p><p>解决问题的复杂性：</p><p>1、<strong>分解</strong>，将复杂的行为抽象成每一部分，但是应对改变需要改变较多的代码</p><p>2、<strong>抽象</strong>，将行为抽象，使用一种通用的方法统一处理，应对变化，处理方法不变，复用性高</p><p>软件设计的目标是：复用。</p><h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><p><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240628225820577.png" alt="image-20240628225820577"></p><p><strong>重新认识面向对象</strong>：</p><p><strong>隔离变化：</strong>从宏观层面，面向对象构建能够将变化带来的影响减少到最小。</p><p><strong>各司其职</strong>：从微观层面，面向对象的方式更强调类的责任，新增加的类不应该影响原来的类型的实现。</p><p>对象是什么？</p><p>从语言层面，对象封装数据和方法；</p><p>从规格层面，对象是一系列可以被使用的公告接口；</p><p>从概念层面，对象是某种拥有责任的抽象。</p><h4 id="1、-依赖倒置原则："><a href="#1、-依赖倒置原则：" class="headerlink" title="1、*依赖倒置原则："></a>1、*依赖倒置原则：</h4><p>高层模块（稳定）不应该依赖于底层模块（变化），二者都应<strong>依赖于抽象</strong>。</p><p>抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）</p><p>在结构化的程序中，常常让上层模块调用下层模块，</p><p>在面向对象的程序设计中，我们应该让抽象程度更高的模块被抽象程度低的模块依赖。</p><p><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240628222829360.png" alt="image-20240628222829360"></p><h4 id="2、开放封闭原则："><a href="#2、开放封闭原则：" class="headerlink" title="2、开放封闭原则："></a>2、开放封闭原则：</h4><p>对拓展开放，对更改封闭，类模块应该是可拓展的，但是是不可以修改的。</p><h4 id="3、单一职责原则："><a href="#3、单一职责原则：" class="headerlink" title="3、单一职责原则："></a>3、单一职责原则：</h4><p>一个类应该仅有一个引起它变化的原因。变化的方向隐含着类的责任</p><p>防止类过于臃肿。</p><h4 id="4、里氏替换原则："><a href="#4、里氏替换原则：" class="headerlink" title="4、里氏替换原则："></a>4、里氏替换原则：</h4><p>子类应该能完全充当一个货真价实的父类对象。继承表达类型抽象。</p><p>可用改进代码段中存在的大量if else可以用循环替代，引入抽象类</p><h4 id="5、接口隔离原则："><a href="#5、接口隔离原则：" class="headerlink" title="5、接口隔离原则："></a>5、接口隔离原则：</h4><p>接口应该小而完备</p><p>不应该强迫客户程序依赖它们不用的方法。</p><h4 id="6、优先使用对象组合，而不是类继承："><a href="#6、优先使用对象组合，而不是类继承：" class="headerlink" title="6、优先使用对象组合，而不是类继承："></a>6、优先使用对象组合，而不是类继承：</h4><p>类继承通常为”白箱复用“，对象组合为”黑箱复用“</p><p>继承在某种程度上破坏了封装性，子类父类耦合性高</p><p>对象组合只要求被组合的对象的对象有良好的接口定义，耦合度低。</p><h4 id="7、封装变化点："><a href="#7、封装变化点：" class="headerlink" title="7、封装变化点："></a>7、封装变化点：</h4><p>使用封装来创建对象之间的分界层，让设计者在分界层一侧修改，不产生另一侧的影响。</p><h4 id="8、针对接口编程，而不是针对实现编程："><a href="#8、针对接口编程，而不是针对实现编程：" class="headerlink" title="8、针对接口编程，而不是针对实现编程："></a>8、针对接口编程，而不是针对实现编程：</h4><p>不将变量类型声明为某个特定的具体类，而是声明称具体的接口。</p><p>客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。</p><p>减少系统各部分的依赖关系，实现”高内聚，低耦合“</p><h4 id="迪米特法则："><a href="#迪米特法则：" class="headerlink" title="迪米特法则："></a>迪米特法则：</h4><p>一个类应该和尽可能少的类发生关联</p><p><strong>设计模式不易先入为主，开始就使用设计模式是对设计模式的最大误用。没有一步到位的设计模式，敏捷软件开发提倡”Refactoring to Patterns” 重构到设计模式</strong></p><h1 id="重构的关键技法"><a href="#重构的关键技法" class="headerlink" title="*重构的关键技法"></a>*重构的关键技法</h1><p><strong>静态-&gt;动态</strong></p><p><strong>早绑定-&gt;晚绑定</strong></p><p><strong>继承-&gt;组合</strong></p><p><strong>编译时依赖-&gt;运行时依赖</strong></p><p><strong>紧耦合-&gt;松耦合</strong></p><h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><p>通过对象创建模式绕开new，来避免对象创建new过程中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定。它是接口抽象后的第一步工作。</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240630112241303.png" alt="image-20240630112241303"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 工厂方法模式</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Product</span>()&#123;&#125;<br>    <span class="hljs-comment">// 定义纯虚函数，必须在子类中覆盖</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">Operation</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteProduct1</span> : <span class="hljs-keyword">public</span> Product&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::string <span class="hljs-title">Operation</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123; Result of the ConcreteProduct1 &#125;&quot;</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteProduct2</span> : <span class="hljs-keyword">public</span> Product&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::string <span class="hljs-title">Operation</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123; Result of the ConcreteProduct2 &#125;&quot;</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Creator</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Creator</span>()&#123;&#125;<br>    <span class="hljs-comment">// 创建者不提供具体的产品构建方法，只是提供了一个可以重写的纯虚函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Product *<span class="hljs-title">FactoryMethod</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 对不同的产品执行对应的操作</span><br>    <span class="hljs-function">std::string <span class="hljs-title">SomeOperation</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>        <span class="hljs-comment">// 构建对应的产品对象，使用多态，函数表指向对应的虚函数</span><br>        <span class="hljs-comment">// 利用了两次多态，第一次是构建产品对象，第二次是使用产品对象的方法</span><br>        Product *product = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">FactoryMethod</span>();<br>        std::string result =<br>            <span class="hljs-string">&quot;Creator: The same creator&#x27;s code has just worked with &quot;</span> +<br>            product-&gt;<span class="hljs-built_in">Operation</span>();<br>        <span class="hljs-keyword">delete</span> product;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteCreator1</span> : <span class="hljs-keyword">public</span> Creator&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// 创建产品1</span><br>  <span class="hljs-function">Product *<span class="hljs-title">FactoryMethod</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreteProduct1</span>(); &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteCreator2</span> : <span class="hljs-keyword">public</span> Creator&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// 创建产品2</span><br>  <span class="hljs-function">Product *<span class="hljs-title">FactoryMethod</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreteProduct2</span>(); &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClientCode</span><span class="hljs-params">(<span class="hljs-type">const</span> Creator&amp; creator)</span></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Client : IM not aware of the creator&#x27;s class, but it still &quot;</span><br>                 <span class="hljs-string">&quot;works.\n&quot;</span><br>              &lt;&lt; creator.<span class="hljs-built_in">SomeOperation</span>() &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;1&quot;</span> &lt;&lt; std::endl;<br>    Creator *creator = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreteCreator1</span>();<br>    <span class="hljs-built_in">ClientCode</span>(*creator);<br>    std::cout &lt;&lt; std::endl;<br>    Creator *creator2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreteCreator2</span>();<br>    <span class="hljs-built_in">ClientCode</span>(*creator2);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>工厂模式用来隔离类对象的使用者和具体类型之间的耦合关系。面对一个经常变化的具体类型，紧耦合关系导致软件脆弱。</p><p>将要创建的具体对象的工作延迟到子类。</p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>在软件系统中，经常面临<strong>一系列相互依赖的对象</strong>的创建工作，同时需求的变化，往往<strong>存在更多系列</strong>对象的创建工作。</p><p>提供一个接口，让该接口负责创建一系列相关或者相互依赖的对象，无需指定它们具体的类。</p><p><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240630154505578.png" alt="image-20240630154505578"></p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h4 id="局部静态变量实现单例"><a href="#局部静态变量实现单例" class="headerlink" title="局部静态变量实现单例"></a>局部静态变量实现单例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 局部静态变量实现单例类 c11之前是线程不安全的</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleInstance</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">SingleInstance</span>()&#123;&#125;<br>    <span class="hljs-built_in">SingleInstance</span>(<span class="hljs-type">const</span> SingleInstance &amp;) = <span class="hljs-keyword">delete</span>;<br>    SingleInstance&amp; <span class="hljs-keyword">operator</span>=(SingleInstance &amp;) = <span class="hljs-keyword">delete</span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> SingleInstance&amp; <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-type">static</span> SingleInstance single;<br>        <span class="hljs-keyword">return</span> single;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="饿汉模式的单例"><a href="#饿汉模式的单例" class="headerlink" title="饿汉模式的单例"></a>饿汉模式的单例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 饿汉模式实现单例</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleHungryInstance</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">SingleHungryInstance</span>()&#123;&#125;<br>    <span class="hljs-built_in">SingleHungryInstance</span>(<span class="hljs-type">const</span> SingleHungryInstance &amp;) = <span class="hljs-keyword">delete</span>;<br>    SingleHungryInstance &amp;<span class="hljs-keyword">operator</span>=(SingleHungryInstance &amp;) = <span class="hljs-keyword">delete</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> SingleHungryInstance* <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(single == <span class="hljs-literal">nullptr</span>)&#123;<br>            single = <span class="hljs-keyword">new</span> SingleHungryInstance;<br>        &#125;<br>        <span class="hljs-keyword">return</span> single;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> SingleHungryInstance *single;<br>&#125;;<br><span class="hljs-comment">// 初始化类静态成员变量</span><br>SingleHungryInstance* SingleHungryInstance::single = <span class="hljs-keyword">new</span> SingleHungryInstance;<br></code></pre></td></tr></table></figure><h4 id="懒汉模式的单例"><a href="#懒汉模式的单例" class="headerlink" title="懒汉模式的单例"></a>懒汉模式的单例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleLazyInstance</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">SingleLazyInstance</span>()&#123;&#125;<br>    <span class="hljs-built_in">SingleLazyInstance</span>(<span class="hljs-type">const</span> SingleLazyInstance &amp;) = <span class="hljs-keyword">delete</span>;<br>    SingleLazyInstance &amp;<span class="hljs-keyword">operator</span>=(SingleLazyInstance &amp;) = <span class="hljs-keyword">delete</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> SingleLazyInstance* <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(single != <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> single;<br>        &#125;<br>        m_mtx.<span class="hljs-built_in">lock</span>();<br>        <span class="hljs-comment">// 双检查锁</span><br>        <span class="hljs-keyword">if</span>(single != <span class="hljs-literal">nullptr</span>)&#123;<br>            m_mtx.<span class="hljs-built_in">unlock</span>();<br>            <span class="hljs-keyword">return</span> single;<br>        &#125;<br>        single = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SingleLazyInstance</span>();<br>        m_mtx.<span class="hljs-built_in">unlock</span>();<br>        <span class="hljs-keyword">return</span> single;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">static</span> SingleLazyInstance *single;<br>  <span class="hljs-type">static</span> std::mutex m_mtx;<br>&#125;;<br><span class="hljs-comment">// 静态成员变量不要忘记类外初始化</span><br>SingleLazyInstance *SingleLazyInstance::single = <span class="hljs-literal">nullptr</span>;<br>std::mutex SingleLazyInstance::m_mtx;<br></code></pre></td></tr></table></figure><h4 id="std-call-once的单例"><a href="#std-call-once的单例" class="headerlink" title="std::call_once的单例"></a>std::call_once的单例</h4><p>在单例模式下使用，<code>std::once_flag</code>实例对应一次不同的初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 使用std::call_once的单例模式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleLazyInstance2</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">SingleLazyInstance2</span>()&#123;&#125;<br>    <span class="hljs-built_in">SingleLazyInstance2</span>(<span class="hljs-type">const</span> SingleLazyInstance2 &amp;) = <span class="hljs-keyword">delete</span>;<br>    SingleLazyInstance2 &amp;<span class="hljs-keyword">operator</span>=(SingleLazyInstance2 &amp;) = <span class="hljs-keyword">delete</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> SingleLazyInstance2* <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 使用std::call_once确保single只被初始化一次</span><br>        std::<span class="hljs-built_in">call_once</span>(initFlag, []() &#123; <br>            single = <span class="hljs-keyword">new</span> SingleLazyInstance2; <br>        &#125;);<br>        <span class="hljs-keyword">return</span> single;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">static</span> SingleLazyInstance2 *single;<br>  <span class="hljs-type">static</span> std::once_flag initFlag;<br>&#125;;<br><span class="hljs-comment">// 静态成员变量不要忘记类外初始化</span><br>SingleLazyInstance2 *SingleLazyInstance2::single = <span class="hljs-literal">nullptr</span>;<br>std::once_flag SingleLazyInstance2::initFlag;<br></code></pre></td></tr></table></figure><p>使用<code>std::call_once</code>实现的单例模板类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">Singleton</span>()&#123;&#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Singleton</span>()&#123;&#125;<br>    <span class="hljs-built_in">Singleton</span>(<span class="hljs-type">const</span> Singleton&lt;T&gt; &amp;) = <span class="hljs-keyword">delete</span>;<br>    Singleton&lt;T&gt; &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Singleton&lt;T&gt; &amp;) = <span class="hljs-keyword">delete</span>;<br><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> T&amp; <span class="hljs-title">GetInsance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-type">static</span> T instance;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>有一个对象，希望产生与其完全相同的复制品</p><h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><h3 id="单一职责类："><a href="#单一职责类：" class="headerlink" title="单一职责类："></a>单一职责类：</h3><h3 id="1、装饰模式"><a href="#1、装饰模式" class="headerlink" title="1、装饰模式"></a>1、装饰模式</h3><p><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240629145354687.png" alt="image-20240629145354687"></p><p><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240629145411371.png" alt="image-20240629145411371"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//业务操作</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stream</span>&#123;<br><span class="hljs-keyword">public</span>：<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-type">int</span> position)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-type">char</span> data)</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Stream</span>()&#123;&#125;<br>&#125;;<br><span class="hljs-comment">//主体类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileStream</span>: <span class="hljs-keyword">public</span> Stream&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span></span>&#123;<br>        <span class="hljs-comment">//读文件流</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-type">int</span> position)</span></span>&#123;<br>        <span class="hljs-comment">//定位文件流</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(<span class="hljs-type">char</span> data)</span></span>&#123;<br>        <span class="hljs-comment">//写文件流</span><br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NetworkStream</span> :<span class="hljs-keyword">public</span> Stream&#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MemoryStream</span> :<span class="hljs-keyword">public</span> Stream&#123;&#125;;<br><br><span class="hljs-comment">//扩展操作</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CryptoStream</span>: <span class="hljs-keyword">public</span> Stream &#123;<br>    <span class="hljs-comment">// 通过聚合来实现装饰器</span><br>    Stream* stream;<span class="hljs-comment">//...</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CryptoStream</span>(Stream* stm):<span class="hljs-built_in">stream</span>(stm)&#123; <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">char</span> <span class="hljs-title">Read</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span></span>&#123;  <br>        <span class="hljs-comment">//额外的加密操作...</span><br>        stream-&gt;<span class="hljs-built_in">Read</span>(number);<span class="hljs-comment">//读文件流</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Seek</span><span class="hljs-params">(<span class="hljs-type">int</span> position)</span></span>&#123;<br>        <span class="hljs-comment">//额外的加密操作...</span><br>        stream::<span class="hljs-built_in">Seek</span>(position);<span class="hljs-comment">//定位文件流</span><br>        <span class="hljs-comment">//额外的加密操作...</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Write</span><span class="hljs-params">(byte data)</span></span>&#123;<br>        <span class="hljs-comment">//额外的加密操作...</span><br>        stream::<span class="hljs-built_in">Write</span>(data);<span class="hljs-comment">//写文件流</span><br>        <span class="hljs-comment">//额外的加密操作...</span><br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedStream</span> : <span class="hljs-keyword">public</span> Stream&#123;<br>    Stream* stream;<span class="hljs-comment">//...</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BufferedStream</span>(Stream* stm):<span class="hljs-built_in">stream</span>(stm)&#123; &#125;<br>    <span class="hljs-comment">//...</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Process</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">//运行时装配</span><br>    FileStream* s1=<span class="hljs-keyword">new</span> <span class="hljs-built_in">FileStream</span>();<br>    CryptoStream* s2=<span class="hljs-keyword">new</span> <span class="hljs-built_in">CryptoStream</span>(s1);<br>    BufferedStream* s3=<span class="hljs-keyword">new</span> <span class="hljs-built_in">BufferedStream</span>(s1);<br>    BufferedStream* s4=<span class="hljs-keyword">new</span> <span class="hljs-built_in">BufferedStream</span>(s2);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、桥模式"><a href="#2、桥模式" class="headerlink" title="2、桥模式"></a>2、桥模式</h3><p>将一个大类或者紧密相关的类拆分为抽象和实现两个独立的层次结构，将抽象部分（业务功能）和实现部分（平台实现）分离，都可以独立地变化。</p><h1 id="行为模式"><a href="#行为模式" class="headerlink" title="行为模式"></a>行为模式</h1><h3 id="组件协作类："><a href="#组件协作类：" class="headerlink" title="组件协作类："></a>组件协作类：</h3><p>组件协作模式通过晚绑定，实现框架与应用程序的松耦合</p><h3 id="1、模板方法"><a href="#1、模板方法" class="headerlink" title="1、模板方法"></a>1、模板方法</h3><p>定义一个操作中算法的骨架（稳定），而是将一些步骤延迟（变化）到子类中。Template Method使得子类可以不改变（复用）一个算法的结构，即可重定义（override）该算法的特定步骤。</p><p><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240628235413653.png" alt="image-20240628235413653"></p><p>*<strong>不论是在哪个设计模式中，在类图中应该指出稳定的部分，和变化的部分来便于理解</strong></p><p>拓展：子类继承父类，对虚函数进行override。</p><p>内含反向的调用结构，不要调用我，让我来调用你。</p><p>推荐将被Template Method调用的虚方法成为protected的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">library</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-built_in">step1</span>();<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">step2</span>())&#123;<br>            <span class="hljs-built_in">step3</span>();<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i) &#123;<br>            <span class="hljs-built_in">step4</span>();<br>        &#125;<br>        <span class="hljs-built_in">step5</span>();<br>    &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">library</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;library is destory&quot;</span> &lt;&lt; std::endl; &#125;<br>  <span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">step1</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;step 1&quot;</span> &lt;&lt; std::endl; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">step3</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;step 3&quot;</span> &lt;&lt; std::endl; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">step5</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;step 5&quot;</span> &lt;&lt; std::endl; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">step2</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 变化</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">step4</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span>:<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">application</span>: <span class="hljs-keyword">public</span> library&#123;<br><span class="hljs-keyword">public</span>:<br>  ~<span class="hljs-built_in">application</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;application is destory&quot;</span> &lt;&lt; std::endl; &#125;<br><br><span class="hljs-keyword">protected</span>:<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">step2</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;step 2&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">step4</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;step 4&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    library *lib = <span class="hljs-keyword">new</span> application;<br>    lib-&gt;<span class="hljs-built_in">run</span>();<br>    <span class="hljs-keyword">delete</span> lib;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、策略模式"><a href="#2、策略模式" class="headerlink" title="2、策略模式"></a>2、策略模式</h3><p>定义一系列算法，把它们一个个封装起来，并且使它们可互相替换（变化）。该模式使得算法可独立于使用它的客户程序（稳定）而变化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 当存在大量if else选择执行</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">TaxBase</span> &#123;<br>CN_Tax,US_Tax,DE_Tax,<br>    FR_Tax<span class="hljs-comment">//改变</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SalesOrder</span>&#123;<br>    TaxBase tax;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">CalculateTax</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//...</span><br>        <span class="hljs-keyword">if</span> (tax == CN_Tax)&#123;<br>            <span class="hljs-comment">//CN***********</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tax == US_Tax)&#123;<br>            <span class="hljs-comment">//US***********</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tax == DE_Tax)&#123;<br>            <span class="hljs-comment">//DE***********</span><br>        &#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tax == FR_Tax)&#123;  <span class="hljs-comment">//改变</span><br><span class="hljs-comment">//...</span><br>&#125;<br>        <span class="hljs-comment">//....</span><br>     &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>使用策略模式更改这些if else选项</p><p><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240629223222091.png" alt="image-20240629223222091"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TaxStrategy</span>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-type">const</span> Context &amp;context)</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">TaxStrategy</span>()&#123;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CNTax</span> : <span class="hljs-keyword">public</span> TaxStrategy &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-type">const</span> Context &amp;context)</span></span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;do CN tax&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1.0f</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NATax</span> : <span class="hljs-keyword">public</span> TaxStrategy&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">double</span> <span class="hljs-title">Calculate</span><span class="hljs-params">(<span class="hljs-type">const</span> Context &amp;context)</span></span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;do NA tax&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2.0f</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SalesOrder</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SalesOrder</span>(TaxStrategy *taxStrategy) <span class="hljs-comment">// 此处可以使用工厂方法构造</span><br>    :<span class="hljs-built_in">strategy</span>(taxStrategy)&#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">CalculateTax</span><span class="hljs-params">()</span></span>&#123;<br>        Context context;<br>        <span class="hljs-type">double</span> val = strategy-&gt;<span class="hljs-built_in">Calculate</span>(context);<br>        <span class="hljs-keyword">return</span> val;<br>    &#125;<br>    ~<span class="hljs-built_in">SalesOrder</span>()&#123;<br>        <span class="hljs-keyword">delete</span> strategy;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>  TaxStrategy *strategy;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    TaxStrategy *tax = <span class="hljs-keyword">new</span> NATax;<br>    <span class="hljs-function">SalesOrder <span class="hljs-title">sales</span><span class="hljs-params">(tax)</span></span>;<br>    sales.<span class="hljs-built_in">CalculateTax</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Strategy及其子类为组件提供了一系列可以重用的算法，从而使类型在运行时方便的在各个算法中进行转化。</p><p><strong>Strategy模式提供条件判断语句的另一种选择</strong>，消除条件判断就是在解耦合。</p><p>如果Strategy对象没有实例变量，那么上下文可以共享同一个Strategy对象，节约对象开销。</p><h3 id="3、观察者-事件模式"><a href="#3、观察者-事件模式" class="headerlink" title="3、观察者&#x2F;事件模式"></a>3、观察者&#x2F;事件模式</h3><p>定义对象间<strong>一种对多（变化）的依赖关系</strong>，以便当<strong>一个对象的状态发生改变时，所有依赖它的对象都能够得到通知并自动更新</strong>。</p><p><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240629135852220.png" alt="image-20240629135852220"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-comment">// --------------------Observer</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IProgress</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">DoProgress</span><span class="hljs-params">(<span class="hljs-type">float</span> value)</span></span>=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">IProgress</span>()&#123;&#125;<br>&#125;;<br><span class="hljs-comment">// --------------------Subject</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileSplitter</span><br>&#123;<br>std::string m_filePath;<br><span class="hljs-type">int</span> m_fileNumber;<br>std::list&lt;IProgress*&gt;  m_iprogressList; <span class="hljs-comment">// 抽象通知机制，支持多个观察者</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">FileSplitter</span>(<span class="hljs-type">const</span> std::string&amp; filePath, <span class="hljs-type">int</span> fileNumber) :<br><span class="hljs-built_in">m_filePath</span>(filePath), <br><span class="hljs-built_in">m_fileNumber</span>(fileNumber)&#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">split</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//1.读取大文件</span><br><span class="hljs-comment">//2.分批次向小文件中写入           </span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m_fileNumber; i++)&#123;<br><span class="hljs-comment">//...</span><br><span class="hljs-type">float</span> progressValue = m_fileNumber;<br>progressValue = (i + <span class="hljs-number">1</span>) / progressValue;<br><span class="hljs-built_in">onProgress</span>(progressValue);<span class="hljs-comment">//发送通知</span><br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addIProgress</span><span class="hljs-params">(IProgress* iprogress)</span></span>&#123;<br>m_iprogressList.<span class="hljs-built_in">push_back</span>(iprogress);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeIProgress</span><span class="hljs-params">(IProgress* iprogress)</span></span>&#123;<br>m_iprogressList.<span class="hljs-built_in">remove</span>(iprogress);<br>&#125;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-comment">// 通知所有的观察者</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onProgress</span><span class="hljs-params">(<span class="hljs-type">float</span> value)</span></span>&#123;<br>std::list&lt;IProgress*&gt;::iterator itor=m_iprogressList.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">while</span> (itor != m_iprogressList.<span class="hljs-built_in">end</span>() )&#123;<br>(*itor)-&gt;<span class="hljs-built_in">DoProgress</span>(value); <span class="hljs-comment">//更新进度条</span><br>itor++;<br>&#125;<br>&#125;<br>&#125;;<br><span class="hljs-comment">// --------------------ConcreteObserver</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MainForm</span> : <span class="hljs-keyword">public</span> Form, <span class="hljs-keyword">public</span> IProgress<br>&#123;<br>TextBox* txtFilePath;<br>TextBox* txtFileNumber;<br>ProgressBar* progressBar;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Button1_Click</span><span class="hljs-params">()</span></span>&#123;<br>std::string filePath = txtFilePath-&gt;<span class="hljs-built_in">getText</span>();<br><span class="hljs-type">int</span> number = std::<span class="hljs-built_in">atoi</span>(txtFileNumber-&gt;<span class="hljs-built_in">getText</span>().<span class="hljs-built_in">c_str</span>());<br>ConsoleNotifier cn;<br><span class="hljs-function">FileSplitter <span class="hljs-title">splitter</span><span class="hljs-params">(filePath, number)</span></span>;<br>splitter.<span class="hljs-built_in">addIProgress</span>(<span class="hljs-keyword">this</span>); <span class="hljs-comment">//订阅通知</span><br>        splitter.<span class="hljs-built_in">addIProgress</span>(&amp;cn);  <span class="hljs-comment">// 订阅通知</span><br>splitter.<span class="hljs-built_in">split</span>();<br>splitter.<span class="hljs-built_in">removeIProgress</span>(<span class="hljs-keyword">this</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">DoProgress</span><span class="hljs-params">(<span class="hljs-type">float</span> value)</span></span>&#123;<br>progressBar-&gt;<span class="hljs-built_in">setValue</span>(value);<br>&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsoleNotifier</span> : <span class="hljs-keyword">public</span> IProgress &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">DoProgress</span><span class="hljs-params">(<span class="hljs-type">float</span> value)</span></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;.&quot;</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>使用面向对象的抽象，Observer模式使我们可以独立地改变目标与观察者，使二者之间的依赖关系松耦合</p><p>目标发送通知，无需指定观察者，通知可以自动传播，观察者自己决定是否订阅通知，目标对象对此一无所知。</p><p>Observer模式是基于事件的UI框架中非常常用的设计模式，是MVC模式中重要组成。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Boost.Asio</title>
    <link href="/2024/07/31/C++asio/"/>
    <url>/2024/07/31/C++asio/</url>
    
    <content type="html"><![CDATA[<p><strong>《总之，好记性不如烂笔头！把你遗忘的都记下来吧！》</strong></p><h1 id="C-asio网络编程"><a href="#C-asio网络编程" class="headerlink" title="C++ asio网络编程"></a>C++ asio网络编程</h1><p><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240630150204589.png" alt="image-20240630150204589"></p><h3 id="基本的asio创建tcp连接流程"><a href="#基本的asio创建tcp连接流程" class="headerlink" title="基本的asio创建tcp连接流程"></a>基本的asio创建tcp连接流程</h3><p>终端节点：</p><p>终端节点就是用来通信的端对端的节点，可以通过ip地址和端口构造，其的节点可以连接这个终端节点做通信</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 服务端创建终端节点</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_num = <span class="hljs-number">3333</span>;<br>asio::ip::address ip_address = asio::ip::address_v6::<span class="hljs-built_in">any</span>();<br>asio::ip::<span class="hljs-function">tcp::endpoint <span class="hljs-title">ep</span><span class="hljs-params">(ip_address, port_num)</span></span>;<br><span class="hljs-comment">// 客户端创建终端节点</span><br>std::string raw_ip_address = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port_num = <span class="hljs-number">3333</span>;<br>boost::system::error_code ec;<br>asio::ip::address ip_address =<br>    asio::ip::address::<span class="hljs-built_in">from_string</span>(raw_ip_address, ec);<br><span class="hljs-comment">// Step 3.</span><br>asio::ip::<span class="hljs-function">tcp::endpoint <span class="hljs-title">ep</span><span class="hljs-params">(ip_address, port_num)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>客户端</strong></p><p>客户端创建socket的方法:</p><p>1、创建上下文io_context 2、选择协议 3、生成socket 4、打开soket</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">asio::io_context  ioc;<br><span class="hljs-comment">// Step 2. Creating an object of &#x27;tcp&#x27; class representing</span><br><span class="hljs-comment">// a TCP protocol with IPv4 as underlying protocol.</span><br>asio::ip::tcp protocol = asio::ip::tcp::<span class="hljs-built_in">v4</span>();<br><span class="hljs-comment">// Step 3. Instantiating an active TCP socket object.</span><br>asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(ioc)</span></span>;<br><span class="hljs-comment">// Used to store information about error that happens</span><br><span class="hljs-comment">// while opening the socket.</span><br>boost::system::error_code ec;<br><span class="hljs-comment">// Step 4. Opening the socket.</span><br>sock.<span class="hljs-built_in">open</span>(protocol, ec);<br></code></pre></td></tr></table></figure><p>客户端创建socket，并通过connect连接指定的对端</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string raw_ip_address = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port = <span class="hljs-number">3333</span>;<br>asio::ip::<span class="hljs-function">tcp::endpoint <span class="hljs-title">ep</span><span class="hljs-params">(asio::ip::address::from_string(raw_ip_address),port)</span></span>;<br><span class="hljs-comment">// 创建socket必须的上下文</span><br>asio::io_context ioc;<br><span class="hljs-comment">// 创建socket，创建socket时指定了协议，将自动执行open</span><br>asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(ioc, ep.protocol())</span></span>;<br><span class="hljs-comment">// 连接</span><br>sock.<span class="hljs-built_in">connect</span>(ep);<br></code></pre></td></tr></table></figure><p><strong>服务端</strong></p><p>服务端创建socket，还需要生成一个acceptor的socket，用来接收连接</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 老版本创建acceptor需要 open()</span><br>asio::io_context ioc;<br>asio::ip::<span class="hljs-function">tcp::acceptor <span class="hljs-title">acceptor</span><span class="hljs-params">(ioc)</span></span>;<br>asio::ip::tcp protocol = asio::ip::tcp::<span class="hljs-built_in">v4</span>();<br>boost::system::error_code ec;<br>acceptor.<span class="hljs-built_in">open</span>(protocol, ec);<br><span class="hljs-comment">// 如果创建acceptor时指定了协议，将自动执行open</span><br>asio::ip::<span class="hljs-function">tcp::acceptor <span class="hljs-title">acceptor</span><span class="hljs-params">(ios, protocol)</span></span>;<br></code></pre></td></tr></table></figure><p>acceptor绑定bind，并监听listen与接收连接accept</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 服务器创建端点ep</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port = <span class="hljs-number">3333</span>;<br>asio::ip::address ip_address = asio::ip::address_v4::<span class="hljs-built_in">any</span>();<br>asio::ip::<span class="hljs-function">tcp::endpoint <span class="hljs-title">ep</span><span class="hljs-params">(ip_address, port)</span></span>;<br><span class="hljs-comment">// 创建acceptor</span><br>asio::io_context ioc;<br>asio::ip::<span class="hljs-function">tcp::acceptor <span class="hljs-title">acceptor</span><span class="hljs-params">(ioc, ep.protocol())</span></span>;<br>boost::system::error_code ec;<br><span class="hljs-comment">// bind()绑定端点</span><br>acceptor.<span class="hljs-built_in">bind</span>(ep, ec);<br><span class="hljs-comment">// 缓冲连接大小</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> BACKLOG_SIZE = <span class="hljs-number">30</span>;<br><span class="hljs-comment">// 监听</span><br>acceptor.<span class="hljs-built_in">listen</span>(BACKLOG_SIZE);<br><span class="hljs-comment">// 接受的sock连接由新创建的sock处理</span><br>asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(ioc)</span></span>;<br>acceptor.<span class="hljs-built_in">accept</span>(sock);<br></code></pre></td></tr></table></figure><p>创建acceptor并进行open,bind,listen一气呵成的初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">asio::io_context ioc;<br><span class="hljs-comment">// 新版本创建acceptor 并直接绑定</span><br>asio::ip::<span class="hljs-function">tcp::acceptor <span class="hljs-title">a</span><span class="hljs-params">(ioc, asio::ip::tcp::endpoint(asio::ip::tcp::v4(), <span class="hljs-number">3333</span>))</span></span>;<br>asio::ip::<span class="hljs-function">tcp::socket <span class="hljs-title">sock</span><span class="hljs-params">(ioc)</span></span>;<br>acceptor.<span class="hljs-built_in">accept</span>(sock);<br></code></pre></td></tr></table></figure><p><strong>async_accept</strong>异步的接收客户端连接</p><p>接受一个提供服务的socket，并可以传递回调函数执行回调函数内的逻辑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">m_ac.<span class="hljs-built_in">async_accept</span>(new_session-&gt;<span class="hljs-built_in">Socket</span>(),<br>std::<span class="hljs-built_in">bind</span>(&amp;Server::handle_accept, <span class="hljs-keyword">this</span>, new_session, std::placeholders::_1));<br></code></pre></td></tr></table></figure><h3 id="接收和发送缓冲区"><a href="#接收和发送缓冲区" class="headerlink" title="接收和发送缓冲区"></a>接收和发送缓冲区</h3><p>任何网络库都有提供buffer的数据结构，所谓buffer就是接收和发送数据时缓存数据的结构。 <code>boost::asio</code>提供了<code>asio::mutable_buffer </code>和 <code>asio::const_buffer</code>这两个结构，他们是一段连续的空间，首字节存储了后续数据的长度。 <code>asio::mutable_buffer</code>用于写服务，<code>asio::const_buffer</code>用于读服务。但是这两个结构都没有被asio的api直接使用。 对于api的buffer参数，asio提出了MutableBufferSequence和ConstBufferSequence概念，他们是由多个<code>asio::mutable_buffer</code>和<code>asio::const_buffer</code>组成的。也就是说<code>boost::asio</code>为了节省空间，将一部分连续的空间组合起来，作为参数交给api使用。 我们可以理解为MutableBufferSequence的数据结构为std::vector 结构如下</p><img src="https://cdn.llfc.club/1676257797218.jpg" alt="https://cdn.llfc.club/1676257797218.jpg" style="zoom:80%;" /><h3 id="同步读写api"><a href="#同步读写api" class="headerlink" title="同步读写api"></a>同步读写api</h3><p><strong>同步写</strong></p><p><code>socket::write_some</code></p><p>可以每次向指定的空间写入固定的字节数，如果写缓冲区满了，就只写一部分，返回写入的字节数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string buf = <span class="hljs-string">&quot;hello world&quot;</span>;<br>std::<span class="hljs-type">size_t</span> total_bytes_written = <span class="hljs-number">0</span>; <span class="hljs-comment">// 已经发送的字节数</span><br><span class="hljs-keyword">while</span> (total_bytes_written != buf.<span class="hljs-built_in">length</span>()) &#123;<br>    <span class="hljs-comment">// asio::buffer()指定发送的位置和长度</span><br>    total_bytes_written += sock.<span class="hljs-built_in">write_some</span>(asio::<span class="hljs-built_in">buffer</span>(buf.<span class="hljs-built_in">c_str</span>()+total_bytes_written<br>    , buf.<span class="hljs-built_in">length</span>() - total_bytes_written));<br>&#125;<br></code></pre></td></tr></table></figure><p><code>soket::send</code></p><p>一次性将buffer中的内容发送给对端，如果有部分字节因为发送缓冲区满无法发送，则阻塞等待，直到发送缓冲区可用，则继续发送完成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string buf = <span class="hljs-string">&quot;Hello World!&quot;</span>;<br><span class="hljs-type">int</span> send_length = sock.<span class="hljs-built_in">send</span>(asio::<span class="hljs-built_in">buffer</span>(buf.<span class="hljs-built_in">c_str</span>(), buf.<span class="hljs-built_in">length</span>()));<br></code></pre></td></tr></table></figure><p><code>boost::asio::write</code></p><p>确保发送整个缓冲区的数据。它通常用于确保数据完全传输，需要传递socket。在内部，<code>asio::write</code> 函数通过反复调用低级别的 <code>write_some</code> 函数来实现这一点，直到整个缓冲区的数据都被成功发送。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string buf = <span class="hljs-string">&quot;Hello World!&quot;</span>;<br><span class="hljs-type">int</span> send_length  = asio::<span class="hljs-built_in">write</span>(sock, asio::<span class="hljs-built_in">buffer</span>(buf.<span class="hljs-built_in">c_str</span>(), buf.<span class="hljs-built_in">length</span>()));<br></code></pre></td></tr></table></figure><p><strong>同步读</strong></p><p><code>socket::read_some</code></p><p>同步读和同步写类似，提供了读取指定字节数的接口<code>read_some</code>。如果缓冲区中没有数据可供读取，<code>read_some</code> 将阻塞，直到有数据可供读取。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> MESSAGE_SIZE = <span class="hljs-number">7</span>;<br><span class="hljs-type">char</span> buf[MESSAGE_SIZE];<br>std::<span class="hljs-type">size_t</span> total_bytes_read = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span> (total_bytes_read != MESSAGE_SIZE) &#123;<br>    total_bytes_read += sock.<span class="hljs-built_in">read_some</span>(<br>    asio::<span class="hljs-built_in">buffer</span>(buf + total_bytes_read,<br>    MESSAGE_SIZE - total_bytes_read));<br>&#125;<br></code></pre></td></tr></table></figure><p><code>socket::receive</code></p><p>可以一次性同步接收对方发送的数据，如果缓冲区中没有数据可供读取，<code>receive</code> 也会阻塞，直到有数据可供读取。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> BUFF_SIZE = <span class="hljs-number">7</span>;<br><span class="hljs-type">char</span> buffer_receive[BUFF_SIZE];<br><span class="hljs-type">int</span> receive_length =  sock.<span class="hljs-built_in">receive</span>(asio::<span class="hljs-built_in">buffer</span>(buffer_receive, BUFF_SIZE));<br></code></pre></td></tr></table></figure><p><code>boost::asio::read</code></p><p>一次性同步读取对方发送的数据，通过多次调用read_some实现，需要传递socket。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> BUFF_SIZE = <span class="hljs-number">7</span>;<br><span class="hljs-type">char</span> buffer_receive[BUFF_SIZE];<br><span class="hljs-type">int</span> receive_length = asio::<span class="hljs-built_in">read</span>(sock, asio::<span class="hljs-built_in">buffer</span>(buffer_receive, BUFF_SIZE));<br></code></pre></td></tr></table></figure><h3 id="异步读写api"><a href="#异步读写api" class="headerlink" title="异步读写api"></a>异步读写api</h3><p><code>socket::async_write_some()</code></p><p><code>async_write_some</code>是异步写的函数，这个异步写函数有两个参数，第一个参数为<code>ConstBufferSequence</code>常引用类型的buffers， 第二个参数为<code>WriteToken</code>类型，而<code>WriteToken</code>在上面定义了，是一个函数对象类型，返回值为void，参数为error_code和size_t， 所以我们为了调用<code>async_write_some</code>函数也要传入一个符合<code>WriteToken</code>定义的函数，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteToSocketErr</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; buf)</span> </span>&#123;<br>    _send_node = <span class="hljs-built_in">make_shared</span>&lt;MsgNode&gt;(buf.<span class="hljs-built_in">c_str</span>(), buf.<span class="hljs-built_in">length</span>());<br>    <span class="hljs-comment">//异步发送数据，因为异步所以不会一下发送完</span><br>    <span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_write_some</span>(asio::<span class="hljs-built_in">buffer</span>(_send_node-&gt;_msg, <br>        _send_node-&gt;_total_len),<br>        std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteCallBackErr,<br>            <span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2, _send_node));<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Session::WriteCallBackErr</span><span class="hljs-params">(<span class="hljs-type">const</span> system::error_code&amp; ec, <span class="hljs-type">const</span> std::<span class="hljs-type">size_t</span>&amp; bytes_transfered, std::shared_ptr&lt;MsgNode&gt; node)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 当前发送消息加上已经发送的消息 判断 总消息数量</span><br><span class="hljs-keyword">if</span> (bytes_transfered + node-&gt;m_cur_len &lt; node-&gt;m_total_len) &#123;<br>node-&gt;m_cur_len += bytes_transfered;<br><span class="hljs-comment">// 如果小于，继续发送</span><br><span class="hljs-keyword">this</span>-&gt;p_socket-&gt;<span class="hljs-built_in">async_write_some</span>(asio::<span class="hljs-built_in">buffer</span>(p_send_node-&gt;p_msg + node-&gt;m_cur_len, node-&gt;m_total_len - node-&gt;m_cur_len),[<span class="hljs-keyword">this</span>,node](<span class="hljs-type">const</span> system::error_code&amp;,<span class="hljs-type">const</span> std::<span class="hljs-type">size_t</span> &amp;bytes_rans)&#123;<br>            <span class="hljs-built_in">WriteCallBackErr</span>(ec, bytes_trans,node); &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>需要注意的问题：</strong></p><p>而实际开发的场景用户是不清楚底层tcp的多路复用调用情况的，用户想发送数据的时候就调用<code>WriteToSocketErr</code>,或者循环调用<code>WriteToSocketErr</code>，很可能在一次没发送完数据还未调用回调函数时再次调用<code>WriteToSocketErr</code>，因为<code>boost::asio</code>封装的时epoll和iocp等多路复用模型，当写事件就绪后就发数据，发送的数据按照<code>async_write_some</code>调用的顺序发送，所以回调函数内调用的<code>async_write_some</code>可能并没有被及时调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//用户发送数据</span><br><span class="hljs-built_in">WriteToSocketErr</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br><span class="hljs-comment">//用户无感知下层调用情况又一次发送了数据</span><br><span class="hljs-built_in">WriteToSocketErr</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br></code></pre></td></tr></table></figure><p>那么很可能第一次只发送了Hello，后面的数据没发完，第二次发送了Hello World!之后又发送了World! 所以对端收到的数据很可能是”HelloHello World! World!</p><p>解决方法：<strong>定义一个发送队列，使用队列来维护数据的发送顺序</strong></p><p><code>socket::async_send()</code></p><p>异步发送，一次性发送所有数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">this</span>-&gt;_socket-&gt;<span class="hljs-built_in">async_send</span>(asio::<span class="hljs-built_in">buffer</span>(send_data-&gt;_msg + send_data-&gt;_cur_len, send_data-&gt;_total_len - send_data-&gt;_cur_len),std::<span class="hljs-built_in">bind</span>(&amp;Session::WriteAllCallBack,<span class="hljs-keyword">this</span>, std::placeholders::_1, std::placeholders::_2));<br></code></pre></td></tr></table></figure><p><code>boost::asio::async_write()</code></p><p><code>async_read_some()</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">_socket-&gt;<span class="hljs-built_in">async_read_some</span>(asio::<span class="hljs-built_in">buffer</span>(_recv_node-&gt;_msg+_recv_node-&gt;_cur_len, _recv_node-&gt;_total_len - _recv_node-&gt;_cur_len), std::<span class="hljs-built_in">bind</span>(&amp;Session::ReadCallBack, <span class="hljs-keyword">this</span>,<br>            std::placeholders::_1, std::placeholders::_2));<br></code></pre></td></tr></table></figure><p><code>async_receive()</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">_socket-&gt;<span class="hljs-built_in">async_receive</span>(asio::<span class="hljs-built_in">buffer</span>(_recv_node-&gt;_msg, _recv_node-&gt;_total_len), std::<span class="hljs-built_in">bind</span>(&amp;Session::ReadAllCallBack, <span class="hljs-keyword">this</span>,std::placeholders::_1, std::placeholders::_2));<br>_recv_pending = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p><code>boost::asio::async_read()</code></p><h3 id="封装Server和Session管理类"><a href="#封装Server和Session管理类" class="headerlink" title="封装Server和Session管理类"></a>封装Server和Session管理类</h3><p>[asio&#x2F;lecture 05 echo AsyncServer&#x2F;Session.h at master · haokss&#x2F;asio (github.com)](<a href="https://github.com/haokss/asio/blob/master/lecture">https://github.com/haokss/asio/blob/master/lecture</a> 05 echo AsyncServer&#x2F;Session.h)</p><p><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240725143439857.png" alt="image-20240725143439857"></p><h3 id="处理异步发送乱序问题"><a href="#处理异步发送乱序问题" class="headerlink" title="处理异步发送乱序问题"></a>处理异步发送乱序问题</h3><p>[asio&#x2F;lecture 07 sample package&#x2F;Session.cpp at master · haokss&#x2F;asio (github.com)](<a href="https://github.com/haokss/asio/blob/master/lecture">https://github.com/haokss/asio/blob/master/lecture</a> 07 sample package&#x2F;Session.cpp)</p><p><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240725145610542.png" alt="image-20240725145610542"></p><h3 id="粘包问题"><a href="#粘包问题" class="headerlink" title="粘包问题"></a>粘包问题</h3><p>因为TCP底层通信是面向字节流的，TCP只保证发送数据的准确性和顺序性，字节流以字节为单位，客户端每次发送N个字节给服务端，N取决于当前客户端的发送缓冲区是否有数据，比如发送缓冲区总大小为10个字节，当前有5个字节数据(上次要发送的数据比如’loveu’)未发送完，那么此时只有5个字节空闲空间，我们调用发送接口发送hello world！其实就是只能发送Hello给服务器，那么服务器一次性读取到的数据就很可能是loveuhello。而剩余的world！只能留给下一次发送，下一次服务器接收到的就是world！ 如下图<a href="https://cdn.llfc.club/1682251035380.jpg"><img src="https://cdn.llfc.club/1682251035380.jpg" alt="https://cdn.llfc.club/1682251035380.jpg"></a></p><p><strong>处理粘包</strong></p><p>处理粘包的方式主要采用应用层定义收发包格式的方式，这个过程俗称切包处理，常用的协议被称为tlv协议(消息id+消息长度+消息内容)，如下图<a href="https://cdn.llfc.club/1683367901552.jpg"><img src="https://cdn.llfc.club/1683367901552.jpg" alt="https://cdn.llfc.club/1683367901552.jpg"></a></p><p>处理粘包问题的简易方法：</p><p><a href="https://gitbookcpp.llfc.club/sections/cpp/boost/asio14.html">asio处理粘包的简易方式 · 恋恋风辰的编程笔记 (llfc.club)</a></p><h3 id="字节序问题"><a href="#字节序问题" class="headerlink" title="字节序问题"></a>字节序问题</h3><h4 id="服务器使用网络字节序"><a href="#服务器使用网络字节序" class="headerlink" title="服务器使用网络字节序"></a>服务器使用网络字节序</h4><p>为保证字节序一致性，网络传输使用网络字节序，也就是大端模式。<br>在 boost::asio 库中，可以使用<code>boost::asio::detail::socket_ops::host_to_network_long() </code>和 <code>boost::asio::detail::socket_ops::host_to_network_short() </code>函数将主机字节序转换为网络字节序。具体方法如下：</p><p>判断本机字节序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 判断当前系统的字节序是大端序还是小端序</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_big_endian</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (*(<span class="hljs-type">char</span>*)&amp;num == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 当前系统为小端序</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 当前系统为大端序</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0x12345678</span>;<br>    <span class="hljs-type">char</span>* p = (<span class="hljs-type">char</span>*)&amp;num;<br>    cout &lt;&lt; <span class="hljs-string">&quot;原始数据：&quot;</span> &lt;&lt; hex &lt;&lt; num &lt;&lt; endl;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_big_endian</span>()) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;当前系统为大端序&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;字节序为：&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">sizeof</span>(num); i++) &#123;<br>            cout &lt;&lt; hex &lt;&lt; (<span class="hljs-type">int</span>)*(p + i) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;当前系统为小端序&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;字节序为：&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-built_in">sizeof</span>(num) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            cout &lt;&lt; hex &lt;&lt; (<span class="hljs-type">int</span>)*(p + i) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="封装逻辑线程处理逻辑功能"><a href="#封装逻辑线程处理逻辑功能" class="headerlink" title="封装逻辑线程处理逻辑功能"></a>封装逻辑线程处理逻辑功能</h3><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240725152857694.png" alt="image-20240725152857694" style="zoom:200%;" /><h3 id="protobuf序列化工具"><a href="#protobuf序列化工具" class="headerlink" title="protobuf序列化工具"></a>protobuf序列化工具</h3><p>Protocol Buffers（简称 Protobuf）是一种轻便高效的序列化数据结构的协议，由 Google 开发。它可以用于将结构化数据序列化到二进制格式，并广泛用于数据存储、通信协议、配置文件等领域。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 定义proto</span><br>syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br>message MsgData<br>&#123;<br>   int32  id = <span class="hljs-number">1</span>;<br>   string data = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端发送protobuf序列化消息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">MsgData msgdata;<br>msgdata.<span class="hljs-built_in">set_id</span>(<span class="hljs-number">1001</span>);<br>msgdata.<span class="hljs-built_in">set_data</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>std::string request;<br>msgdata.<span class="hljs-built_in">SerializeToString</span>(&amp;request);<br></code></pre></td></tr></table></figure><p>服务端接收序列化消息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">MsgData msgdata;<br>std::string receive_data;<br>msgdata.<span class="hljs-built_in">ParseFromString</span>(std::<span class="hljs-built_in">string</span>(_recv_msg_node-&gt;_data, _recv_msg_node-&gt;_total_len));<br>std::cout &lt;&lt; <span class="hljs-string">&quot;recevie msg id  is &quot;</span> &lt;&lt; msgdata.<span class="hljs-built_in">id</span>() &lt;&lt; <span class="hljs-string">&quot; msg data is &quot;</span> &lt;&lt; msgdata.<span class="hljs-built_in">data</span>() &lt;&lt; endl;<br>std::string return_str = <span class="hljs-string">&quot;server has received msg, msg data is &quot;</span> + msgdata.<span class="hljs-built_in">data</span>();<br>MsgData msgreturn;<br>msgreturn.<span class="hljs-built_in">set_id</span>(msgdata.<span class="hljs-built_in">id</span>());<br>msgreturn.<span class="hljs-built_in">set_data</span>(return_str);<br>msgreturn.<span class="hljs-built_in">SerializeToString</span>(&amp;return_str);<br><span class="hljs-built_in">Send</span>(return_str);<br></code></pre></td></tr></table></figure><h3 id="json序列化"><a href="#json序列化" class="headerlink" title="json序列化"></a>json序列化</h3><p>使用jsoncpp进行序列化，jsoncpp 是一个 C++ JSON 库，它提供了将 JSON 数据解析为 C++ 对象、将 C++ 对象序列化为 JSON 数据的功能。它支持所有主流操作系统</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;json/json.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;json/value.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;json/reader.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Json::Value root;<br>    root[<span class="hljs-string">&quot;id&quot;</span>] = <span class="hljs-number">1001</span>;<br>    root[<span class="hljs-string">&quot;data&quot;</span>] = <span class="hljs-string">&quot;hello world&quot;</span>;<br>    std::string request = root.<span class="hljs-built_in">toStyledString</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;request is &quot;</span> &lt;&lt; request &lt;&lt; std::endl;<br><br>    Json::Value root2;<br>    Json::Reader reader;<br>    reader.<span class="hljs-built_in">parse</span>(request, root2);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;msg id is &quot;</span> &lt;&lt; root2[<span class="hljs-string">&quot;id&quot;</span>] &lt;&lt; <span class="hljs-string">&quot; msg is &quot;</span> &lt;&lt; root2[<span class="hljs-string">&quot;data&quot;</span>] &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="服务器优雅推出"><a href="#服务器优雅推出" class="headerlink" title="服务器优雅推出"></a>服务器优雅推出</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">boost::asio::io_context ioc;<br><span class="hljs-comment">// 设置服务器推出信号</span><br>boost::<span class="hljs-function">asio::signal_set <span class="hljs-title">signals</span><span class="hljs-params">(ioc, SIGINT, SIGTERM)</span></span>;<br>signals.<span class="hljs-built_in">async_wait</span>([&amp;ioc](<span class="hljs-keyword">auto</span>, <span class="hljs-keyword">auto</span>) &#123;<br>ioc.<span class="hljs-built_in">stop</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><p>使用调用堆栈查看LogicSystem析构</p><h3 id="asio协程"><a href="#asio协程" class="headerlink" title="asio协程"></a>asio协程</h3><p>协程更容易处理IO密集型的服务器，因为其协程上下文切换快</p><h3 id="封装IOServicePool"><a href="#封装IOServicePool" class="headerlink" title="封装IOServicePool"></a>封装IOServicePool</h3><p><img src="https://cdn.llfc.club/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230604151126.png" alt="https://cdn.llfc.club/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230604151126.png"></p><h3 id="使用beast构建http服务器"><a href="#使用beast构建http服务器" class="headerlink" title="使用beast构建http服务器"></a>使用beast构建http服务器</h3><p>[asio&#x2F;lecture 14 HttpServer&#x2F;lecture 14 HttpServer.cpp at master · haokss&#x2F;asio (github.com)](<a href="https://github.com/haokss/asio/blob/master/lecture">https://github.com/haokss/asio/blob/master/lecture</a> 14 HttpServer&#x2F;lecture 14 HttpServer.cpp)</p><p><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240704163156448.png" alt="image-20240704163156448"></p><h3 id="使用beast搭建websocket服务器"><a href="#使用beast搭建websocket服务器" class="headerlink" title="使用beast搭建websocket服务器"></a>使用beast搭建websocket服务器</h3><p>[asio&#x2F;lecture 15 Websocket at master · haokss&#x2F;asio (github.com)](<a href="https://github.com/haokss/asio/tree/master/lecture">https://github.com/haokss/asio/tree/master/lecture</a> 15 Websocket)</p><h3 id="服务器通信grpc"><a href="#服务器通信grpc" class="headerlink" title="服务器通信grpc"></a>服务器通信grpc</h3><p>通过grpc可以实现服务器之间的通信</p><p>库配置：<a href="https://blog.csdn.net/qq_42102546/article/details/133071765?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~Ctr-3-133071765-blog-135999810.235%5Ev43%5Epc_blog_bottom_relevance_base7&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~Ctr-3-133071765-blog-135999810.235%5Ev43%5Epc_blog_bottom_relevance_base7&utm_relevant_index=4">win10系统 C++环境 安装编译GRPC_windows下grpc安装教程c++-CSDN博客</a></p><p>编译proto文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">protoc.exe  -I=&quot;.&quot; --grpc_out=&quot;.&quot; --plugin=protoc-gen-grpc=&quot;D:\c++_lib\grpc-1.34.0\grpc\visualpro\Debug\grpc_cpp_plugin.exe&quot; &quot;message.proto&quot;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">protoc.exe --cpp_out=. &quot;message.proto&quot;<br></code></pre></td></tr></table></figure><p>定义proto文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br>package hello;<br>service Greeter &#123;<br>  <span class="hljs-function">rpc <span class="hljs-title">SayHello</span> <span class="hljs-params">(HelloRequest)</span> <span class="hljs-title">returns</span> <span class="hljs-params">(HelloReply)</span> </span>&#123;&#125;<br>&#125;<br>message HelloRequest &#123;<br>  string message = <span class="hljs-number">1</span>;<br>&#125;<br>message HelloReply &#123;<br>  string message = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Linux网络编程"><a href="#Linux网络编程" class="headerlink" title="Linux网络编程"></a>Linux网络编程</h1><p>通过fork函数来创建一个进程副本<code>pit_t fork(void)</code></p><p>对于父进程：fork函数返回子进程ID</p><p>对于子进程：fork函数返回0</p><p>利用<code>wait 和 waitpid</code>函数来等待进程的结束，防止僵尸进程的产生。</p><p>wait是阻塞的等待，而waitpid是非阻塞的等待。</p><h3 id="I-O复用"><a href="#I-O复用" class="headerlink" title="I&#x2F;O复用"></a>I&#x2F;O复用</h3><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p><code>select</code> 实现 I&#x2F;O 多路复用的工作原理</p><ol><li><strong>文件描述符集</strong>： <code>select</code> 使用 <code>fd_set</code> 类型来存储一组文件描述符。程序使用 <code>FD_SET</code>、<code>FD_CLR</code>、<code>FD_ISSET</code> 和 <code>FD_ZERO</code> 等宏来操作这些集合。</li><li><strong>监视多个文件描述符</strong>：通过 <code>FD_SET</code> 将感兴趣的文件描述符（如套接字）添加到集合中。然后调用 <code>select</code>，传递这些集合。<code>select</code> 会阻塞，直到其中至少有一个文件描述符可以执行非阻塞 I&#x2F;O 操作。</li><li><strong>处理活动文件描述符</strong>：当 <code>select</code> 返回时，遍历文件描述符集，使用 <code>FD_ISSET</code> 宏检查哪个文件描述符有活动（如新连接、可读数据等），然后对这些文件描述符执行相应的操作。</li></ol><ul><li><strong>优点</strong>：<ul><li>可以在单个线程中处理多个客户端连接。</li><li>易于理解和使用。</li></ul></li><li><strong>缺点</strong>：<ul><li>有最大文件描述符数的限制。</li><li>当文件描述符数量较大时，性能下降，因为需要线性扫描文件描述符集。</li><li><code>select</code> 每次调用后都需要重新初始化文件描述符集，增加了额外的开销。</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++并发编程</title>
    <link href="/2024/07/31/concurrency/"/>
    <url>/2024/07/31/concurrency/</url>
    
    <content type="html"><![CDATA[<p><strong>《总之，好记性不如烂笔头！把你遗忘的都记下来吧！》</strong></p><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><h3 id="std-thread"><a href="#std-thread" class="headerlink" title="std::thread"></a>std::thread</h3><p>函数可以是<strong>普通函数</strong>，<strong>成员函数</strong>，<strong>函数对象</strong>，<strong>lambda表达式</strong></p><p>普通函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CPP">std::<span class="hljs-built_in">thread</span>(func, args...)<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printHelloWorld</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;msg)</span></span>&#123;<br>    std::cout&lt;&lt;msg;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">thread1</span><span class="hljs-params">(printHelloWorld, <span class="hljs-string">&quot;hello world&quot;</span>)</span></span>;<br>    thread<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>类的非静态成员函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">A a;<br><span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(&amp;A::func, &amp;a)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>支持拷贝操作</strong></p><h4 id="1、-join-阻塞主线程，等待子线程完成"><a href="#1、-join-阻塞主线程，等待子线程完成" class="headerlink" title="1、 join() 阻塞主线程，等待子线程完成"></a>1、 join() 阻塞主线程，等待子线程完成</h4><p>**joinable()**判断对象能够汇合，如果不能汇合将返回false，如果对已经汇合过的线程调用join()将产生错误行为。</p><h4 id="2、detach-将子线程和主线程分离"><a href="#2、detach-将子线程和主线程分离" class="headerlink" title="2、detach() 将子线程和主线程分离"></a>2、detach() 将子线程和主线程分离</h4><p>如果等到std::thread对象销毁还没决定join()&#x2F;detach() ,std::thread的析构函数将调用**std::terminate()**终止整个程序。</p><h4 id="获取线程ID"><a href="#获取线程ID" class="headerlink" title="获取线程ID"></a>获取线程ID</h4><p>线程ID所属的型别为std::thread::id,  可以通过调用std::this_thread::get_id()获得。</p><h4 id="std-thread源码剖析"><a href="#std-thread源码剖析" class="headerlink" title="std::thread源码剖析"></a>std::thread源码剖析</h4><h3 id="数据未定义错误-线程传递参数问题"><a href="#数据未定义错误-线程传递参数问题" class="headerlink" title="数据未定义错误&#x2F;线程传递参数问题"></a>数据未定义错误&#x2F;线程传递参数问题</h3><h5 id="1、传入函数对象临时变量导致构造函数语法与声明函数一致"><a href="#1、传入函数对象临时变量导致构造函数语法与声明函数一致" class="headerlink" title="1、传入函数对象临时变量导致构造函数语法与声明函数一致"></a>1、传入函数对象临时变量导致构造函数语法与声明函数一致</h5><p>如：std::thread my_thread(background_task())，此时将my_thread当作函数指针</p><p>解决方法： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 1、多加一个括号</span><br><span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">((background_task()))</span></span>;<br><span class="hljs-comment">// 2、使用列表初始化</span><br>std::thread t&#123;<span class="hljs-built_in">background_task</span>()&#125;;<br></code></pre></td></tr></table></figure><h5 id="2、传入临时变量，但形参为引用"><a href="#2、传入临时变量，但形参为引用" class="headerlink" title="2、传入临时变量，但形参为引用"></a>2、传入临时变量，但形参为引用</h5><p>临时变量被传入参数后销毁，形参的引用导致了未定义的行为。</p><p>解决方法：</p><ul><li>通过智能指针传递参数，因为引用计数会随着赋值增加，保证变量使用期间不被释放，叫做：伪闭包策略</li><li>将局部变量的值作为参数传递，但拷贝消耗时间空间</li></ul><h5 id="3、传递指针或者引用指向已经释放的内存"><a href="#3、传递指针或者引用指向已经释放的内存" class="headerlink" title="3、传递指针或者引用指向已经释放的内存"></a>3、传递指针或者引用指向已经释放的内存</h5><h5 id="4、入口函数为类的私有成员函数"><a href="#4、入口函数为类的私有成员函数" class="headerlink" title="4、入口函数为类的私有成员函数"></a>4、入口函数为类的私有成员函数</h5><p>解决方法：将私有成员函数变为友元函数</p><h5 id="5、移交线程归属权"><a href="#5、移交线程归属权" class="headerlink" title="5、移交线程归属权"></a><strong>5、移交线程归属权</strong></h5><p>不能将一个线程的归属权交给一个已经绑定线程的变量</p><h3 id="在异常的情况下等待线程完结"><a href="#在异常的情况下等待线程完结" class="headerlink" title="在异常的情况下等待线程完结"></a>在异常的情况下等待线程完结</h3><p>当主线程发生异常时，可能会导致子线程的join()未执行，从而导致子线程不能执行完全。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 使用异常捕获确保子线程被join()</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(my_func)</span></span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">do_something_in_current_thread</span>();<br>    &#125;<span class="hljs-built_in">catch</span>(...)&#123;<br>        t.<span class="hljs-built_in">join</span>();<br>        <span class="hljs-keyword">throw</span>;<br>    &#125;<br>    t.<span class="hljs-built_in">join</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="通过RAII过程等待线程完结"><a href="#通过RAII过程等待线程完结" class="headerlink" title="通过RAII过程等待线程完结"></a><strong>通过RAII过程等待线程完结</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">thread_guard</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">thread_guard</span><span class="hljs-params">(std::thread &amp;<span class="hljs-type">_t</span>)</span>:t(_t)&#123;</span>&#125;<br>    <span class="hljs-built_in">thread_guard</span>(<span class="hljs-type">const</span> thread_guard &amp;) = <span class="hljs-keyword">delete</span>;<br>    thread_guard &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> thread_guard &amp;) = <span class="hljs-keyword">delete</span>;<br>    ~<span class="hljs-built_in">thread_guard</span>()&#123;<br>        <span class="hljs-keyword">if</span>(t.<span class="hljs-built_in">joinable</span>())&#123;<br>            t.<span class="hljs-built_in">join</span>();<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>  std::thread &amp;t;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="控制运行的线程数量"><a href="#控制运行的线程数量" class="headerlink" title="控制运行的线程数量"></a>控制运行的线程数量</h3><p>函数**std::thread::hardware_concurrency()**表示程序在各次运行中可真正并发的线程数量。在多核系统上，该值可能就是CPU的核芯数量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 并发版本的accumulate</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;exception&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">empty_stack</span> : <span class="hljs-keyword">public</span> std::exception&#123;<br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">what</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator, <span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">accumlate_block</span>&#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Iterator first, Iterator last, T&amp; result)</span></span>&#123;<br>        result = std::<span class="hljs-built_in">accumulate</span>(first, last, result);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator, <span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">parallel_accumulate</span><span class="hljs-params">(Iterator first, Iterator last, T init)</span></span>&#123;<br>    <span class="hljs-keyword">auto</span> length = std::<span class="hljs-built_in">distance</span>(first, last);<br>    <span class="hljs-keyword">if</span>(!length)<br>        <span class="hljs-keyword">return</span> init;<br>    <span class="hljs-type">const</span> <span class="hljs-type">long</span> min_per_thread = <span class="hljs-number">25</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">long</span> max_threads = (length + min_per_thread - <span class="hljs-number">1</span>) / min_per_thread;<br>    <span class="hljs-type">const</span> <span class="hljs-type">long</span> hardware_threads = std::thread::<span class="hljs-built_in">hardware_concurrency</span>();<br>    <span class="hljs-type">const</span> <span class="hljs-type">long</span> num_threads = std::<span class="hljs-built_in">min</span>(hardware_threads != <span class="hljs-number">0</span> ? hardware_threads : <span class="hljs-number">2</span>,<br>                                        max_threads);<br>    <span class="hljs-type">const</span> <span class="hljs-type">long</span> block_size = length / num_threads;<br>    <span class="hljs-function">std::vector&lt;T&gt; <span class="hljs-title">results</span><span class="hljs-params">(num_threads)</span></span>;<br>    <span class="hljs-function">std::vector&lt;std::thread&gt; <span class="hljs-title">threads</span><span class="hljs-params">(num_threads - <span class="hljs-number">1</span>)</span></span>;<br>    Iterator block_start = first;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> i = <span class="hljs-number">0</span>; i &lt; (num_threads - <span class="hljs-number">1</span>);++i)&#123;<br>        Iterator block_end = block_start;<br>        std::<span class="hljs-built_in">advance</span>(block_end, block_size);<br>        threads[i] = std::<span class="hljs-built_in">thread</span>(<br>            <span class="hljs-built_in">accumlate_block</span>&lt;Iterator, T&gt;(), block_start, block_end, std::<span class="hljs-built_in">ref</span>(results[i]));<br>        block_start = block_end;<br>    &#125;<br>    <span class="hljs-built_in">accumlate_block</span>&lt;Iterator, T&gt;()(block_start, last, results[num_threads - <span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; entry: threads)&#123;<br>        entry.<span class="hljs-built_in">join</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">accumulate</span>(results.<span class="hljs-built_in">begin</span>(), results.<span class="hljs-built_in">end</span>(), init);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; a;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000000</span>;++i)&#123;<br>        a.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 并发的accumlate</span><br>    <span class="hljs-keyword">auto</span> beforeTime = std::chrono::steady_clock::<span class="hljs-built_in">now</span>();<br>    <span class="hljs-built_in">parallel_accumulate</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">auto</span> afterTime = std::chrono::steady_clock::<span class="hljs-built_in">now</span>();<br>    std::cout &lt;&lt; std::chrono::<span class="hljs-built_in">duration</span>&lt;<span class="hljs-type">double</span>&gt;(afterTime - beforeTime).<span class="hljs-built_in">count</span>() &lt;&lt; std::endl;<br>    <span class="hljs-comment">// 非并发的accmulate</span><br>    beforeTime = std::chrono::steady_clock::<span class="hljs-built_in">now</span>();<br>    std::<span class="hljs-built_in">accumulate</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>    afterTime = std::chrono::steady_clock::<span class="hljs-built_in">now</span>();<br>    std::cout &lt;&lt; std::chrono::<span class="hljs-built_in">duration</span>&lt;<span class="hljs-type">double</span>&gt;(afterTime - beforeTime).<span class="hljs-built_in">count</span>() &lt;&lt; std::endl;<br>    <span class="hljs-comment">// 标准库中并发的std::reduce</span><br>    beforeTime = std::chrono::steady_clock::<span class="hljs-built_in">now</span>();<br>    std::<span class="hljs-built_in">reduce</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>    afterTime = std::chrono::steady_clock::<span class="hljs-built_in">now</span>();<br>    std::cout &lt;&lt; std::chrono::<span class="hljs-built_in">duration</span>&lt;<span class="hljs-type">double</span>&gt;(afterTime - beforeTime).<span class="hljs-built_in">count</span>() &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="存储std-thread容器"><a href="#存储std-thread容器" class="headerlink" title="存储std::thread容器"></a>存储std::thread容器</h3><p>使用容器存储线程，如<code>std::vector</code>，由于<code>std::thread</code>没有拷贝构造函数使用<code>push_back</code>必须显示构造一个临时<code>std::thread</code>变量，然后利用移动构造函数移入容器。</p><p>而使用emplace_back可以直接在容器内部构造一个<code>std::thread</code>，能够减少一次移动构造。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">my_thread</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span>&#123;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    std::vector&lt;std::thread&gt; vec;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">((my_thread()))</span></span>;<br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    <span class="hljs-comment">// 使用push_back()</span><br>    vec.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">thread</span>(<span class="hljs-built_in">my_thread</span>()));<br>    <span class="hljs-comment">// 使用emplace_back()</span><br>    vec.<span class="hljs-built_in">emplace_back</span>((<span class="hljs-built_in">my_thread</span>()));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;t:vec)&#123;<br>        t.<span class="hljs-built_in">join</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="std-jthread"><a href="#std-jthread" class="headerlink" title="std::jthread"></a>std::jthread</h3><p><strong>自动汇合（join on destruction）</strong>:</p><ul><li><code>std::jthread</code> 在析构时自动调用 <code>join()</code>，确保线程在对象销毁前完成。这可以避免常见的资源泄漏问题或未处理的线程终止问题。</li><li>对比之下，<code>std::thread</code> 在析构时如果线程仍然可运行（joinable），则会调用 <code>std::terminate()</code>。</li></ul><p><strong>传递停止令牌（stop token）</strong>:</p><ul><li><code>std::jthread</code> 提供了一种机制，可以传递一个 <code>std::stop_token</code> 给线程函数，用于请求线程停止。这是通过 <code>std::jthread</code> 构造函数的重载实现的，它会创建一个 <code>std::stop_source</code> 和一个 <code>std::stop_token</code>，并将 <code>std::stop_token</code> 传递给线程函数。</li><li>这使得线程管理和停止控制更加方便和安全。</li></ul><p><strong>更好的 RAII 支持</strong>:</p><ul><li>由于 <code>std::jthread</code> 自动管理线程的生命周期（自动 <code>join</code>），它更符合 RAII（资源获取即初始化）原则，降低了出错的概率。</li></ul><h2 id="数据共享"><a href="#数据共享" class="headerlink" title="数据共享"></a>数据共享</h2><h3 id="std-mutex"><a href="#std-mutex" class="headerlink" title="std::mutex"></a>std::mutex</h3><p>利用了临界区的概念，创建了一个互斥的代码块。创建互斥锁</p><p>1、lock()加锁</p><p>2、unlock()解锁</p><h3 id="std-lock"><a href="#std-lock" class="headerlink" title="std::lock"></a>std::lock</h3><p>同时对两个锁进行加锁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::<span class="hljs-built_in">lock</span>(mtx1, mtx2);<br></code></pre></td></tr></table></figure><h3 id="std-timed-mutex"><a href="#std-timed-mutex" class="headerlink" title="std::timed_mutex"></a>std::timed_mutex</h3><p>支持延迟加锁的互斥锁，当使用延迟加锁时，就使用这个锁来控制互斥量。</p><h3 id="std-lock-guard"><a href="#std-lock-guard" class="headerlink" title="std::lock_guard"></a>std::lock_guard</h3><p>构造时加锁系，析构时解锁，只在局部作用域中使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 使用lock_guard需要注意使用&#123; &#125;花括号来控制作用域!</span><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>    &#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>        --shared_data;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;current thread is &quot;</span> &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; std::endl;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;shared_data is &quot;</span> &lt;&lt; shared_data &lt;&lt; std ::endl;<br>    &#125;<br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">microseconds</span>(<span class="hljs-number">1000</span>));<br>&#125; &#125;);<br></code></pre></td></tr></table></figure><p>传递第二个参数为std::adopt_lock表示获取锁之前已经加锁了, 锁是领取过来的。通过std::lock_gruard就可以管理这个领取过来的锁了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 为了同时给mtx1,mtx2加锁</span><br>std::<span class="hljs-built_in">lock</span>(mtx1, mtx2);<br><span class="hljs-comment">// 将这两个锁领养过来管理</span><br><span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">guard1</span><span class="hljs-params">(mtx1, std::adopt_lock)</span></span>;<br><span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">guard2</span><span class="hljs-params">(mtx2, std::adopt_lock)</span></span><br></code></pre></td></tr></table></figure><h3 id="std-scope-lock-c-17"><a href="#std-scope-lock-c-17" class="headerlink" title="std::scope_lock c++17"></a>std::scope_lock c++17</h3><p>提供了另一种同时对多个锁进行加锁并控制的操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::scope_lock <span class="hljs-title">lock</span><span class="hljs-params">(mtx1, mtx2)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="std-unique-lock"><a href="#std-unique-lock" class="headerlink" title="std::unique_lock"></a>std::unique_lock</h3><p>对互斥量的灵活加锁，构造时自动加锁，析构时解锁。</p><p>传递第二个参数std::adopt_lock指明对象管理互斥上的锁；</p><p>​  std::defer_lock使互斥在完成构造时为无锁状态，延迟加锁。</p><p>成员函数:</p><p><code>lock()</code>自己加锁；</p><p><code>unlock()</code>自己解锁；</p><p><code>owns_lock() </code>判断是否占有了锁；</p><p><code>try_lock_for()</code>等待一段时间，如果获取不到锁就结束等待；</p><p><code>try_lock_until()</code>等待到某个时间, 如果获取不到锁就结束等待；</p><h3 id="std-shared-mutex-c-17"><a href="#std-shared-mutex-c-17" class="headerlink" title="std::shared_mutex c++17"></a>std::shared_mutex c++17</h3><ul><li><p>提供了 <code>lock()</code>, <code>try_lock()</code>, 和 <code>try_lock_for()</code> 以及 <code>try_lock_until()</code> 函数，这些函数都可以用于获取互斥锁。</p></li><li><p>提供了 <code>try_lock_shared()</code> 和 <code>lock_shared()</code> 函数，这些函数可以用于获取共享锁。</p></li><li><p>当 <code>std::shared_mutex</code> 被锁定后，其他尝试获取该锁的线程将会被阻塞，直到该锁被解锁。</p></li></ul><p>使用<code>std::shared_lock&lt;&gt;</code>来构造控制共享锁， 独占的锁就由<code>std::lock_guard</code>或<code>std::unique_lock</code>控制</p><p><strong>读操作需要使用共享锁的原因：</strong></p><p>1、在读操作的过程中需要确保没有写操作，防止读入不完整的数据；</p><p>2、读操作之间是可以同时进行的；</p><h3 id="std-shared-time-mutex-c-14"><a href="#std-shared-time-mutex-c-14" class="headerlink" title="std::shared_time_mutex c++14"></a>std::shared_time_mutex c++14</h3><ul><li>与 <code>std::shared_mutex</code> 类似，也提供了 <code>lock()</code>, <code>try_lock()</code>, 和 <code>try_lock_for()</code> 以及 <code>try_lock_until()</code> 函数用于获取互斥锁。</li><li>与 <code>std::shared_mutex</code> 不同的是，它还提供了 <code>try_lock_shared()</code> 和 <code>lock_shared()</code> 函数用于获取共享锁，这些函数在尝试获取共享锁时具有超时机制。</li><li>当 <code>std::shared_timed_mutex</code> 被锁定后，其他尝试获取该锁的线程将会被阻塞，直到该锁被解锁，这与 <code>std::shared_mutex</code> 相同。然而，当尝试获取共享锁时，如果不能立即获得锁，<code>std::shared_timed_mutex</code> 会设置一个超时，超时过后如果仍然没有获取到锁，则操作将返回失败。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 使用共享锁共享读取的案例</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;shared_mutex&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DNSService</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">DNSService</span>()&#123;&#125;<br>    <span class="hljs-comment">// 查询操作使用共享锁</span><br>    <span class="hljs-function">std::string <span class="hljs-title">QueryDns</span><span class="hljs-params">(std::string dnsName)</span></span>&#123;<br>        <span class="hljs-function">std::shared_lock&lt;std::shared_mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(m_shared_mtx)</span></span>;<br>        <span class="hljs-keyword">auto</span> iter = dns_info.<span class="hljs-built_in">find</span>(dnsName);<br>        <span class="hljs-keyword">if</span>(iter != dns_info.<span class="hljs-built_in">end</span>())&#123;<br>            <span class="hljs-keyword">return</span> iter-&gt;second;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">// 写操作独占锁</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddDnsInfo</span><span class="hljs-params">(std::string dsnName, std::string dsnEntry)</span></span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::shared_mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(m_shared_mtx)</span></span>;<br>        dns_info.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">make_pair</span>(dsnName, dsnEntry));<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>  std::map&lt;std::string, std::string&gt; dns_info;<br>  <span class="hljs-keyword">mutable</span> std::shared_mutex m_shared_mtx;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    DNSService dns;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">([&amp;dns]() &#123; dns.AddDnsInfo(<span class="hljs-string">&quot;www.haha.com&quot;</span>, <span class="hljs-string">&quot;127.0.0.1&quot;</span>); &#125;)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        [&amp;dns]() &#123; std::cout &lt;&lt; dns.QueryDns(<span class="hljs-string">&quot;www.haha.com&quot;</span>) &lt;&lt; std::endl; &#125;)</span></span>;<br><br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="递归锁"><a href="#递归锁" class="headerlink" title="递归锁"></a>递归锁</h3><p>在接口内部加锁，并调用另一个加锁的接口导致循环加锁而卡死，可以使用递归锁来来避免。</p><p><code>std::recursive_mutex</code>,但是并不推荐使用这种操作，应该从设计上避免递归加锁。</p><h3 id="线程安全的栈"><a href="#线程安全的栈" class="headerlink" title="线程安全的栈"></a>线程安全的栈</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">safe_stack</span>&#123;   <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 默认构造函数</span><br>    <span class="hljs-built_in">safe_stack</span>()&#123;&#125;<br>    <span class="hljs-comment">// 拷贝构造函数</span><br>    <span class="hljs-built_in">safe_stack</span>(<span class="hljs-type">const</span> safe_stack &amp; other)&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(other.mtx)</span></span>;<br>        stk = other.stk;<br>    &#125;<br>    <span class="hljs-comment">// 禁用拷贝赋值运算符</span><br>    safe_stack &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> safe_stack &amp;) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T new_value)</span></span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(<span class="hljs-keyword">this</span>-&gt;mtx)</span></span>;<br>        stk.<span class="hljs-built_in">push</span>(std::<span class="hljs-built_in">move</span>(new_value));<br>    &#125;<br>    <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(<span class="hljs-keyword">this</span>-&gt;mtx)</span></span>;<br>        <span class="hljs-keyword">if</span>(stk.<span class="hljs-built_in">empty</span>())<br>            std::cerr &lt;&lt; <span class="hljs-string">&quot;pop error&quot;</span>;<br>        std::shared_ptr&lt;T&gt; ptr = std::<span class="hljs-built_in">make_shared</span>&lt;T&gt;(stk.<span class="hljs-built_in">top</span>());<br>        stk.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> ptr;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(T&amp; value)</span></span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(<span class="hljs-keyword">this</span>-&gt;mtx)</span></span>;<br>        <span class="hljs-keyword">if</span>(stk.<span class="hljs-built_in">empty</span>())<br>            std::cerr &lt;&lt; <span class="hljs-string">&quot;pop error&quot;</span>;<br>        value = stk.<span class="hljs-built_in">top</span>();<br>        stk.<span class="hljs-built_in">pop</span>();<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::mutex mtx;<br>    std::stack&lt;T&gt; stk;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="线程安全的单例模式"><a href="#线程安全的单例模式" class="headerlink" title="线程安全的单例模式"></a>线程安全的单例模式</h3><h4 id="局部静态变量实现单例"><a href="#局部静态变量实现单例" class="headerlink" title="局部静态变量实现单例"></a>局部静态变量实现单例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 局部静态变量实现单例类 c11之前是线程不安全的</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleInstance</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">SingleInstance</span>()&#123;&#125;<br>    <span class="hljs-built_in">SingleInstance</span>(<span class="hljs-type">const</span> SingleInstance &amp;) = <span class="hljs-keyword">delete</span>;<br>    SingleInstance&amp; <span class="hljs-keyword">operator</span>=(SingleInstance &amp;) = <span class="hljs-keyword">delete</span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> SingleInstance&amp; <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-type">static</span> SingleInstance single;<br>        <span class="hljs-keyword">return</span> single;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="饿汉模式的单例"><a href="#饿汉模式的单例" class="headerlink" title="饿汉模式的单例"></a>饿汉模式的单例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 饿汉模式实现单例</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleHungryInstance</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">SingleHungryInstance</span>()&#123;&#125;<br>    <span class="hljs-built_in">SingleHungryInstance</span>(<span class="hljs-type">const</span> SingleHungryInstance &amp;) = <span class="hljs-keyword">delete</span>;<br>    SingleHungryInstance &amp;<span class="hljs-keyword">operator</span>=(SingleHungryInstance &amp;) = <span class="hljs-keyword">delete</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> SingleHungryInstance* <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(single == <span class="hljs-literal">nullptr</span>)&#123;<br>            single = <span class="hljs-keyword">new</span> SingleHungryInstance;<br>        &#125;<br>        <span class="hljs-keyword">return</span> single;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> SingleHungryInstance *single;<br>&#125;;<br><span class="hljs-comment">// 初始化类静态成员变量</span><br>SingleHungryInstance* SingleHungryInstance::single = <span class="hljs-keyword">new</span> SingleHungryInstance;<br></code></pre></td></tr></table></figure><h4 id="懒汉模式的单例"><a href="#懒汉模式的单例" class="headerlink" title="懒汉模式的单例"></a>懒汉模式的单例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleLazyInstance</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">SingleLazyInstance</span>()&#123;&#125;<br>    <span class="hljs-built_in">SingleLazyInstance</span>(<span class="hljs-type">const</span> SingleLazyInstance &amp;) = <span class="hljs-keyword">delete</span>;<br>    SingleLazyInstance &amp;<span class="hljs-keyword">operator</span>=(SingleLazyInstance &amp;) = <span class="hljs-keyword">delete</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> SingleLazyInstance* <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(single != <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> single;<br>        &#125;<br>        m_mtx.<span class="hljs-built_in">lock</span>();<br>        <span class="hljs-comment">// 双检查锁</span><br>        <span class="hljs-keyword">if</span>(single != <span class="hljs-literal">nullptr</span>)&#123;<br>            m_mtx.<span class="hljs-built_in">unlock</span>();<br>            <span class="hljs-keyword">return</span> single;<br>        &#125;<br>        single = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SingleLazyInstance</span>();<br>        m_mtx.<span class="hljs-built_in">unlock</span>();<br>        <span class="hljs-keyword">return</span> single;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">static</span> SingleLazyInstance *single;<br>  <span class="hljs-type">static</span> std::mutex m_mtx;<br>&#125;;<br><span class="hljs-comment">// 静态成员变量不要忘记类外初始化</span><br>SingleLazyInstance *SingleLazyInstance::single = <span class="hljs-literal">nullptr</span>;<br>std::mutex SingleLazyInstance::m_mtx;<br></code></pre></td></tr></table></figure><h4 id="std-call-once的单例"><a href="#std-call-once的单例" class="headerlink" title="std::call_once的单例"></a>std::call_once的单例</h4><p>在单例模式下使用，<code>std::once_flag</code>实例对应一次不同的初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 使用std::call_once的单例模式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleLazyInstance2</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">SingleLazyInstance2</span>()&#123;&#125;<br>    <span class="hljs-built_in">SingleLazyInstance2</span>(<span class="hljs-type">const</span> SingleLazyInstance2 &amp;) = <span class="hljs-keyword">delete</span>;<br>    SingleLazyInstance2 &amp;<span class="hljs-keyword">operator</span>=(SingleLazyInstance2 &amp;) = <span class="hljs-keyword">delete</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> SingleLazyInstance2* <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 使用std::call_once确保single只被初始化一次</span><br>        std::<span class="hljs-built_in">call_once</span>(initFlag, []() &#123; <br>            single = <span class="hljs-keyword">new</span> SingleLazyInstance2; <br>        &#125;);<br>        <span class="hljs-keyword">return</span> single;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">static</span> SingleLazyInstance2 *single;<br>  <span class="hljs-type">static</span> std::once_flag initFlag;<br>&#125;;<br><span class="hljs-comment">// 静态成员变量不要忘记类外初始化</span><br>SingleLazyInstance2 *SingleLazyInstance2::single = <span class="hljs-literal">nullptr</span>;<br>std::once_flag SingleLazyInstance2::initFlag;<br></code></pre></td></tr></table></figure><p>使用<code>std::call_once</code>实现的单例模板类</p><p>&#x2F;&#x2F; TODO</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="防范死锁的准则"><a href="#防范死锁的准则" class="headerlink" title="防范死锁的准则"></a>防范死锁的准则</h4><ul><li><strong>避免嵌套锁</strong></li></ul><p>如果已经持有了锁，就不要试图获取第二个锁。如果要获取多个锁，应该采用std::lock()&#x2F;std::scope_lock，通过一次动作全部获取所有锁。</p><ul><li><p><strong>使用固定的顺序依次获取锁</strong></p></li><li><p><strong>层级锁</strong></p><p>在实际开发中很难规避在同一个函数内加多个锁的情况，我们要尽可能的避免循环加锁，可以自定义一个层级锁，保证对多个互斥量加锁时是有序的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">hierarchical_mutex</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">hierarchical_mutex</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> value)</span></span><br><span class="hljs-function">        : hierarchy_value(value), previous_hierarchy_value(<span class="hljs-number">0</span>)&#123;</span><br>        &#125;<br>    <span class="hljs-built_in">hierarchical_mutex</span>(<span class="hljs-type">const</span> hierarchical_mutex &amp;) = <span class="hljs-keyword">delete</span>;<br>    hierarchical_mutex &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> hierarchical_mutex &amp;) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-built_in">check_for_hierarchy_violation</span>();<br>        internal_mutex.<span class="hljs-built_in">lock</span>();<br>        <span class="hljs-built_in">update_hierarchy_value</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">// 解锁的时候必须确保上一次加锁的也是该对象</span><br>        <span class="hljs-keyword">if</span>(this_thread_hierarchy_value != hierarchy_value)&#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;mutex hierarchy violated1&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 恢复原来的层级</span><br>        this_thread_hierarchy_value = previous_hierarchy_value;<br>        internal_mutex.<span class="hljs-built_in">unlock</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">try_lock</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-built_in">check_for_hierarchy_violation</span>();<br>        <span class="hljs-keyword">if</span>(internal_mutex.<span class="hljs-built_in">try_lock</span>())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-built_in">update_hierarchy_value</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">check_for_hierarchy_violation</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">// 加锁的等级只能从高到底，否则抛出逻辑错误</span><br>        <span class="hljs-keyword">if</span>(this_thread_hierarchy_value &lt;= hierarchy_value)&#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;mutex hierarchy violated2&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update_hierarchy_value</span><span class="hljs-params">()</span></span>&#123;<br>        previous_hierarchy_value = this_thread_hierarchy_value;<br>        this_thread_hierarchy_value = hierarchy_value;<br>    &#125;<br>  <span class="hljs-keyword">private</span>:<br>    std::mutex internal_mutex;  <span class="hljs-comment">// 层级锁</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> hierarchy_value;    <span class="hljs-comment">// 当前层级值</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> previous_hierarchy_value; <span class="hljs-comment">// 上一次层级值</span><br>    <span class="hljs-type">static</span> <span class="hljs-keyword">thread_local</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> this_thread_hierarchy_value; <span class="hljs-comment">// 在单个线程内只存在一个的线程静态变量，表示</span><br>                                                                   <span class="hljs-comment">// 当前线程已经加了某个等级的锁</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">thread_local</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span></span><br><span class="hljs-function">    <span class="hljs-title">hierarchical_mutex::this_thread_hierarchy_value</span><span class="hljs-params">(ULONG_MAX)</span></span>;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_hierarchy_lock</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">hierarchical_mutex  <span class="hljs-title">hmtx1</span><span class="hljs-params">(<span class="hljs-number">1000</span>)</span></span>;<br>    <span class="hljs-function">hierarchical_mutex  <span class="hljs-title">hmtx2</span><span class="hljs-params">(<span class="hljs-number">500</span>)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">([&amp;hmtx1, &amp;hmtx2]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        hmtx<span class="hljs-number">1.l</span>ock();</span></span><br><span class="hljs-params"><span class="hljs-function">        hmtx<span class="hljs-number">2.l</span>ock();</span></span><br><span class="hljs-params"><span class="hljs-function">        hmtx<span class="hljs-number">2.</span>unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">        hmtx<span class="hljs-number">1.</span>unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;)</span></span>;<br><br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">([&amp;hmtx1, &amp;hmtx2]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        hmtx<span class="hljs-number">1.l</span>ock();    </span></span><br><span class="hljs-params"><span class="hljs-function">        hmtx<span class="hljs-number">2.l</span>ock();</span></span><br><span class="hljs-params"><span class="hljs-function">        hmtx<span class="hljs-number">2.</span>unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">        hmtx<span class="hljs-number">1.</span>unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;)</span></span>;<br><br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test_hierarchy_lock</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="线程间传递变量"><a href="#线程间传递变量" class="headerlink" title="线程间传递变量"></a>线程间传递变量</h2><h3 id="1、通过共享变量"><a href="#1、通过共享变量" class="headerlink" title="1、通过共享变量"></a>1、通过共享变量</h3><h3 id="2、通过参数传递"><a href="#2、通过参数传递" class="headerlink" title="2、通过参数传递"></a>2、通过参数传递</h3><h3 id="3、std-promise"><a href="#3、std-promise" class="headerlink" title="3、std::promise"></a>3、std::promise</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(std::promise&lt;<span class="hljs-type">int</span>&gt; &amp;f)</span></span>&#123;<br>    f.<span class="hljs-built_in">set_value</span>(<span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    std::promise&lt;<span class="hljs-type">int</span>&gt; f;<br>    std::future&lt;<span class="hljs-type">int</span>&gt; future_res = f.<span class="hljs-built_in">get_future</span>();<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func, std::ref(f))</span></span>;<br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    std::cout &lt;&lt; future_res.<span class="hljs-built_in">get</span>() &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="并发的同步"><a href="#并发的同步" class="headerlink" title="并发的同步"></a>并发的同步</h2><h3 id="std-condition-variable条件变量"><a href="#std-condition-variable条件变量" class="headerlink" title="std::condition_variable条件变量"></a>std::condition_variable条件变量</h3><p>成员函数：</p><p><strong>void wait( std::unique_lock&lt; std::mutex&gt; &gt;&amp; lock,  Predicate pred );</strong></p><p>wait导致当前线程被阻塞直到条件变量被通知，或者虚假唤醒发生，等待期间将解锁互斥。</p><blockquote><p>虚假唤醒：线程重新获得互斥，并查验条件，而这一行为却不是通过另一个线程的通知。（可能是操作系统做出的唤醒）</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 当传递谓词时，其等价于</span><br><span class="hljs-built_in">While</span>(!<span class="hljs-built_in">pred</span>())<br><span class="hljs-built_in">wait</span>(lock);<br><span class="hljs-comment">// 本质上是忙等的优化，while可以防止虚假唤醒导致线程阻塞失效</span><br></code></pre></td></tr></table></figure><p>当谓词返回false时，线程进入阻塞或等待状态，解锁互斥；</p><p>当谓词返回true时，线程从wait()中返回，互斥仍被锁住。</p><p><strong>wait_for()</strong></p><p>阻塞当前线程，直到条件变量被唤醒，或者到达指定时长</p><p><strong>wait_until()</strong></p><p>阻塞当前线程，直到条件变量被唤醒，或者到指定时间点</p><p><strong>notify_one</strong>()</p><p>通知一个等待的线程</p><p><strong>notify_all</strong>()</p><p>通知所有等待的线程</p><h3 id="使用条件变量循环打印消息"><a href="#使用条件变量循环打印消息" class="headerlink" title="使用条件变量循环打印消息"></a>使用条件变量循环打印消息</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br>std::mutex mtx;<br>std::condition_variable cv_a;<br>std::condition_variable cv_b;<br><span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_printA</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;num)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>        cv_a.<span class="hljs-built_in">wait</span>(lock, [&amp;num]()&#123; <br>            <span class="hljs-keyword">return</span> num == <span class="hljs-number">1</span>; <br>        &#125;);<br><br>        ++num;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;current thread num : &quot;</span> &lt;&lt; num &lt;&lt; std::endl;<br>        lock.<span class="hljs-built_in">unlock</span>();<br>        <span class="hljs-comment">// 通知阻塞线程</span><br>        cv_b.<span class="hljs-built_in">notify_one</span>();<br>        <span class="hljs-comment">// std::this_thread::sleep_for(std::chrono::microseconds(500));</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_printB</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;num)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>        cv_b.<span class="hljs-built_in">wait</span>(lock, [&amp;num]()&#123; <br>            <span class="hljs-keyword">return</span> num == <span class="hljs-number">2</span>; <br>        &#125;);<br><br>        --num;<br>        lock.<span class="hljs-built_in">unlock</span>();<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;current thread num : &quot;</span> &lt;&lt; num &lt;&lt; std::endl;<br>        cv_a.<span class="hljs-built_in">notify_one</span>();<br>        <span class="hljs-comment">// std::this_thread::sleep_for(std::chrono::microseconds(500));</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(do_printA, std::ref(num))</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(do_printB, std::ref(num))</span></span>;<br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用条件变量实现生产者消费者模型"><a href="#使用条件变量实现生产者消费者模型" class="headerlink" title="使用条件变量实现生产者消费者模型"></a>使用条件变量实现生产者消费者模型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br>std::mutex g_mutex;<br>std::condition_variable g_cv;<br>std::queue&lt;<span class="hljs-type">int</span>&gt; g_queue;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Producer</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        &#123;            <br>            <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(g_mutex)</span></span>;<br>            g_queue.<span class="hljs-built_in">push</span>(i);            <br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Producer: produced &quot;</span> &lt;&lt; i &lt;&lt; std::endl;<br>        &#125;<br>        g_cv.<span class="hljs-built_in">notify_one</span>();        <br>        std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">100</span>));<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Consumer</span><span class="hljs-params">()</span> </span>&#123;    <br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;        <br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(g_mutex)</span></span>;<br>        g_cv.<span class="hljs-built_in">wait</span>(lock, []() &#123; <span class="hljs-keyword">return</span> !g_queue.<span class="hljs-built_in">empty</span>(); &#125;);        <br>        <span class="hljs-type">int</span> value = g_queue.<span class="hljs-built_in">front</span>();<br>        g_queue.<span class="hljs-built_in">pop</span>();        <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Consumer: consumed &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <br>    <span class="hljs-function">std::thread <span class="hljs-title">producer_thread</span><span class="hljs-params">(Producer)</span></span>;    <br>    <span class="hljs-function">std::thread <span class="hljs-title">consumer_thread</span><span class="hljs-params">(Consumer)</span></span>;<br>    producer_thread.<span class="hljs-built_in">join</span>();<br>    consumer_thread.<span class="hljs-built_in">join</span>();    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="条件变量实现线程安全队列"><a href="#条件变量实现线程安全队列" class="headerlink" title="条件变量实现线程安全队列"></a>条件变量实现线程安全队列</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadSafeQueue</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ThreadSafeQueue</span>()&#123;&#125;<br>    <span class="hljs-built_in">ThreadSafeQueue</span>(<span class="hljs-type">const</span> ThreadSafeQueue&amp; t)&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(m_mtx)</span></span>;<br>        m_queue = t.m_queue;<br>    &#125;<br>    ThreadSafeQueue &amp;<span class="hljs-keyword">operator</span>=(ThreadSafeQueue &amp;) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T new_value)</span></span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(m_mtx)</span></span>;<br>        m_queue.<span class="hljs-built_in">push</span>(new_value);<br>        m_cv.<span class="hljs-built_in">notify_one</span>();<br>    &#125;<br>    <span class="hljs-comment">// 等待出栈,使用引用返回pop值</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wait_and_pop</span><span class="hljs-params">(T &amp;value)</span></span>&#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(m_mtx)</span></span>;<br>        <span class="hljs-comment">// pop为空时就阻塞挂起</span><br>        m_cv.<span class="hljs-built_in">wait</span>(lock, [<span class="hljs-keyword">this</span>]()<br>                  &#123; <span class="hljs-keyword">return</span> !m_queue.<span class="hljs-built_in">empty</span>(); &#125;);<br>        value = m_queue.<span class="hljs-built_in">front</span>();<br>        m_queue.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-comment">// 等待出栈，使用智能指针返回pop值</span><br>    <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">wait_and_pop</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(m_mtx)</span></span>;<br>        m_cv.<span class="hljs-built_in">wait</span>(lock, [<span class="hljs-keyword">this</span>]()<br>                  &#123; <span class="hljs-keyword">return</span> !m_queue.<span class="hljs-built_in">empty</span>(); &#125;);<br>        <span class="hljs-keyword">auto</span> ptr = std::<span class="hljs-built_in">make_shared</span>&lt;T&gt;(m_queue.<span class="hljs-built_in">front</span>());<br>        m_queue.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> ptr;<br>    &#125;<br>    <span class="hljs-comment">// 尝试出栈，成功出栈返回true</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">try_pop</span><span class="hljs-params">(T &amp;value)</span></span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(m_mtx)</span></span>;<br>        <span class="hljs-keyword">if</span>(m_queue.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        value = m_queue.<span class="hljs-built_in">front</span>();<br>        m_queue.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">try_pop</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(m_mtx)</span></span>;<br>        <span class="hljs-keyword">if</span>(m_queue.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_shared</span>&lt;T&gt;(<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">auto</span> ptr = std::<span class="hljs-built_in">make_shared</span>&lt;T&gt;(m_queue.<span class="hljs-built_in">front</span>());<br>        m_queue.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> ptr;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(m_mtx)</span></span>;<br>        <span class="hljs-keyword">return</span> m_queue.<span class="hljs-built_in">empty</span>();<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">mutable</span> std::mutex m_mtx; <span class="hljs-comment">// 声明为mutable，即使为常成员函数也能修改其值</span><br>    std::queue&lt;T&gt; m_queue;<br>    std::condition_variable m_cv;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 测试用例，创建一个生产者线程不断向队列中加入元素1....n，</span><br>    <span class="hljs-comment">// 有两个消费者线程从队列中取数据，其中消费者A使用等待的方式来取数据，消费者B使用尝试的方式来取数据</span><br>    ThreadSafeQueue&lt;<span class="hljs-type">int</span>&gt; queue;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">([&amp;queue]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; ;++i) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            queue.push(i);</span></span><br><span class="hljs-params"><span class="hljs-function">            std::cout &lt;&lt; <span class="hljs-string">&quot;producer push:&quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span></span><br><span class="hljs-params"><span class="hljs-function">            std::this_thread::sleep_for(std::chrono::milliseconds(<span class="hljs-number">200</span>));</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">consumer1</span><span class="hljs-params">([&amp;queue]() &#123;  </span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">auto</span> ptr = queue.wait_and_pop();</span></span><br><span class="hljs-params"><span class="hljs-function">            std::cout &lt;&lt; <span class="hljs-string">&quot;consumer1 get:&quot;</span> &lt;&lt; *ptr.get() &lt;&lt; std::endl;</span></span><br><span class="hljs-params"><span class="hljs-function">            std::this_thread::sleep_for(std::chrono::milliseconds(<span class="hljs-number">500</span>));</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">consumer2</span><span class="hljs-params">([&amp;queue]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-type">int</span> ret;</span></span><br><span class="hljs-params"><span class="hljs-function">            queue.try_pop(ret);</span></span><br><span class="hljs-params"><span class="hljs-function">            std::cout &lt;&lt; <span class="hljs-string">&quot;consumer2 get:&quot;</span> &lt;&lt; ret &lt;&lt; std::endl;</span></span><br><span class="hljs-params"><span class="hljs-function">            std::this_thread::sleep_for(std::chrono::milliseconds(<span class="hljs-number">500</span>));</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    consumer<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    consumer<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="异步并发"><a href="#异步并发" class="headerlink" title="异步并发"></a>异步并发</h2><h3 id="std-async"><a href="#std-async" class="headerlink" title="std::async"></a>std::async</h3><p>std::async使用异步的方式启动任务，从其返回值中获得<strong>std::future对象</strong>。默认情况下编译器会根据当前线程情况自动选择是否开启专属的线程执行任务。</p><p>不需要管理线程的生命周期。</p><p>可以指定第一个参数：std::lauch</p><p><strong>std::lauch::deferred</strong> 在当前线程上延后调用任务函数，直到遇到在futrue上get&#x2F;wait才会执行任务函数；</p><p><strong>std::lauch::async</strong>开启专属的线程，在新线程上运行任务函数；</p><p>默认情况下，使用std::lauch::deferred | std::lauch::async策略，由编译器选择执行情况</p><h3 id="std-future"><a href="#std-future" class="headerlink" title="std::future"></a>std::future</h3><p>调用get()时，当前线程会阻塞，以便future准备妥当并返回值或者异常。get()只能被调用一次，因为它会移动或者消耗掉std::future对象的状态；</p><p>wait()也是一个阻塞调用，wait()不会返回任务结果，它只是等待异步任务完成。如果任务完成，wait()会立即返回，如果任务没有完成wait()会阻塞当前线程，直到任务完成。wait()可以被调用多次。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find_the_answer_to_ltuae</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>;++i)&#123;<br>        ++a;<br>    &#125;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    std::future&lt;<span class="hljs-type">int</span>&gt; future_result = std::<span class="hljs-built_in">async</span>(std::launch::async, find_the_answer_to_ltuae);<br>    std::cout &lt;&lt; <span class="hljs-built_in">find_the_answer_to_ltuae</span>() &lt;&lt; std::endl;<br>    std::cout &lt;&lt; future_result.<span class="hljs-built_in">get</span>() &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><h3 id="std-packaged-task"><a href="#std-packaged-task" class="headerlink" title="std::packaged_task"></a>std::packaged_task</h3><p>连接<strong>future对象</strong>和<strong>可调用函数</strong>。</p><p>std::packaged_task是一个类模板，其模板参数是函数签名。例如：&lt;void()&gt; 代表了一个不接受参数和没有返回值的函数。</p><p>1、<code>std::package_task&lt;T&gt; task (func)</code>其中func是被包装的任务（函数），模板类型为函数的返回值；</p><p>2、通过<code>std::future&lt;T&gt; f = task.get_future()</code>获取与任务关联的future对象。</p><p>3、再通过<code>f.get()</code>来获取任务的返回值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find_the_answer_to_ltuae</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>;++i)&#123;<br>        ++a;<br>    &#125;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::packaged_task&lt;<span class="hljs-title">int</span><span class="hljs-params">()</span>&gt; <span class="hljs-title">task</span><span class="hljs-params">(find_the_answer_to_ltuae)</span></span>;<br>    <span class="hljs-keyword">auto</span> future_packged_result = task.<span class="hljs-built_in">get_future</span>();<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(std::move(task))</span></span>;<br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    std::cout &lt;&lt; future_packged_result.<span class="hljs-built_in">get</span>() &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="std-promise"><a href="#std-promise" class="headerlink" title="std::promise"></a>std::promise</h3><p><code>std::promise</code>用于在某一线程中设置某个值或异常，而<code>std::future</code>则用于在另一线程中获取这个值或异常。</p><p><code>set_value()</code>设置值，在主线程通过std::future::get()获取设置的值，如果值未设置，将阻塞。</p><p><code>set_exception()</code>设置异常, 设置的异常通过<code>std::current_exception()</code>获取。子线程设置的异常，主线程必须捕获这个设置的异常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_execption</span><span class="hljs-params">(std::promise&lt;<span class="hljs-type">void</span>&gt; pro)</span></span>&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;An error occured&quot;</span>);<br>    &#125;<span class="hljs-built_in">catch</span>(...)&#123;<br>        pro.<span class="hljs-built_in">set_exception</span>(std::<span class="hljs-built_in">current_exception</span>());<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 设置值</span><br>    std::promise&lt;std::string&gt; p;<br>    std::future&lt;std::string&gt; f = p.<span class="hljs-built_in">get_future</span>();<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">([](std::promise&lt;std::string&gt; p)</span></span><br><span class="hljs-params"><span class="hljs-function">                   &#123; p.set_value(<span class="hljs-string">&quot;hello world&quot;</span>); &#125;, std::move(p))</span></span>;<br>    std::cout &lt;&lt; f.<span class="hljs-built_in">get</span>() &lt;&lt; std::endl;<br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    <span class="hljs-comment">// 设置异常</span><br>    std::promise&lt;<span class="hljs-type">void</span>&gt; promiseException;<br>    std::future&lt;<span class="hljs-type">void</span>&gt; future = promiseException.<span class="hljs-built_in">get_future</span>();<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(set_execption, std::move(promiseException))</span></span>;<br>    <span class="hljs-comment">// 必须在主线程中捕获异常</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;waiting for set exception&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-comment">// future.get()会重新获取异常</span><br>        future.<span class="hljs-built_in">get</span>();<br>    &#125;<span class="hljs-built_in">catch</span>(<span class="hljs-type">const</span> std::exception&amp; e)&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;catch :&quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>    &#125;<br>    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="std-shared-future"><a href="#std-shared-future" class="headerlink" title="std::shared_future"></a>std::shared_future</h3><p>当多个线程需要等待同一个执行结果时，可以使用std::shared_future</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    std::promise&lt;<span class="hljs-type">int</span>&gt; promise;<br>    std::shared_future&lt;<span class="hljs-type">int</span>&gt; shared_f = promise.<span class="hljs-built_in">get_future</span>();<br>    <span class="hljs-comment">// 在t1线程内设置一个值为10</span><br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">([](std::promise&lt;<span class="hljs-type">int</span>&gt; &amp;&amp;p)&#123; </span></span><br><span class="hljs-params"><span class="hljs-function">        std::this_thread::sleep_for(std::chrono::seconds(<span class="hljs-number">2</span>));</span></span><br><span class="hljs-params"><span class="hljs-function">        p.set_value(<span class="hljs-number">10</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;, std::move(promise))</span></span>;<br>    <span class="hljs-comment">// 在t2线程内获取这个值，并加1</span><br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">([shared_f]()&#123; </span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">int</span> m = shared_f.get();</span></span><br><span class="hljs-params"><span class="hljs-function">        std::cout &lt;&lt; std::this_thread::get_id() &lt;&lt; <span class="hljs-string">&quot; num is&quot;</span> &lt;&lt; m + <span class="hljs-number">1</span> &lt;&lt; std::endl;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>; <br>    <span class="hljs-comment">// 在t3线程内获取这个值，并减去5</span><br>    <span class="hljs-function">std::thread <span class="hljs-title">t3</span><span class="hljs-params">([shared_f]()&#123; </span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">int</span> m = shared_f.get();</span></span><br><span class="hljs-params"><span class="hljs-function">        std::cout &lt;&lt; std::this_thread::get_id() &lt;&lt; <span class="hljs-string">&quot; num is&quot;</span> &lt;&lt; m - <span class="hljs-number">5</span> &lt;&lt; std::endl;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br>    t<span class="hljs-number">3.</span><span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="利用future进行函数式编程"><a href="#利用future进行函数式编程" class="headerlink" title="利用future进行函数式编程"></a>利用future进行函数式编程</h3><blockquote><p>函数式编程风格：把运算过程尽量写成一系列嵌套的函数调用。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::chrono;<br><br><span class="hljs-comment">// 函数式编程的快速排序</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">std::list&lt;T&gt; <span class="hljs-title">quick_sort</span><span class="hljs-params">(std::list&lt;T&gt; input)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(input.<span class="hljs-built_in">empty</span>())<br>        <span class="hljs-keyword">return</span> input;<br>    <span class="hljs-comment">// 定义结果列表</span><br>    std::list&lt;T&gt; result;<br>    result.<span class="hljs-built_in">splice</span>(result.<span class="hljs-built_in">begin</span>(), input, input.<span class="hljs-built_in">begin</span>());<br>    <span class="hljs-type">const</span> T &amp;pivot = *result.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-comment">// 将input划分为两列</span><br>    <span class="hljs-keyword">auto</span> divide_point = std::<span class="hljs-built_in">partition</span>(input.<span class="hljs-built_in">begin</span>(), input.<span class="hljs-built_in">end</span>(), [pivot](<span class="hljs-type">const</span> T &amp;it)<br>                                       &#123; <span class="hljs-keyword">return</span> it &lt; pivot; &#125;);<br>    std::list&lt;T&gt; lower_part;<br>    <span class="hljs-comment">// 将input的第一列取下，并插入到lower_part</span><br>    lower_part.<span class="hljs-built_in">splice</span>(lower_part.<span class="hljs-built_in">end</span>(), input, input.<span class="hljs-built_in">begin</span>(), divide_point);<br>    <span class="hljs-comment">// 递归调用，通过对象移动move转移对象的所有权，避免拷贝</span><br>    <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">new_lower</span><span class="hljs-params">(quick_sort(std::move(lower_part)))</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">new_higher</span><span class="hljs-params">(quick_sort(std::move(input)))</span></span>;<br>    result.<span class="hljs-built_in">splice</span>(result.<span class="hljs-built_in">begin</span>(), new_lower);<br>    result.<span class="hljs-built_in">splice</span>(result.<span class="hljs-built_in">end</span>(), new_higher);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// 并行的快速排序</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">std::list&lt;T&gt; <span class="hljs-title">parallel_quick_sort</span><span class="hljs-params">(std::list&lt;T&gt; input, <span class="hljs-type">int</span> depth = <span class="hljs-number">0</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (input.<span class="hljs-built_in">empty</span>())<br>        <span class="hljs-keyword">return</span> input;<br>    <span class="hljs-keyword">if</span> (depth &gt; <span class="hljs-number">5</span>)<br>    &#123; <span class="hljs-comment">// 控制递归深度以避免过多的线程开销</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_sort</span>(std::<span class="hljs-built_in">move</span>(input));<br>    &#125;<br>    std::list&lt;T&gt; result;<br>    result.<span class="hljs-built_in">splice</span>(result.<span class="hljs-built_in">begin</span>(), input, input.<span class="hljs-built_in">begin</span>());<br>    <span class="hljs-type">const</span> T &amp;pivot = *result.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-comment">// 根据哨兵划分两侧</span><br>    <span class="hljs-keyword">auto</span> divide_point = std::<span class="hljs-built_in">partition</span>(input.<span class="hljs-built_in">begin</span>(), input.<span class="hljs-built_in">end</span>(), [pivot](<span class="hljs-type">const</span> T &amp;it)<br>                                       &#123; <span class="hljs-keyword">return</span> it &lt; pivot; &#125;);<br>    <span class="hljs-comment">// 将前一侧放到lower_part</span><br>    std::list&lt;T&gt; lower_part;<br>    lower_part.<span class="hljs-built_in">splice</span>(lower_part.<span class="hljs-built_in">begin</span>(), input, input.<span class="hljs-built_in">begin</span>(), divide_point);<br>    <span class="hljs-comment">// 开启并发线程处理lower_part</span><br>    std::future&lt;std::list&lt;T&gt;&gt; <span class="hljs-built_in">new_lower</span>(std::<span class="hljs-built_in">async</span>(&amp;parallel_quick_sort&lt;T&gt;, std::<span class="hljs-built_in">move</span>(lower_part), depth + <span class="hljs-number">1</span>));<br>    <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">new_higher</span><span class="hljs-params">(parallel_quick_sort(std::move(input), depth + <span class="hljs-number">1</span>))</span></span>;<br>    result.<span class="hljs-built_in">splice</span>(result.<span class="hljs-built_in">end</span>(), new_higher);<br>    result.<span class="hljs-built_in">splice</span>(result.<span class="hljs-built_in">begin</span>(), new_lower.<span class="hljs-built_in">get</span>());<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::ifstream <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;random_numbers.txt&quot;</span>)</span></span>;<br>    std::list&lt;<span class="hljs-type">int</span>&gt; list&#123;&#125;;<br>    std::string line;<br>    <span class="hljs-keyword">while</span>(std::<span class="hljs-built_in">getline</span>(file, line))&#123;<br>        <span class="hljs-function">std::stringstream <span class="hljs-title">ss</span><span class="hljs-params">(line)</span></span>;<br>        std::string num;<br>        <span class="hljs-keyword">while</span>(std::<span class="hljs-built_in">getline</span>(ss, num, <span class="hljs-string">&#x27; &#x27;</span>))&#123;<br>            <span class="hljs-keyword">if</span>(!num.<span class="hljs-built_in">empty</span>())<br>                list.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">stoi</span>(num));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">auto</span> last = steady_clock::<span class="hljs-built_in">now</span>();<br>    <span class="hljs-keyword">auto</span> list2 = <span class="hljs-built_in">quick_sort</span>(list);<br>    <span class="hljs-keyword">auto</span> now = steady_clock::<span class="hljs-built_in">now</span>();<br>    std::cout &lt;&lt; <span class="hljs-built_in">duration_cast</span>&lt;microseconds&gt;((now - last)).<span class="hljs-built_in">count</span>() &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><h3 id="std-atomic-flag"><a href="#std-atomic-flag" class="headerlink" title="std::atomic_flag"></a>std::atomic_flag</h3><p>最简单的原子类型标准， 表示一个布尔标志。具有两种状态：成立或置零。</p><p>必须由宏<code>ATOMIC_FLAG_INIT</code>初始化</p><p><code>clear()</code>：销毁</p><p><code>test_and_set</code>：读取原有的值，并设置标志成立</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 实现自旋锁</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">spinlock_mutex</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">spinlock_mutex</span>():<span class="hljs-built_in">flag</span>(ATOMIC_FLAG_INIT)&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(flag.<span class="hljs-built_in">test_and_set</span>(std::memory_order_acquire));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123; flag.<span class="hljs-built_in">clear</span>(std::memory_order_release); &#125;<br><br>  <span class="hljs-keyword">private</span>:<br>    std::atomic_flag flag;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    spinlock_mutex spinlock;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">([&amp;spinlock]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        spinlock.lock();</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>;++i)&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            std::cout &lt;&lt; <span class="hljs-string">&quot;*&quot;</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">        spinlock.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">([&amp;spinlock]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        spinlock.lock();</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>;++i)&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            std::cout &lt;&lt; <span class="hljs-string">&quot;?&quot;</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">        spinlock.unlock();</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="std-atomic"><a href="#std-atomic" class="headerlink" title="std::atomic&lt;T&gt;"></a>std::atomic&lt;T&gt;</h3><p><code>is_lock_free()</code>判断类型操作能由原子指令直接实现。</p><p>支持<code>load()</code>和<code>store()</code>、<code>exchange()</code>、<code>compare_exchange_weak()</code>和<code>compare_exchange_strong()</code>等操作。</p><h3 id="内存次序"><a href="#内存次序" class="headerlink" title="内存次序"></a>内存次序</h3><p>对原子类型上的每一种操作，都可以提供额外的参数，从枚举类std::memory_order取值</p><p>包括<code>std::memory_order_relaxed</code>、<code>std:: memory_order_acquire</code>、<code>std::memory_order_consume</code>、<code>std::memory_order_acq_rel</code>、<code>std::memory_order_release</code>和 <code>std::memory_order_seq_cst</code>。</p><ul><li><p>存储（<code>store</code>）操作，可选用的内存次序有<code>std::memory_order_relaxed</code>、<code>std::memory_order_release</code>或<code>std::memory_order_seq_cst</code>。</p></li><li><p>载入（<code>load</code>）操作，可选用的内存次序有<code>std::memory_order_relaxed</code>、<code>std::memory_order_consume</code>、<code>std::memory_order_acquire</code>或<code>std::memory_order_seq_cst</code>。</p></li><li><p>“读-改-写”（<code>read-modify-write</code>）操作，可选用的内存次序有<code>std::memory_order_relaxed</code>、<code>std::memory_order_consume</code>、<code>std::memory_order_acquire</code>、<code>std::memory_order_release</code>、<code>std::memory_order_acq_rel</code>或<code>std::memory_order_seq_cst</code>。</p></li></ul><p>原子操作默认使用的是<code>std::memory_order_seq_cst</code>先后一致次序。</p><h2 id="设计并发的数据结构"><a href="#设计并发的数据结构" class="headerlink" title="设计并发的数据结构"></a>设计并发的数据结构</h2><h3 id="线程安全的并发栈"><a href="#线程安全的并发栈" class="headerlink" title="线程安全的并发栈"></a>线程安全的并发栈</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadSafeStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ThreadSafeStack</span>()&#123;&#125;<br>    <span class="hljs-built_in">ThreadSafeStack</span>(<span class="hljs-type">const</span> ThreadSafeStack &amp;t)&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(m_mtx)</span></span>;<br>        m_stack = t.m_stack;<br>    &#125;<br>    ThreadSafeStack &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> ThreadSafeStack &amp;) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;value)</span></span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(m_mtx)</span></span>;<br>        m_stack.<span class="hljs-built_in">push</span>(value);<br>        <span class="hljs-comment">// 有数据入栈就通知</span><br>        m_cv.<span class="hljs-built_in">notify_one</span>();<br>    &#125;<br>    <span class="hljs-comment">// wait版本的pop</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wait_and_pop</span><span class="hljs-params">(T &amp;value)</span></span>&#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(m_mtx)</span></span>;<br>        <span class="hljs-comment">// 如果栈不为空才允许pop，否则就等待</span><br>        cv.<span class="hljs-built_in">wait</span>(lock,[<span class="hljs-keyword">this</span>]()&#123;<br>            <span class="hljs-keyword">return</span> !m_stack.<span class="hljs-built_in">empty</span>();<br>        &#125;);<br>        <span class="hljs-comment">// 因为front()返回的是左值，赋值会调用拷贝赋值，转成右值，调用移动赋值</span><br>        value = std::<span class="hljs-built_in">move</span>(m_stack.<span class="hljs-built_in">front</span>());<br>        m_stack.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-comment">// 智能指针版本的返回</span><br>    <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">wait_and_pop</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(m_mtx)</span></span>;<br>        cv.<span class="hljs-built_in">wait</span>(lock, [<span class="hljs-keyword">this</span>]()&#123;<br>            <span class="hljs-keyword">return</span> !m_stack.<span class="hljs-built_in">empty</span>();<br>        &#125;);<br>        std::shared_ptr&lt;T&gt; res = std::<span class="hljs-built_in">make_shared</span>&lt;T&gt;(std::<span class="hljs-built_in">move</span>(m_stack.<span class="hljs-built_in">front</span>()));<br>        m_stack.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> <br>    &#125;<br>    <span class="hljs-comment">// try版本的pop</span><br>    <span class="hljs-type">bool</span> <span class="hljs-built_in">try_pop</span>(T &amp;value)&#123;<br>        std::lock_guard&lt;std::mutex&gt; <span class="hljs-built_in">lock</span>(m_mtx);<br>        <span class="hljs-keyword">if</span>(m_stack.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        value = std::<span class="hljs-built_in">move</span>(m_stack.<span class="hljs-built_in">front</span>());<br>        m_stack.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">try_pop</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(m_mtx)</span></span>;<br>        <span class="hljs-keyword">if</span>(m_stack.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">shared_ptr</span>&lt;T&gt;();<br>        std::shared_ptr&lt;T&gt; res = std::<span class="hljs-built_in">make_shared</span>&lt;T&gt;(std::<span class="hljs-built_in">move</span>(m_stack.<span class="hljs-built_in">front</span>()));<br>        m_stack.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(m)</span></span>;<br>        <span class="hljs-keyword">return</span> data.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>  <span class="hljs-keyword">private</span>:<br>    std::stack&lt;T&gt; m_stack;<br>    std::mutex m_mtx;<br>    std::condition_variable m_cv;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h3><p>单向链表可以充当队列的最简单的数据结构：</p><img src="C:\Users\haoks\AppData\Roaming\Typora\typora-user-images\image-20240620151604250.png" alt="image-20240620151604250" style="zoom: 15%;" /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadSafeQueue</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>        std::shared_ptr&lt;T&gt; data;<br>        std::unique_ptr&lt;node&gt; next;<br>    &#125;;<br>    <span class="hljs-function">node* <span class="hljs-title">get_tail</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(tail_mutex)</span></span>;<br>        <span class="hljs-keyword">return</span> tail;<br>    &#125;<br>    <span class="hljs-function">std::unique_ptr&lt;node&gt; <span class="hljs-title">pop_head</span><span class="hljs-params">()</span></span>&#123;<br>        std::unique_ptr&lt;node&gt; old_head = std::<span class="hljs-built_in">move</span>(head);<br>        head = std::<span class="hljs-built_in">move</span>(old_head-&gt;next);<br>        <span class="hljs-keyword">return</span> old_head;<br>    &#125;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">wait_for_data</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">head_lock</span><span class="hljs-params">(head_mutex)</span></span>;<br>        m_cv.<span class="hljs-built_in">wait</span>(head_lock, [&amp;]() &#123;<br>            <span class="hljs-keyword">return</span> head.<span class="hljs-built_in">get</span>()!= <span class="hljs-built_in">get_tail</span>();<br>        &#125;);<br>        <span class="hljs-keyword">return</span> head_lock;<br>    &#125;<br>    <span class="hljs-function">std::unique_ptr&lt;node&gt; <span class="hljs-title">wait_pop_head</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">head_lock</span><span class="hljs-params">(wait_for_data())</span></span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pop_head</span>();<br>    &#125;<br>    <span class="hljs-function">std::unique_ptr&lt;node&gt; <span class="hljs-title">wait_pop_head</span><span class="hljs-params">(T &amp;value)</span></span>&#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">head_lock</span><span class="hljs-params">(wait_for_data())</span></span>;<br>        value = std::<span class="hljs-built_in">move</span>(*head-&gt;data);<br>        <span class="hljs-keyword">return</span> pop_head;<br>    &#125;<br>    <span class="hljs-function">std::unique_lock&lt;node&gt; <span class="hljs-title">try_pop_head</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(head_mutex)</span></span>;<br>        <span class="hljs-keyword">if</span>(head.<span class="hljs-built_in">get</span>() == tail)&#123;<br>            <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">unique_lock</span>&lt;node&gt;();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pop_head</span>();<br>    &#125;<br>    <span class="hljs-function">std::unique_lock&lt;node&gt; <span class="hljs-title">try_pop_head</span><span class="hljs-params">(T &amp;value)</span></span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">head_lock</span><span class="hljs-params">(head_mutex)</span></span>;<br>        <span class="hljs-keyword">if</span>(head.<span class="hljs-built_in">get</span>() == tail)&#123;<br>            <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">unique_lock</span>&lt;node&gt;();<br>        &#125;<br>        value = std::<span class="hljs-built_in">move</span>(*head-&gt;data);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pop_head</span>();<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ThreadSafeQueue</span>(): <span class="hljs-built_in">head</span>(<span class="hljs-keyword">new</span> node), <span class="hljs-built_in">tail</span>(head.<span class="hljs-built_in">get</span>())&#123;&#125;<br>    <span class="hljs-built_in">ThreadSafeQueue</span>(<span class="hljs-type">const</span> ThreadSafeQueue &amp;) = <span class="hljs-keyword">delete</span>;<br>    ThreadSafeQueue &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> ThreadSafeQueue &amp;) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T new_value)</span></span>&#123;<br>        <span class="hljs-comment">// 构建指向数据的指针</span><br>        std::shared_ptr&lt;T&gt; new_ptr = std::<span class="hljs-built_in">make_shared</span>&lt;T&gt;(std::<span class="hljs-built_in">move</span>(new_value));<br>        <span class="hljs-comment">// 创建新的虚结点</span><br>        <span class="hljs-function">std::unique_ptr&lt;node&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> node)</span></span>;<br>        &#123;<br>            <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(tail_mutex)</span></span>;<br>            tail-&gt;data = new_ptr;<br>            node *new_tail = p.<span class="hljs-built_in">get</span>(); <br>            tail-&gt;next = std::<span class="hljs-built_in">move</span>(p);<br>            tail = new_tail;<br>        &#125;<br>        m_cv.<span class="hljs-built_in">notify_one</span>();<br>    &#125;<br><br>    <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">wait_and_pop</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-type">const</span> std::unique_ptr&lt;node&gt; old_head = <span class="hljs-built_in">wait_pop_head</span>();<br>        <span class="hljs-keyword">return</span> old_head-&gt;data;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wait_and_pop</span><span class="hljs-params">(T &amp;value)</span></span>&#123;<br>        <span class="hljs-type">const</span> std::unique_ptr&lt;node&gt; old_head = <span class="hljs-built_in">wait_and_pop</span>(value);<br>    &#125;<br>    <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">try_pop</span><span class="hljs-params">()</span></span>&#123;<br>        std::unique_ptr&lt;node&gt; old_head = <span class="hljs-built_in">try_pop_head</span>();<br>        <span class="hljs-keyword">return</span> old_head ? old_head-&gt;data : std::<span class="hljs-built_in">shared_ptr</span>&lt;T&gt;();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">try_pop</span><span class="hljs-params">(T &amp;value)</span></span>&#123;<br>        <span class="hljs-type">const</span> std::unique_lock&lt;node&gt; old_head = <span class="hljs-built_in">try_pop_head</span>(value);<br>        <span class="hljs-keyword">return</span> old_head != <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(head_mutex)</span></span>;<br>        <span class="hljs-keyword">return</span> (head.<span class="hljs-built_in">get</span>() == tail);<br>    &#125;<br>  <span class="hljs-keyword">private</span>:<br>    std::mutex head_mutex;<br>    std::mutex tail_mutex;<br>    std::unique_ptr&lt;node&gt; head;<br>    node *tail;<br>    std::condition_variable m_cv;<br>&#125;;<br>std::mutex read_mtx;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printInt</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string con, <span class="hljs-type">int</span> i)</span></span>&#123;<br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(read_mtx)</span></span>;<br>    std::cout &lt;&lt;con&lt;&lt;<span class="hljs-string">&quot; : &quot;</span>&lt;&lt; i &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br><br>    ThreadSafeQueue&lt;<span class="hljs-type">int</span>&gt; safe_que;<br>    <span class="hljs-function">std::thread <span class="hljs-title">consumer1</span><span class="hljs-params">([&amp;]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; data = safe_que.wait_and_pop();</span></span><br><span class="hljs-params"><span class="hljs-function">            printInt(<span class="hljs-string">&quot;consumer1&quot;</span>, *data);</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">consumer2</span><span class="hljs-params">([&amp;]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; data = safe_que.wait_and_pop();</span></span><br><span class="hljs-params"><span class="hljs-function">            printInt(<span class="hljs-string">&quot;consumer2&quot;</span>, *data);</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">producer</span><span class="hljs-params">([&amp;]() &#123; </span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>;++i)&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            safe_que.push(i);</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br>    consumer<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    consumer<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br>    producer.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="设计并发代码线程安全原则"><a href="#设计并发代码线程安全原则" class="headerlink" title="设计并发代码线程安全原则"></a>设计并发代码线程安全原则</h2><p>考虑一个操作是否是线程安全的，需要注意以下几个关键点：</p><h3 id="1-共享资源访问"><a href="#1-共享资源访问" class="headerlink" title="1. 共享资源访问"></a>1. 共享资源访问</h3><p>如果多个线程访问同一个资源（如变量、对象、文件、数据库等），且至少有一个线程在修改该资源，那么这个访问需要是线程安全的。</p><h3 id="2-原子性"><a href="#2-原子性" class="headerlink" title="2. 原子性"></a>2. 原子性</h3><p>确保操作是原子的，即不能被中断。一个操作要么完全执行，要么完全不执行。原子操作通常由硬件支持（如处理器的原子指令）或通过锁实现。</p><h3 id="3-可见性"><a href="#3-可见性" class="headerlink" title="3. 可见性"></a>3. 可见性</h3><p>确保一个线程对数据的修改对其他线程是可见的。这可以通过适当的内存屏障或同步机制来实现。缺乏可见性可能会导致一个线程看到旧的数据，而不是另一个线程刚刚写入的数据。</p><h3 id="4-有序性"><a href="#4-有序性" class="headerlink" title="4. 有序性"></a>4. 有序性</h3><p>确保操作按预期顺序执行。在多线程环境中，编译器和处理器可能会重新排序指令以优化性能，这可能导致线程间的非预期行为。同步机制可以强制执行正确的顺序。</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>1、task任务队列表示</p><p>2、封装回调函数</p><p>3、空闲时挂起，有任务后通知</p><p>线程池的局限性：</p><p>1、不适合具有顺序执行的任务；</p><p>2、任务之间强相关或者互斥性较强；</p><h3 id="简易的线程池模型"><a href="#简易的线程池模型" class="headerlink" title="简易的线程池模型"></a>简易的线程池模型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ThreadPool</span>(<span class="hljs-type">int</span> numThreads) : <span class="hljs-built_in">stop</span>(<span class="hljs-literal">false</span>)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numThreads; ++i)&#123;<br>            threads.<span class="hljs-built_in">emplace_back</span>([<span class="hljs-keyword">this</span>]&#123;<br>                <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>                    std::unique_lock&lt;std::mutex&gt; <span class="hljs-built_in">lock</span>(mtx);<br>                    <span class="hljs-comment">// 如果任务为或者stop为false就等待被唤醒</span><br>                    condition.<span class="hljs-built_in">wait</span>(lock, [<span class="hljs-keyword">this</span>]&#123; <span class="hljs-keyword">return</span> !tasks.<span class="hljs-built_in">empty</span>() || stop; &#125;);<br>                    <span class="hljs-keyword">if</span>(stop &amp;&amp; tasks.<span class="hljs-built_in">empty</span>())&#123;<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br>                    <span class="hljs-comment">// 取任务</span><br>                    std::function&lt;<span class="hljs-built_in">void</span>()&gt; <span class="hljs-built_in">task</span>(std::<span class="hljs-built_in">move</span>(tasks.<span class="hljs-built_in">front</span>()));<br>                    tasks.<span class="hljs-built_in">pop</span>();<br>                    <span class="hljs-comment">// 解锁</span><br>                    lock.<span class="hljs-built_in">unlock</span>();<br>                    <span class="hljs-comment">// 执行任务</span><br>                    <span class="hljs-built_in">task</span>();<br>                &#125; &#125;);<br>        &#125;<br>    &#125;<br>    ~<span class="hljs-built_in">ThreadPool</span>()&#123;<br>        &#123;<br>            <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>            stop = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 把任务队列任务取完</span><br>        condition.<span class="hljs-built_in">notify_all</span>();<br>        <span class="hljs-comment">// 等待任务完成</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;t : threads)&#123;<br>            t.<span class="hljs-built_in">join</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 添加任务</span><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">F</span>, <span class="hljs-keyword">class</span>... Args&gt;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(F &amp;&amp;f, Args &amp;&amp;...args)</span></span>&#123;<br>        std::function&lt;<span class="hljs-type">void</span>()&gt; task = std::<span class="hljs-built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...);<br>        <span class="hljs-comment">// 对tasks加锁</span><br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>;<br>        tasks.<span class="hljs-built_in">emplace</span>(std::<span class="hljs-built_in">move</span>(task));<br>        lock.<span class="hljs-built_in">unlock</span>();<br>        <span class="hljs-comment">// 通知</span><br>        condition.<span class="hljs-built_in">notify_one</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;std::thread&gt; threads;<br>    std::queue&lt;std::function&lt;<span class="hljs-type">void</span>()&gt;&gt; tasks;<br>    std::mutex mtx;<br>    std::condition_variable condition;<br>    <span class="hljs-type">bool</span> stop;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">ThreadPool <span class="hljs-title">pool</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i)&#123;<br>        pool.<span class="hljs-built_in">enqueue</span>([i]&#123; <br>            std::cout &lt;&lt; <span class="hljs-string">&quot;task : &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;is running&quot;</span> &lt;&lt; std::endl;<br>            std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;task : &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;is done&quot;</span> &lt;&lt; std::endl;<br>            &#125;);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线程池的单例模式实现"><a href="#线程池的单例模式实现" class="headerlink" title="线程池的单例模式实现"></a>线程池的单例模式实现</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">#include &lt;iostream&gt;</span><br><span class="hljs-comment">#include &lt;thread&gt;</span><br><span class="hljs-comment">#include &lt;queue&gt;</span><br><span class="hljs-comment">#include &lt;mutex&gt;</span><br><span class="hljs-comment">#include &lt;condition_variable&gt;</span><br><span class="hljs-comment">#include &lt;future&gt;</span><br><span class="hljs-comment">#include &lt;atomic&gt;</span><br><span class="hljs-comment">#include &lt;vector&gt;</span><br><span class="hljs-comment">#include &lt;functional&gt;</span><br><span class="hljs-comment">#include &lt;memory&gt;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPool</span> </span>&#123;<br>    using Task = std::<span class="hljs-variable constant_">packaged_task</span>&lt;<span class="hljs-keyword">void</span>()&gt;;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-title function_ invoke__">ThreadPool</span>(<span class="hljs-keyword">const</span> ThreadPool &amp;) = delete;<br>    ThreadPool &amp;operator=(ThreadPool &amp;) = delete;<br>    <span class="hljs-built_in">static</span> ThreadPool&amp; <span class="hljs-title function_ invoke__">GetInstance</span>()&#123;<br>        <span class="hljs-built_in">static</span> ThreadPool t;<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>    <span class="hljs-comment">// 向任务队列中添加任务</span><br>    template&lt;typename T, typename ...Args&gt;<br>    auto <span class="hljs-title function_ invoke__">commit</span>(T func, Args&amp;&amp; ...args) -&gt; std::<span class="hljs-variable constant_">future</span>&lt;<span class="hljs-title function_ invoke__">decltype</span>(<span class="hljs-title function_ invoke__">func</span>(args...))&gt;&#123;<br>        using ReturnType = <span class="hljs-title function_ invoke__">decltype</span>(<span class="hljs-title function_ invoke__">func</span>(args...));<br>        <span class="hljs-comment">// 判断线程池是否停止</span><br>        <span class="hljs-keyword">if</span>(m_stop.<span class="hljs-title function_ invoke__">load</span>())<br>            <span class="hljs-keyword">return</span> std::<span class="hljs-variable constant_">future</span>&lt;ReturnType&gt;();<br>        <span class="hljs-comment">// 创建一个任务</span><br>        auto task = std::<span class="hljs-variable constant_">make_shared</span>&lt;std::<span class="hljs-variable constant_">packaged_task</span>&lt;<span class="hljs-title function_ invoke__">ReturnType</span>()&gt;&gt;(<br>                        std::<span class="hljs-title function_ invoke__">bind</span>(std::<span class="hljs-variable constant_">forward</span>&lt;T&gt;(func), std::<span class="hljs-variable constant_">forward</span>&lt;Args&gt;(args)...));<br>        std::<span class="hljs-variable constant_">future</span>&lt;ReturnType&gt; ret = task-&gt;<span class="hljs-title function_ invoke__">get_future</span>();<br>        &#123;<br>            std::<span class="hljs-variable constant_">lock_guard</span>&lt;std::<span class="hljs-variable constant_">mutex</span>&gt; <span class="hljs-title function_ invoke__">lock</span>(m_mtx);<br>            m_tasks.<span class="hljs-title function_ invoke__">emplace</span>([task]&#123; <br>                (*task)(); <br>                &#125;);<br>        &#125;<br>        m_cv.<span class="hljs-title function_ invoke__">notify_one</span>();<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 单例模式下的初始构造函数必须是private</span><br>    <span class="hljs-title function_ invoke__">ThreadPool</span>(unsigned <span class="hljs-keyword">int</span> num = <span class="hljs-number">4</span>) : <span class="hljs-title function_ invoke__">m_stop</span>(<span class="hljs-literal">false</span>)&#123;<br>        <span class="hljs-comment">// 确定启动线程数</span><br>        <span class="hljs-keyword">if</span>(num &lt; <span class="hljs-number">1</span>)<br>            m_thread_num = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            m_thread_num = num;<br>        <span class="hljs-comment">// 初始化线程</span><br>        <span class="hljs-title function_ invoke__">init_thread</span>();<br>    &#125;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_ invoke__">init_thread</span>()&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m_thread_num;++i)&#123;<br>            m_thread_pool.<span class="hljs-title function_ invoke__">emplace_back</span>([this] &#123;<br>                <span class="hljs-keyword">while</span>(!this-&gt;m_stop.<span class="hljs-title function_ invoke__">load</span>())&#123;<br>                    Task task;<br>                    &#123;<br>                        std::<span class="hljs-variable constant_">unique_lock</span>&lt;std::<span class="hljs-variable constant_">mutex</span>&gt; <span class="hljs-title function_ invoke__">lock</span>(m_mtx);<br>                        <span class="hljs-comment">// 线程挂起，等待任务</span><br>                        <span class="hljs-comment">// std::cout &lt;&lt; &quot; thread is waiting: &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;</span><br>                        m_cv.<span class="hljs-title function_ invoke__">wait</span>(lock, [this]&#123; <br>                            // 唤醒时直到线程池结束，或者任务池中有任务取消挂起<br>                            <span class="hljs-keyword">return</span> m_stop.<span class="hljs-title function_ invoke__">load</span>() || !m_tasks.<span class="hljs-keyword">empty</span>(); <br>                        &#125;);<br>                        <span class="hljs-comment">// 再次判断任务队列是否为空，看是否是stop导致的唤醒</span><br>                        <span class="hljs-keyword">if</span>(m_tasks.<span class="hljs-keyword">empty</span>())&#123;<br>                            <span class="hljs-keyword">return</span>;<br>                        &#125;<br>                        <span class="hljs-comment">// 取出任务</span><br>                        task = std::<span class="hljs-title function_ invoke__">move</span>(m_tasks.<span class="hljs-title function_ invoke__">front</span>());<br>                        m_tasks.<span class="hljs-title function_ invoke__">pop</span>();<br>                    &#125;<br>                    <span class="hljs-comment">// 执行任务</span><br>                    --m_thread_num;<br>                    std::<span class="hljs-variable constant_">cout</span> &lt;&lt; <span class="hljs-string">&quot;thread &quot;</span> &lt;&lt; std::<span class="hljs-variable constant_">this_thread</span>::<span class="hljs-title function_ invoke__">get_id</span>() &lt;&lt; <span class="hljs-string">&quot;is getting task : &quot;</span> &lt;&lt; std::<span class="hljs-variable constant_">endl</span>;<br>                    <span class="hljs-title function_ invoke__">task</span>();<br>                    ++m_thread_num;<br>                &#125;<br>            &#125;);<br>        &#125;       <br>    &#125;<br>    ~<span class="hljs-title function_ invoke__">ThreadPool</span>()&#123;<br>        <span class="hljs-comment">// 不允许执行新的任务</span><br>        m_stop = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 等待正在执行的所有任务</span><br>        m_cv.<span class="hljs-title function_ invoke__">notify_all</span>();<br>        <span class="hljs-keyword">for</span> (auto &amp;it: m_thread_pool)&#123;<br>            <span class="hljs-keyword">if</span>(it.<span class="hljs-title function_ invoke__">joinable</span>())&#123;<br>                std::<span class="hljs-variable constant_">cout</span> &lt;&lt; <span class="hljs-string">&quot;join thread&quot;</span> &lt;&lt; it.<span class="hljs-title function_ invoke__">get_id</span>() &lt;&lt; std::<span class="hljs-variable constant_">endl</span>;<br>                it.<span class="hljs-title function_ invoke__">join</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    std::<span class="hljs-variable constant_">queue</span>&lt;std::<span class="hljs-variable constant_">packaged_task</span>&lt;<span class="hljs-keyword">void</span>()&gt;&gt; m_tasks;     <span class="hljs-comment">// 任务队列</span><br>    std::<span class="hljs-variable constant_">vector</span>&lt;std::<span class="hljs-variable constant_">thread</span>&gt; m_thread_pool;             <span class="hljs-comment">// 线程池</span><br>    std::<span class="hljs-variable constant_">mutex</span> m_mtx;                                   <span class="hljs-comment">// 队列锁</span><br>    std::<span class="hljs-variable constant_">condition_variable</span> m_cv;                       <span class="hljs-comment">// 通知线程池取任务条件变量</span><br>    std::<span class="hljs-variable constant_">atomic_bool</span> m_stop;                            <span class="hljs-comment">// 线程结束标志</span><br>    std::<span class="hljs-variable constant_">atomic_int</span> m_thread_num;<br>&#125;;<br><br><span class="hljs-keyword">int</span> <span class="hljs-title function_ invoke__">main</span>(<span class="hljs-keyword">int</span> argc, char <span class="hljs-keyword">const</span> *argv[])<br>&#123;<br>    <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;<br>    std::<span class="hljs-variable constant_">this_thread</span>::<span class="hljs-title function_ invoke__">sleep_for</span>(std::<span class="hljs-variable constant_">chrono</span>::<span class="hljs-title function_ invoke__">seconds</span>(<span class="hljs-number">2</span>));<br>    <span class="hljs-title class_">ThreadPool</span>::<span class="hljs-title function_ invoke__">GetInstance</span>().<span class="hljs-title function_ invoke__">commit</span>([](<span class="hljs-keyword">int</span> &amp;num)&#123; <br>        num = <span class="hljs-number">10</span>;<br>        std::<span class="hljs-variable constant_">cout</span> &lt;&lt; <span class="hljs-string">&quot;into thread num :&quot;</span> &lt;&lt; num &lt;&lt; std::<span class="hljs-variable constant_">endl</span>;<br><br>        &#125;, std::<span class="hljs-title function_ invoke__">ref</span>(num));<br>    std::<span class="hljs-variable constant_">this_thread</span>::<span class="hljs-title function_ invoke__">sleep_for</span>(std::<span class="hljs-variable constant_">chrono</span>::<span class="hljs-title function_ invoke__">seconds</span>(<span class="hljs-number">2</span>));<br>    std::<span class="hljs-variable constant_">cout</span> &lt;&lt; <span class="hljs-string">&quot;num is :&quot;</span> &lt;&lt; num &lt;&lt; std::<span class="hljs-variable constant_">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="一个异步日志"><a href="#一个异步日志" class="headerlink" title="一个异步日志"></a>一个异步日志</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;any&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">LogLevel</span> &#123;<br>    DEBUG = <span class="hljs-number">0</span>,<br>    INFO = <span class="hljs-number">1</span>,<br>    WARNING = <span class="hljs-number">2</span>,<br>    ERROR = <span class="hljs-number">3</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">currentTime</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">auto</span> now = std::chrono::system_clock::<span class="hljs-built_in">now</span>();<br>    std::<span class="hljs-type">time_t</span> <span class="hljs-type">now_time_t</span> = std::chrono::system_clock::<span class="hljs-built_in">to_time_t</span>(now);<br>    std::tm *now_tm = std::<span class="hljs-built_in">localtime</span>(&amp;<span class="hljs-type">now_time_t</span>);<br>    std::cout &lt;&lt; std::<span class="hljs-built_in">put_time</span>(now_tm, <span class="hljs-string">&quot;[%y-%m-%d %H:%M:%S]&quot;</span>);<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LogTask</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LogTask</span>()&#123;&#125;<br>    <span class="hljs-built_in">LogTask</span>(<span class="hljs-type">const</span> LogTask &amp;log)<br>        : <span class="hljs-built_in">m_level</span>(log.m_level), <span class="hljs-built_in">m_logData</span>(log.m_logData)&#123;&#125;;<br>    <span class="hljs-built_in">LogTask</span>(<span class="hljs-type">const</span> LogTask &amp;&amp;log)<br>        : <span class="hljs-built_in">m_level</span>(log.m_level), <span class="hljs-built_in">m_logData</span>(std::<span class="hljs-built_in">move</span>(log.m_logData))&#123;&#125;;<br><span class="hljs-keyword">public</span>:<br>    LogLevel m_level;   <span class="hljs-comment">// 记录日志等级c</span><br>    std::queue&lt;std::any&gt; m_logData; <span class="hljs-comment">// 日志数据</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncLogger</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">AsyncLogger</span>():<span class="hljs-built_in">m_stop</span>(<span class="hljs-literal">false</span>)&#123;<br>        m_logThread = std::<span class="hljs-built_in">thread</span>([<span class="hljs-keyword">this</span>] () &#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-comment">// 不断的从日志队列中取消息打印，如果没有消息就挂起</span><br>                std::unique_lock&lt;std::mutex&gt; <span class="hljs-built_in">lock</span>(m_mtx);<br>                m_cv.<span class="hljs-built_in">wait</span>(lock, [<span class="hljs-keyword">this</span>]() &#123;<br>                    <span class="hljs-keyword">return</span> !m_logQueue.<span class="hljs-built_in">empty</span>() || m_stop;<br>                &#125;);<br>                <span class="hljs-comment">// 停止就取消消息循环,同时也要保证消息队列为空</span><br>                <span class="hljs-keyword">if</span>(m_stop &amp;&amp; m_logQueue.<span class="hljs-built_in">empty</span>())<br>                    <span class="hljs-keyword">return</span>;<br>                <span class="hljs-comment">// 否则取消息</span><br>                <span class="hljs-keyword">auto</span> logMsg = m_logQueue.<span class="hljs-built_in">front</span>();<br>                m_logQueue.<span class="hljs-built_in">pop</span>();<br>                lock.<span class="hljs-built_in">unlock</span>();<br>                <span class="hljs-comment">// 打印消息</span><br>                <span class="hljs-built_in">printLogTask</span>(logMsg);<br>            &#125;<br>        &#125;);<br>    &#125;<br>    <span class="hljs-built_in">AsyncLogger</span>(<span class="hljs-type">const</span> AsyncLogger &amp;) = <span class="hljs-keyword">delete</span>;<br>    AsyncLogger &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> AsyncLogger &amp;) = <span class="hljs-keyword">delete</span>;<br>    ~<span class="hljs-built_in">AsyncLogger</span>()&#123;<br>        m_stop = <span class="hljs-literal">true</span>;<br>        m_cv.<span class="hljs-built_in">notify_all</span>();<br>        <span class="hljs-keyword">if</span>(m_logThread.<span class="hljs-built_in">joinable</span>())<br>            m_logThread.<span class="hljs-built_in">join</span>();<br>        <span class="hljs-built_in">currentTime</span>();<br>        std::cout &lt;&lt; <span class="hljs-string">&quot; Exit Logger Success!&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">// 打印日志函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printLogTask</span><span class="hljs-params">(std::shared_ptr&lt;LogTask&gt; logTaskPtr)</span></span>&#123;<br>        <span class="hljs-built_in">currentTime</span>();<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[&quot;</span> &lt;&lt; <span class="hljs-built_in">logLevelToString</span>(logTaskPtr-&gt;m_level) &lt;&lt; <span class="hljs-string">&quot;]&quot;</span>;<br>        <span class="hljs-comment">// 从logTask中的queue取消息打印</span><br>        <span class="hljs-keyword">while</span>(!logTaskPtr-&gt;m_logData.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-comment">// 将any转化为string类型</span><br>                std::cout&lt;&lt;<span class="hljs-built_in">convertToString</span>(logTaskPtr-&gt;m_logData.<span class="hljs-built_in">front</span>());<br>            &#125;<span class="hljs-built_in">catch</span>(<span class="hljs-type">const</span> std::bad_any_cast&amp;)&#123;<br>                <span class="hljs-comment">// 处理不能转化的变量类型异常</span><br>                std::cout &lt;&lt; <span class="hljs-string">&quot;(Invalid Log Data Type)&quot;</span>;<br>            &#125;<br>            logTaskPtr-&gt;m_logData.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        std::cout &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-comment">// 转换any类型数据</span><br>    <span class="hljs-function">std::string <span class="hljs-title">convertToString</span><span class="hljs-params">(<span class="hljs-type">const</span> std::any &amp;data)</span></span>&#123;<br>        <span class="hljs-comment">// 只处理三种类型, 其余情况抛出异常</span><br>        std::ostringstream oss;<br>        <span class="hljs-keyword">if</span>(data.<span class="hljs-built_in">type</span>() == <span class="hljs-built_in">typeid</span>(<span class="hljs-type">int</span>))<br>            oss &lt;&lt; std::<span class="hljs-built_in">any_cast</span>&lt;<span class="hljs-type">int</span>&gt;(data);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data.<span class="hljs-built_in">type</span>() == <span class="hljs-built_in">typeid</span>(std::string))<br>            oss &lt;&lt; std::<span class="hljs-built_in">any_cast</span>&lt;std::string&gt;(data);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data.<span class="hljs-built_in">type</span>() == <span class="hljs-built_in">typeid</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*))<br>            oss &lt;&lt; std::<span class="hljs-built_in">any_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span> *&gt;(data);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">bad_any_cast</span>();<br>        <span class="hljs-keyword">return</span> oss.<span class="hljs-built_in">str</span>();<br>    &#125;<br>    <span class="hljs-comment">// 日志等级到字符串映射</span><br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">logLevelToString</span><span class="hljs-params">(LogLevel level)</span></span>&#123;<br>        <span class="hljs-keyword">switch</span>(level)&#123;<br>            <span class="hljs-keyword">case</span> DEBUG:<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;DEBUG&quot;</span>;<br>            <span class="hljs-keyword">case</span> INFO:<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;INFO&quot;</span>;<br>            <span class="hljs-keyword">case</span> WARNING:<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;WARNING&quot;</span>;<br>            <span class="hljs-keyword">case</span> ERROR:<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ERROR&quot;</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;UNKNOW TYPE&quot;</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 单例模式</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> AsyncLogger&amp; <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-type">static</span> AsyncLogger log;<br>        <span class="hljs-keyword">return</span> log;<br>    &#125;<br>    <span class="hljs-comment">// 写异步日志</span><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function">    <span class="hljs-type">void</span> <span class="hljs-title">AsyncWrite</span><span class="hljs-params">(LogLevel logLevel, Args&amp;&amp;... args)</span></span>&#123;<br>        std::shared_ptr&lt;LogTask&gt; task = std::<span class="hljs-built_in">make_shared</span>&lt;LogTask&gt;();<br>        task-&gt;m_level = logLevel;<br>        <span class="hljs-comment">// 利用折叠表达式将消息入队</span><br>        (task-&gt;m_logData.<span class="hljs-built_in">push</span>(args), ...);<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(m_mtx)</span></span>;<br>        <span class="hljs-type">bool</span> notify = m_logQueue.<span class="hljs-built_in">empty</span>();<br>        m_logQueue.<span class="hljs-built_in">push</span>(task);<br>        <span class="hljs-comment">// 判断是否是第一个消息</span><br>        lock.<span class="hljs-built_in">unlock</span>();<br>        <span class="hljs-keyword">if</span>(notify)&#123;<br>            m_cv.<span class="hljs-built_in">notify_one</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 写日志的特化版本</span><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function">    <span class="hljs-type">void</span> <span class="hljs-title">AsyncWriteInfo</span><span class="hljs-params">(Args&amp;&amp;...args)</span></span>&#123;<br>        <span class="hljs-built_in">AsyncWrite</span>(INFO, std::forward&lt;Args&gt;(args)...);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function">    <span class="hljs-type">void</span> <span class="hljs-title">AsyncWriteError</span><span class="hljs-params">(Args&amp;&amp;...args)</span></span>&#123;<br>        <span class="hljs-built_in">AsyncWrite</span>(ERROR, std::forward&lt;Args&gt;(args)...);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function">    <span class="hljs-type">void</span> <span class="hljs-title">AsyncWriteDebug</span><span class="hljs-params">(Args&amp;&amp;...args)</span></span>&#123;<br>        <span class="hljs-built_in">AsyncWrite</span>(DEBUG, std::forward&lt;Args&gt;(args)...);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function">    <span class="hljs-type">void</span> <span class="hljs-title">AsyncWriteWarning</span><span class="hljs-params">(Args&amp;&amp;...args)</span></span>&#123;<br>        <span class="hljs-built_in">AsyncWrite</span>(WARNING, std::forward&lt;Args&gt;(args)...);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>  std::queue&lt;std::shared_ptr&lt;LogTask&gt;&gt; m_logQueue;  <span class="hljs-comment">// 日志队列</span><br>  std::condition_variable m_cv; <br>  std::mutex m_mtx; <span class="hljs-comment">// 互斥访问日志队列</span><br>  <span class="hljs-type">bool</span> m_stop; <span class="hljs-comment">// 停止</span><br>  std::thread m_logThread; <span class="hljs-comment">// 日志工作线程</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func_error</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ;i&lt;<span class="hljs-number">100</span>;++i)&#123;<br>        AsyncLogger::<span class="hljs-built_in">GetInstance</span>().<span class="hljs-built_in">AsyncWriteError</span>(i);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func_info</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;++i)&#123;<br>        AsyncLogger::<span class="hljs-built_in">GetInstance</span>().<span class="hljs-built_in">AsyncWriteInfo</span>(i);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    AsyncLogger::<span class="hljs-built_in">GetInstance</span>().<span class="hljs-built_in">AsyncWrite</span>(LogLevel::INFO,  <span class="hljs-number">3.12</span>, <span class="hljs-string">&quot;HELLO&quot;</span>, <span class="hljs-number">321</span>);<br>    AsyncLogger::<span class="hljs-built_in">GetInstance</span>().<span class="hljs-built_in">AsyncWrite</span>(LogLevel::ERROR, <span class="hljs-string">&quot;INPUT ERROR&quot;</span>);<br>    AsyncLogger::<span class="hljs-built_in">GetInstance</span>().<span class="hljs-built_in">AsyncWriteError</span>(<span class="hljs-string">&quot;haha this is a error&quot;</span>, <span class="hljs-number">132.123</span>);<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(func_error)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(func_info)</span></span>;<br>    t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br>    t<span class="hljs-number">2.</span><span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
