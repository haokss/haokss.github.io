

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="《总之，好记性不如烂笔头！把你遗忘的都记下来吧！》 Effective C++ 改善程序和设计的55个具体做法01：视C++为一个语言联邦 C。C++以C为基础； Object-Oriented C++。包括类、封装、继承、多态、动态绑定等； Template C++。 C++泛型编程的基础； STL库。包括容器、算法、迭代器、配置器、仿函数；  02：尽量以const，enum，inline替代">
<meta property="og:type" content="article">
<meta property="og:title" content="Effective C++">
<meta property="og:url" content="http://example.com/2024/07/31/Effective/index.html">
<meta property="og:site_name" content="haoks">
<meta property="og:description" content="《总之，好记性不如烂笔头！把你遗忘的都记下来吧！》 Effective C++ 改善程序和设计的55个具体做法01：视C++为一个语言联邦 C。C++以C为基础； Object-Oriented C++。包括类、封装、继承、多态、动态绑定等； Template C++。 C++泛型编程的基础； STL库。包括容器、算法、迭代器、配置器、仿函数；  02：尽量以const，enum，inline替代">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-07-31T13:03:27.000Z">
<meta property="article:modified_time" content="2024-07-31T13:11:06.741Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>Effective C++ - haoks</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":["home"]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"#"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":"lRNjMHJuYBjEDxG7qZ3nMGPi-gzGzoHsz","app_key":"SAOxud4u65tFtKVuwrFrHaQN","server_url":"https://lrnjmhju.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>haoks</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">Effective C++</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-07-31 21:03" pubdate>
          2024年7月31日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          6.3k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          53 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Effective C++</h1>
            
            
              <div class="markdown-body">
                
                <p><strong>《总之，好记性不如烂笔头！把你遗忘的都记下来吧！》</strong></p>
<h1 id="Effective-C-改善程序和设计的55个具体做法"><a href="#Effective-C-改善程序和设计的55个具体做法" class="headerlink" title="Effective C++ 改善程序和设计的55个具体做法"></a>Effective C++ 改善程序和设计的55个具体做法</h1><h2 id="01：视C-为一个语言联邦"><a href="#01：视C-为一个语言联邦" class="headerlink" title="01：视C++为一个语言联邦"></a>01：视C++为一个语言联邦</h2><ul>
<li>C。C++以C为基础；</li>
<li>Object-Oriented C++。包括类、封装、继承、多态、动态绑定等；</li>
<li>Template C++。 C++泛型编程的基础；</li>
<li>STL库。包括容器、算法、迭代器、配置器、仿函数；</li>
</ul>
<h2 id="02：尽量以const，enum，inline替代-define"><a href="#02：尽量以const，enum，inline替代-define" class="headerlink" title="02：尽量以const，enum，inline替代#define"></a>02：尽量以const，enum，inline替代#define</h2><h3 id="1、使用const-enum替换-define"><a href="#1、使用const-enum替换-define" class="headerlink" title="1、使用const&#x2F;enum替换#define"></a>1、使用const&#x2F;enum替换#define</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ASPECT_RATIO 1.653</span><br></code></pre></td></tr></table></figure>

<p>ASPECT_RATIO不能被编译器所看到，导致错误信息可能只是数字。</p>
<p>使用常量来替换宏：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">double</span> ASPECTRATIO = <span class="hljs-number">1.653</span><br></code></pre></td></tr></table></figure>

<p>使用常量来替换宏的两种特殊情况：</p>
<p>第一：<strong>定义常量指针</strong></p>
<p>由于常量定义式常放在头文件内，有必要将指针声明为const。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> authorName = <span class="hljs-string">&quot;Scott Meyers&quot;</span>;<br></code></pre></td></tr></table></figure>

<p>第二：<strong>类的静态常量</strong></p>
<p>为了将常量的作用域限制在类中，必须声明为类的成员</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GamePlayer</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 在类内声明和初始化，是编译时常量，没有内存地址</span><br>	<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> NumTurns = <span class="hljs-number">5</span>;  <span class="hljs-comment">// 常量的声明式并初始化（C++11）</span><br>	<span class="hljs-type">int</span> scores[NumTurns]; <span class="hljs-comment">// 使用常量</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>只要不取地址就可以声明并使用它们而无须提供定义，但是要取类静态常量的地址，就必须提供定义式！</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> GamePlayer::NumTurns; <span class="hljs-comment">//定义式，由于声明已经获得初值，定义可以不设置初值</span><br></code></pre></td></tr></table></figure>

<p>顺便的#define在类内不提供任何封装性。</p>
<p>如果不支持静态常量类内初始化，将初值放在定义式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CostEstimate</span>&#123;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">double</span> FudgeFactor;<span class="hljs-comment">// 类内声明</span><br>&#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> CostEstimate::FudgeFactor = <span class="hljs-number">1.35</span>; <span class="hljs-comment">// 静态常量类外定义并初始化 </span><br></code></pre></td></tr></table></figure>

<p>但是这样做不能在类内使用这个常量，可以使用“ the enum hack”的补偿做法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GamePlayer</span>&#123;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-keyword">enum</span> &#123; NumTurns = <span class="hljs-number">5</span> &#125;;<br>	<span class="hljs-type">int</span> scores[NumTurns];<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="2、改写-define形似函数的宏"><a href="#2、改写-define形似函数的宏" class="headerlink" title="2、改写#define形似函数的宏"></a>2、改写#define形似函数的宏</h3><p>对于像是这样的形似函数的宏：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CALL_WITH_MAX(a, b) f((a) &gt; (b) ? (a) : (b))</span><br></code></pre></td></tr></table></figure>

<p>使用这样的宏，必须为宏上的所有实参加上括号。</p>
<p>应该使用<strong>template inline</strong>来替代这样的宏，它具有和宏一般的效率，且更加安全</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">callWithMax</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; a, <span class="hljs-type">const</span> T&amp;b)</span></span>&#123;<br>	<span class="hljs-built_in">f</span>(a &gt; b ? a : b);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="03：尽可能的使用const"><a href="#03：尽可能的使用const" class="headerlink" title="03：尽可能的使用const"></a>03：尽可能的使用const</h2><p>const可以和函数返回值、参数、函数自身产生关联。</p>
<h3 id="const作用于函数返回值："><a href="#const作用于函数返回值：" class="headerlink" title="const作用于函数返回值："></a><strong>const作用于函数返回值：</strong></h3><p>令函数返回一个常量值，可以降低因错误而产生的意外。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span>&#123; ... &#125;;<br><span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>* (<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs);<br><span class="hljs-comment">// 返回const对象可以防止下面的错误</span><br>Rational a, b, c;<br>(a * b) = c;<br><span class="hljs-comment">// 从而产生像是</span><br><span class="hljs-keyword">if</span>( a * b = c) <span class="hljs-comment">// 因为错误写==而导致的逻辑错误</span><br></code></pre></td></tr></table></figure>

<h3 id="const参数："><a href="#const参数：" class="headerlink" title="const参数："></a><strong>const参数：</strong></h3><p>对于在函数中不改变的参数，应当将它们声明为const的。</p>
<h3 id="const成员函数："><a href="#const成员函数：" class="headerlink" title="const成员函数："></a><strong>const成员函数：</strong></h3><p>将const作于成员函数是为了const对象能够使用这个成员函数，存在两方面：1、使得接口容易被理解，因为可以很容易看出这个接口不改变对象内容；2、能够被const对象使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextBlock</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TextBlock</span>(std::string txt):<span class="hljs-built_in">text</span>(txt)&#123;&#125;;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-type">size_t</span> position) <span class="hljs-type">const</span>&#123;  <span class="hljs-comment">// 使用常成员函数重载的[]</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;this is use the const&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> text[position];<br>    &#125;<br>    <span class="hljs-type">char</span> &amp;<span class="hljs-keyword">operator</span>[](std::<span class="hljs-type">size_t</span> position)&#123;	<span class="hljs-comment">// 使用普通成员函数重载的[]</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;this is use the non-const&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> text[position];<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>  std::string text;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> <span class="hljs-type">const</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">TextBlock <span class="hljs-title">tb</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>)</span></span>;<br>    std::cout &lt;&lt; tb[<span class="hljs-number">0</span>]&lt;&lt;std::endl;<br>    <span class="hljs-function">TextBlock <span class="hljs-title">ctb</span><span class="hljs-params">(<span class="hljs-string">&quot;haha&quot;</span>)</span></span>;<br>    std::cout &lt;&lt; ctb[<span class="hljs-number">1</span>]&lt;&lt;std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>const成员函数的bitwise constness 和 logical constness</strong></p>
<p>bitwise const：成员函数只有在不改变对象内的任何成员变量时才可以说是const的。一个更改了”指针所指向之物“的成员函数仍算数bitwise const，不会引发编译异常。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CTextBlock</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// bitwise const声明，在函数内并不修改成员变量</span><br>    <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-type">size_t</span> position)<span class="hljs-type">const</span>&#123;<br>        <span class="hljs-keyword">return</span> pText[position];<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">char</span> *pText; <span class="hljs-comment">// 文本长度，可能是随时变化的， 如果变换文本记录长度失效</span><br>&#125;;<br><span class="hljs-comment">// 但是利用返回的引用，仍可能修改成员变量</span><br><span class="hljs-function"><span class="hljs-type">const</span> CTextBlock <span class="hljs-title">cctb</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello&quot;</span>)</span></span>;<br><span class="hljs-type">char</span> *pc = &amp;cctb[<span class="hljs-number">0</span>];<br>*pc = <span class="hljs-string">&#x27;J&#x27;</span>; <span class="hljs-comment">// 将&#x27;H&#x27;修改为了&#x27;J&#x27;</span><br></code></pre></td></tr></table></figure>

<p>logical const:  一个const成员函数可以修改它所处理的的对象的某些bits，但是只有在客户端侦测不出的情况下。</p>
<p>为了确保能够在const成员函数中修改成员变量，需要将需要修改的成员变量声明为<strong>mutable</strong>的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CTextBlock</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(!lengthIsValid)&#123;<br>        <span class="hljs-comment">// 即使是在const成员函数中也能修改，因为其被定义为mutable的了</span><br>        textLength = std::<span class="hljs-built_in">strlen</span>(pText);<br>        lengthIsValid = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> textLength;<br>  &#125;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">char</span> *pText; <span class="hljs-comment">// 文本长度，可能是随时变化的， 如果变换文本记录长度失效</span><br>  <span class="hljs-keyword">mutable</span> std::<span class="hljs-type">size_t</span> textLength; <span class="hljs-comment">// 记录当前的文本长度</span><br>  <span class="hljs-keyword">mutable</span> <span class="hljs-type">bool</span> lengthIsValid;   <span class="hljs-comment">// 当前文本长度是否失效</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>避免const和non-const成员函数的重复：</strong></p>
<p>运用const成员函数来实现出其non-const成员函数的方法。因为在non-const中对象可能被改动，因此使用const成员函数调用non-const成员函数是一种错误的行为。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CTextBlock2</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-type">size_t</span> position)<span class="hljs-type">const</span>&#123;<br>        <span class="hljs-comment">// ......</span><br>        <span class="hljs-comment">// ......</span><br>        <span class="hljs-comment">// 很长的代码</span><br>        <span class="hljs-keyword">return</span> pText[position]; <br>    &#125;<br>    <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-type">size_t</span> position) &#123;<br>        <span class="hljs-comment">// 转调用const版本的operator[]</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span> &amp;&gt;(	<span class="hljs-comment">// 利用const_cast&lt;&gt;()去除返回值的const性质</span><br>            <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> TextBlock &amp;&gt;(*<span class="hljs-keyword">this</span>)[position]);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">char</span> *pText; <br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="04：确定对象使用前已先被初始化"><a href="#04：确定对象使用前已先被初始化" class="headerlink" title="04：确定对象使用前已先被初始化"></a>04：确定对象使用前已先被初始化</h2><h3 id="使用内置型对象进行手工初始化"><a href="#使用内置型对象进行手工初始化" class="headerlink" title="使用内置型对象进行手工初始化"></a>使用内置型对象进行手工初始化</h3><p>因为C++不保证初始化它们，读取未初始化的值会导致不明确的行为。</p>
<h3 id="使用初始化成员列表"><a href="#使用初始化成员列表" class="headerlink" title="使用初始化成员列表"></a>使用<strong>初始化成员列表</strong></h3><p><strong>不要混淆赋值和初始化</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ABEntry::<span class="hljs-built_in">ABEntry</span>(<span class="hljs-type">const</span> std;:string &amp;name)&#123;<br>    <span class="hljs-comment">// 赋值操作</span><br>	theName = name;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对象的初始化在进入构造函数本体之前，在构造函数内不是初始化而是赋值。</p>
<p>改用初始化能够减少一次赋值动作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">ABEntry::<span class="hljs-built_in">ABEntry</span>(<span class="hljs-type">const</span> std;:string &amp;name):<span class="hljs-built_in">theName</span>(name)<br>&#123;&#125;<br></code></pre></td></tr></table></figure>

<p>规定总是在初值列中列出所有成员变量，C++有十分固定的成员初始化次序，基类早于继承类初始化，成员变量总是按照生命次序被初始化。在初始化成员列表中，最好以声明次序列出各个成员。</p>
<h3 id="不同编译单元（不同文件）的non-local-static对象的初始化次序"><a href="#不同编译单元（不同文件）的non-local-static对象的初始化次序" class="headerlink" title="不同编译单元（不同文件）的non-local static对象的初始化次序"></a><strong>不同编译单元（不同文件）的non-local static对象的初始化次序</strong></h3><blockquote>
<p>函数内的static对象成为local static对象，其它static对象称为non-local static对象</p>
</blockquote>
<p>由于C++对于不同编译单元内的non-local static对象的初始化次序没有明确定义，导致一个编译单元的non-local static对象使用另一个编译单元的non-local static对象可能未初始化。</p>
<p>解决方法：</p>
<p>将non-local static对象搬到自己的专属函数中使之变为local static，在函数内部被声明为static，函数返回一个reference指向它所含的对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileSystem</span> &#123; ... &#125;;<br><span class="hljs-function">FileSystem&amp; <span class="hljs-title">tfs</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-type">static</span> FileSystem fs;<br>	<span class="hljs-keyword">return</span> fs;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="05：了解C-默默编写并调用哪些函数"><a href="#05：了解C-默默编写并调用哪些函数" class="headerlink" title="05：了解C++默默编写并调用哪些函数"></a>05：了解C++默默编写并调用哪些函数</h2><p>对于一个类如果没有声明，编译器就会自动生成一个<strong>copy构造函数</strong>，一个<strong>copy赋值运算符</strong>和一个<strong>析构函数</strong>，如果没有声明默认构造函数，同时也会生成一个默认构造函数。所有这些函数都是<strong>public</strong>且<strong>inline</strong>的。</p>
<p>**对于内含引用、const类型的成员变量，编译器会拒绝为class生成operator&#x3D;**。</p>
<p>如果一个基类将拷贝赋值运算符声明为private，那么编译器会拒绝为派生类生成拷贝赋值运算符。</p>
<h2 id="06：若不想使用编译器自动生成的函数，就应该明确拒绝"><a href="#06：若不想使用编译器自动生成的函数，就应该明确拒绝" class="headerlink" title="06：若不想使用编译器自动生成的函数，就应该明确拒绝"></a>06：若不想使用编译器自动生成的函数，就应该明确拒绝</h2><p>1、声明一个具有private类型的拷贝赋值运算符作为基类，并继承；</p>
<p>2、使用&#x3D;delete直接删除；</p>
<h2 id="07：为多态基类声明virtual析构函数"><a href="#07：为多态基类声明virtual析构函数" class="headerlink" title="07：为多态基类声明virtual析构函数"></a>07：为多态基类声明virtual析构函数</h2><p>使用factory工厂方法，返回一个基类指针，指向新生成的继承类对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 工厂方法的简化定义</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">Product</span>()&#123;&#125;  <span class="hljs-comment">// 正确的定义：virtual ~Product()&#123;&#125;</span><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteProduct1</span> : <span class="hljs-keyword">public</span> Product&#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteProduct2</span> : <span class="hljs-keyword">public</span> Product&#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Creator</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">Creator</span>()&#123;&#125;  <span class="hljs-comment">// 正确的定义：virtual ~Creator()&#123;&#125;</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Product *<span class="hljs-title">FactoryMethod</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SomeOperation</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>        <span class="hljs-comment">// 在此处返回一个基类指针指向了派生类</span><br>        Product *product = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">FactoryMethod</span>();<br>		<span class="hljs-comment">// 未定义！释放基类指针，避免资源泄漏</span><br>        <span class="hljs-keyword">delete</span> product;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteCreator1</span> : <span class="hljs-keyword">public</span> Creator&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">Product *<span class="hljs-title">FactoryMethod</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreteProduct1</span>(); &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteCreator2</span> : <span class="hljs-keyword">public</span> Creator&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">Product *<span class="hljs-title">FactoryMethod</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreteProduct2</span>(); &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>C++指出，当继承对象经由一个基类指针被删除，而基类指针带有一个<strong>non-virtual析构函数</strong>其结果是<strong>未定义</strong>的。产生的结果是基类部分被析构，而派生类的部分没有被析构，导致资源泄露，破坏数据结构。</p>
<p><strong>任何类中只要带有virtual函数几乎确定也应该有一个virtual析构函数。</strong>反之亦然。</p>
<p>声明一个带纯虚析构函数的抽象类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 抽象类，不能实例化对象</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AMOV</span>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-comment">// 声明为纯虚析构函数</span><br>	<span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">AWOV</span>() = <span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-comment">// 必须为纯虚析构函数提供一份定义</span><br>AMOV::~<span class="hljs-built_in">AMOV</span>()&#123; &#125;<br></code></pre></td></tr></table></figure>

<p>析构函数从最深层的派生类开始调用其析构函数，然后每一个基类的析构函数被调用。编译器会在AMOV的继承类的析构函数中创建一个对~AMOV的调用动作，因此必须为这个函数提供一份定义。</p>
<h2 id="08：别让异常逃离析构函数"><a href="#08：别让异常逃离析构函数" class="headerlink" title="08：别让异常逃离析构函数"></a>08：别让异常逃离析构函数</h2><p>在析构函数中必须执行一个动作，但该动作会在失败时抛出异常。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DBConn</span>&#123;<br><span class="hljs-keyword">public</span>:<br>	...<br>    ~<span class="hljs-built_in">DBConn</span>()&#123;<br>        <span class="hljs-comment">// 确保数据库连接总是会关闭，但是会抛出异常</span><br>    	db.<span class="hljs-built_in">close</span>();<br>    &#125;<br> <span class="hljs-keyword">private</span>:<br> 	DBConnection db;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>如果调用导致异常，析构函数将传播异常，允许其离开这个析构函数。</p>
<p>解决方法：</p>
<p>1、通过调用abort终止</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">DBConn::~<span class="hljs-built_in">DBConn</span>()&#123;<br>	<span class="hljs-keyword">try</span> &#123; db.<span class="hljs-built_in">close</span>();&#125;<br>	<span class="hljs-built_in">catch</span>(...)&#123;<br>		std::<span class="hljs-built_in">abort</span>();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个方法将导致程序被强迫结束。</p>
<p>2、记录close的失败调用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">DBConn::~<span class="hljs-built_in">DBConn</span>()&#123;<br>	<span class="hljs-keyword">try</span> &#123; db.<span class="hljs-built_in">close</span>();&#125;<br>	<span class="hljs-built_in">catch</span>(...)&#123;<br>		记录失败调用。<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>3、 在新接口中操作，将责任从析构函数中转移</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DBConn</span>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span>&#123;<br>		db.<span class="hljs-built_in">close</span>();<br>		closed = <span class="hljs-literal">true</span>;<br>	&#125;<br>    ~<span class="hljs-built_in">DBConn</span>()&#123;<br>    	<span class="hljs-keyword">if</span>(!<span class="hljs-built_in">closed</span>())&#123;<br>    		<span class="hljs-keyword">try</span>&#123;<br>    			db.<span class="hljs-built_in">close</span>();<br>    		&#125;<span class="hljs-built_in">catch</span>(...)&#123;<br>    			记录close失败调用。<br>    		&#125;<br>    	&#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>将close责任从析构函数中转移到DBConn的用户手中。</p>
<p><strong>如果某个操作可能在失败时抛出异常，而又必须处理该异常，这个异常必须来自析构函数之外</strong>，析构函数抛出异常会带来”过早结束程序“和”不明确行为“的风险。</p>
<h2 id="09：绝不在析构和构造函数过程中调用virtual函数"><a href="#09：绝不在析构和构造函数过程中调用virtual函数" class="headerlink" title="09：绝不在析构和构造函数过程中调用virtual函数"></a>09：绝不在析构和构造函数过程中调用virtual函数</h2><h2 id="10：令operator-返回一个reference-to-this"><a href="#10：令operator-返回一个reference-to-this" class="headerlink" title="10：令operator&#x3D;返回一个reference to *this"></a>10：令operator&#x3D;返回一个reference to *this</h2><p>为类实现赋值操作符时应该遵守的协议：赋值操作符必须返回一个reference指向操作符的左侧实参（左值）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>&#123;<br><span class="hljs-keyword">public</span>:<br>	...<br>	Widget&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)&#123;<br>		...<br>		<span class="hljs-comment">// 返回左侧对象</span><br>		<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>	&#125;<br>	<span class="hljs-comment">// 对其他符号也适用</span><br>	Widget&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> Widget&amp; rhs)&#123;<br>		... <br>		<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>	&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="11：在operator-中处理“自我赋值”"><a href="#11：在operator-中处理“自我赋值”" class="headerlink" title="11：在operator&#x3D;中处理“自我赋值”"></a>11：在operator&#x3D;中处理“自我赋值”</h2><p>自我赋值发生在对象赋值给自己，这种情况可能会隐式发生。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// px和py指向同一个对象</span><br>*px = *py;<br></code></pre></td></tr></table></figure>

<p>为了防止自我赋值时销毁自身</p>
<p><strong>1、自我检验</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)&#123;<br>	<span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span> == &amp;rhs) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>	<span class="hljs-keyword">delete</span> pb;<br>	pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);<br>	<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 这样做存在潜在的隐患：如果new失败会导致pb指向一片被删除的Bitmap</p>
<p><strong>2、使用拷贝实现自我赋值</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)&#123;<br>	Bitmap* pOrig = pb;<br>	pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.bp);<br>	<span class="hljs-keyword">delete</span> pOrig;<br>	<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样即使new失败也能保证pb的指向是安全的。但是这样会导致多一次拷贝构造，影响效率。</p>
<p><strong>3、使用copy and swap技术</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>&#123;<br>	...<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Widget &amp;rhs)</span></span>;<br>	...<br>&#125;;<br>Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget &amp;rhs)&#123;<br>	 Widget <span class="hljs-built_in">temp</span>(rhs);<br>	 <span class="hljs-built_in">swap</span>(temp);<br>	 <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="12：复制对象时勿忘其每一个成分"><a href="#12：复制对象时勿忘其每一个成分" class="headerlink" title="12：复制对象时勿忘其每一个成分"></a>12：复制对象时勿忘其每一个成分</h2><p>为一个类增加一个成员变量，必须同时修改拷贝函数。</p>
<p>在继承类的拷贝函数中，必须小心的复制其基类的部分，通常它们是private的，需要通过派生类调用基类的拷贝构造函数&#x2F;拷贝赋值运算符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">PriorityCustomer::<span class="hljs-built_in">PriorityCustomer</span>(<span class="hljs-type">const</span> PriorityCustomer &amp;rhs)<br>	:<span class="hljs-built_in">Customer</span>(rhs), <span class="hljs-built_in">priority</span>(rhs.priority)<br>&#123;<br>	<span class="hljs-built_in">logCall</span>(<span class="hljs-string">&quot;PriorityCustomer copy constructor&quot;</span>);<br>&#125;<br>PriorityCustomer&amp; PriorityCustomer::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> PriorityCustomer &amp;rhs)&#123;<br>	<span class="hljs-built_in">logCall</span>(<span class="hljs-string">&quot;PriorityCustomer copy assignment operator&quot;</span>);<br>	Customer::<span class="hljs-keyword">operator</span>=(rhs);	<span class="hljs-comment">// 对基类成分进行赋值操作</span><br>	priority = rhs.priority;<br>	<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="13：以对象管理资源"><a href="#13：以对象管理资源" class="headerlink" title="13：以对象管理资源"></a>13：以对象管理资源</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//在工厂模式中</span><br><span class="hljs-function">Investment* <span class="hljs-title">createInvestment</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;<br>	Invesetment *pInv = <span class="hljs-built_in">creatInvestment</span>();<br>	... <span class="hljs-comment">// 可能存在过早的退出，或者异常</span><br>	<span class="hljs-keyword">delete</span> pInv;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>由于在…代码块中过早的退出，或者触发异常以及人为的遗忘delete到会导致内存泄漏。</p>
<p>为了确保<code>createInvestment()</code>返回的资源总是被释放，我们需要将资源放入对象内，依靠析构函数自动调用确保资源正确被释放（即为RAII对象）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">// 使用auto_ptr管理</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-function">std::auto_ptr&lt;Investment&gt; <span class="hljs-title">pInv</span><span class="hljs-params">(createInvestment())</span></span>;<br>	...	<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以对象管理资源的两个关键想法：</p>
<ul>
<li>获得资源后立即放入管理对象内。“以对象管理资源”的观念常被称为 RAII（Resource Acquisition Is Initialization);</li>
<li>管理对象运用析构函数确保资源被释放。</li>
</ul>
<p>由于<code>std::auto_ptr</code>不能同时指向同一个对象。如果通过copy构造函数或者copy assignmen操作符复制它们，它们将变成null</p>
<p>使用<code>std::shared_ptr</code>就不会有这个问题，因此建议使用<code>std::shared_ptr</code></p>
<h2 id="14：在资源管理类中小心copy行为"><a href="#14：在资源管理类中小心copy行为" class="headerlink" title="14：在资源管理类中小心copy行为"></a>14：在资源管理类中小心copy行为</h2><p>当需要建立自己的RAII对象时，需要明确对象被复制后发生的行为，多数情况下有以下两种选择：</p>
<ul>
<li><strong>禁止复制</strong>。许多时候允许RAII对象被复制并不合理。如果复制动作对RAII对象不合理，应该明确禁止；</li>
<li><strong>对底层资源使用引用计数法</strong>。当希望保有资源直到最后一个使用对象被销毁，这时候复制RAII对象应该将资源的引用计数递增；</li>
</ul>
<p>通常只需要内含一个<code>std::shared_ptr</code>成员变量，RAII类就可以实现引用计数复制行为。通过<strong>自定义<code>std::shared_ptr</code> 的删除器</strong>，就可以实现指定的删除。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lock</span><span class="hljs-params">(Mutex *pm)</span></span>;<span class="hljs-comment">// 锁住pm</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">(Mutex *pm)</span></span>; <span class="hljs-comment">// 解锁pm</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Lock</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// unlock是指定的删除器，mutexPtr析构函数将在引用计数为0时调用unlock</span><br>	<span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Lock</span><span class="hljs-params">(Mutex* pm)</span>:mutexPtr(pm, unlock)&#123;</span><br>		<span class="hljs-built_in">lock</span>(mutexPtr.<span class="hljs-built_in">get</span>());<br>	&#125;<br><span class="hljs-keyword">private</span>:<br>	std::shared_ptr&lt;Mutex&gt; mutexPtr;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>其它的选择：</p>
<ul>
<li>复制底部资源。在此情况下复制资源管理对象，应该同时复制其包含的资源。</li>
<li>转移底部资源的拥有权。在某些罕见场合下需要确保永远只有一个RAII对象指向一个未加工资源，即使发生了复制。如<code>std::auto_ptr</code></li>
</ul>
<h2 id="15：在资源管理类中提供对原始资源的访问"><a href="#15：在资源管理类中提供对原始资源的访问" class="headerlink" title="15：在资源管理类中提供对原始资源的访问"></a>15：在资源管理类中提供对原始资源的访问</h2><p>有些时候需要直接访问原始资源，需要有一个函数将RAII对象转化为原始资源，通过以下两个方法：</p>
<p><strong>1、显示转化：</strong></p>
<p>如<code>std::shared_ptr</code>提供了<code>get()</code>成员函数，用来执行显示转化。</p>
<p><strong>2、隐式转化：</strong></p>
<p><code>std::shared_ptr</code>同时重载了操作符operator-&gt;和operator*，它们允许隐式转化至底部原始指针。</p>
<p>有时还是必须取得RAII对象内的原始资源，提供隐式转换函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">FontHandle <span class="hljs-title">getFont</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">releaseFont</span><span class="hljs-params">(FontHandle fh)</span></span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Font</span>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Font</span><span class="hljs-params">(FontHandle fh)</span>:f(fh)&#123;</span>&#125;<br>	~<span class="hljs-built_in">Font</span>()&#123;<br>		<span class="hljs-built_in">releaseFont</span>(f);<br>	&#125;<br>	<span class="hljs-comment">// 显示转化函数</span><br>	<span class="hljs-function">FontHandle <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> f;<br>	&#125;<br>	<span class="hljs-comment">// 隐式转化函数</span><br>	<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">FontHandle</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> f;<br>	&#125;<br><span class="hljs-keyword">private</span>:<br>	FontHandle f;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>但是隐式转化函数会增加错误发生的机率。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Font <span class="hljs-title">f1</span><span class="hljs-params">(getFont())</span></span>;<br>...<br>FontHandle f2 = f1; <span class="hljs-comment">// 将f1隐式转化为FontHandle后复制它</span><br></code></pre></td></tr></table></figure>

<p>当f1被销毁，字体释放，f2就会成为悬垂的。</p>
<p>​                                                                  </p>
<h2 id="16：成对使用new和delete时要采取相同形式"><a href="#16：成对使用new和delete时要采取相同形式" class="headerlink" title="16：成对使用new和delete时要采取相同形式"></a>16：成对使用new和delete时要采取相同形式</h2><p>使用new，有两件事发生。第一，内存被名为operator new的函数分配出来；第二，针对内存会有构造函数被调用。对于delete，先调用析构函数，然后使用operator delete释放内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string *stringPtr1 = <span class="hljs-keyword">new</span> std::string;<br>std::string *stringPtr2 = <span class="hljs-keyword">new</span> std::string[<span class="hljs-number">100</span>];<br>...<br><span class="hljs-keyword">delete</span> stringPtr1;<br><span class="hljs-comment">//delete [] stringptr1  错误，未定义的行为 </span><br><span class="hljs-keyword">delete</span> [] stringPtr2;<br><span class="hljs-comment">//delete stringPtr2;  错误，未定义的行为</span><br></code></pre></td></tr></table></figure>

<p>如果调用new时使用[],必须在delete时也使用[]，反之亦然。</p>
<h2 id="17：以独立语句将newed对象置入智能指针"><a href="#17：以独立语句将newed对象置入智能指针" class="headerlink" title="17：以独立语句将newed对象置入智能指针"></a>17：以独立语句将newed对象置入智能指针</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">// 说明C++参数的构建顺序是不确定的</span><br><span class="hljs-comment">// 函数定义</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">priority</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processWidget</span><span class="hljs-params">(std::shared_ptr&lt;Widget&gt; pw, <span class="hljs-type">int</span> priority)</span></span>;<br><br><span class="hljs-comment">// 调用</span><br><span class="hljs-comment">//processWidget(new Widget, priority());// 调用将失败，由于不存在Widget*到std::shared_ptr&lt;Widget&gt; </span><br><span class="hljs-built_in">processWidget</span>(std::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;(<span class="hljs-keyword">new</span> Widet), <span class="hljs-built_in">priority</span>());<span class="hljs-comment">// 成功的调用，但是可能导致资源泄露</span><br></code></pre></td></tr></table></figure>

<p>执行上面的函数有三件事：1、调用new Widget 2、调用<code>std::shared_ptr</code>构造函数 3、 调用priority()</p>
<p>但是它们的顺序确是不确定的，存在new Widget调用后，再调用priority()导致异常，从而智能指针接受不到的情况。</p>
<p>解决的方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-comment">// 先创建Widget放入智能指针，再作为参数</span><br><span class="hljs-function">std::shared_ptr&lt;Widget&gt; <span class="hljs-title">pw</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget)</span></span>;<br><span class="hljs-built_in">processWidget</span>(pw, <span class="hljs-built_in">priority</span>());<br></code></pre></td></tr></table></figure>



<h2 id="18：让接口容易被正确使用，不易被误用"><a href="#18：让接口容易被正确使用，不易被误用" class="headerlink" title="18：让接口容易被正确使用，不易被误用"></a>18：让接口容易被正确使用，不易被误用</h2><h2 id="19：设计class犹如设计type"><a href="#19：设计class犹如设计type" class="headerlink" title="19：设计class犹如设计type"></a>19：设计class犹如设计type</h2><p>C++中，当你定义了一个新class，也就定义了一个新type。如何设计高效的类，必须了解下面的问题：</p>
<ul>
<li>新type的对象应该如何被创建和销毁？</li>
<li>对象的初始化和对象的赋值该有什么样的差别？</li>
<li>新type的对象如果被passed by value，意味着什么？</li>
<li>什么是新type的“合法值”</li>
<li>你的新type需要配合某个继承系吗？</li>
<li>你的新type需要什么样的转化？</li>
<li>什么样的操作符和函数对此新type而言是合理的？</li>
<li>什么样的标准函数应该驳回？</li>
<li>谁该取用新的type成员？</li>
<li>什么是新type的“未声明接口”？</li>
<li>新type有多么一般化？</li>
<li>你真需要一个新type吗？</li>
</ul>
<h2 id="20：宁以pass-by-reference-to-const替换pass-by-value"><a href="#20：宁以pass-by-reference-to-const替换pass-by-value" class="headerlink" title="20：宁以pass-by-reference-to-const替换pass-by-value"></a>20：宁以pass-by-reference-to-const替换pass-by-value</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Person</span>();<br>	<span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Person</span>();<br><span class="hljs-keyword">private</span>:<br>	std::string name; <span class="hljs-comment">// 成员变量</span><br>	std::string address;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>: <span class="hljs-keyword">public</span> Person&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Student</span>();<br>	~<span class="hljs-built_in">Student</span>();<br><span class="hljs-keyword">private</span>:<br>	std::string schoolName;   <span class="hljs-comment">// 成员变量</span><br>	std::string schoolAddress;<br>&#125;;<br><span class="hljs-comment">// 调用</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">validateStudent</span><span class="hljs-params">(Student s)</span></span>;<span class="hljs-comment">// 函数声明</span><br>Student plato;<br><span class="hljs-type">bool</span> platoIsOk = <span class="hljs-built_in">validateStudent</span>(plato); <span class="hljs-comment">// 以pass by value方式调用函数</span><br></code></pre></td></tr></table></figure>

<p>使用by value方式会导致一次Student拷贝构造，一次Person拷贝构造，四次string拷贝构造，六次析构函数！</p>
<p>而使用传递<strong>const引用参数能够避免这些构造和析构</strong>动作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">validateStudent</span><span class="hljs-params">(<span class="hljs-type">const</span> Student&amp; s)</span></span>;<br></code></pre></td></tr></table></figure>

<p>使用引用作为参数同时可以避免对象切割的问题</p>
<blockquote>
<p>对象切割：当继承类对象以值传递方式被视为基类对象，基类构造函数将被调用，造成继承类的特化性质被切割，仅仅留下一个基类对象。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window</span>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function">std::string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WindowWithScrollBars</span>: <span class="hljs-keyword">public</span> Window&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br><span class="hljs-comment">// 打印函数               使用const Window&amp; w参数就不会被切割</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printNameAndDisplay</span><span class="hljs-params">(Window w)</span></span>&#123;<br>    std::cout&lt;&lt;w.<span class="hljs-built_in">name</span>();<br>    w.<span class="hljs-built_in">display</span>();<br>&#125;<br><span class="hljs-comment">// 传递WindowWithScrollBars</span><br>WindowWithScrollBars wwsb;<br><span class="hljs-built_in">printNameAndDisplay</span>(wwsb);<span class="hljs-comment">// 总是调用Window::display</span><br></code></pre></td></tr></table></figure>

<p>一般而言，可以合理假设”pass by value”并不昂贵的对象为内置类型，STL迭代器和函数对象，其它都需要传递常量引用。</p>
<h2 id="21：必须返回对象时，别妄想返回其reference"><a href="#21：必须返回对象时，别妄想返回其reference" class="headerlink" title="21：必须返回对象时，别妄想返回其reference"></a>21：必须返回对象时，别妄想返回其reference</h2><p>并不是所有情况传递引用都是合理的。任何情况下看到一个reference声明式，都应该询问它的另一个名字是什么？</p>
<p>函数中创建新对象的途径有两种：在stack空间或者在heap空间创建。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 尝试在栈空间创建对象并返回引用，错误！</span><br><span class="hljs-type">const</span> Rational&amp; <span class="hljs-keyword">operator</span>* (<span class="hljs-type">const</span> Rational &amp;lhs, <span class="hljs-type">const</span> Rational &amp;rhs)&#123;<br>	<span class="hljs-function">Rational <span class="hljs-title">result</span><span class="hljs-params">(lhs.n * rhs.n, lhs.d * rhs.d)</span></span>;<br>	<span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>local对象将在函数返回前销毁，其引用将无定义。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 尝试在堆空间创建对象并返回引用，同样错误！</span><br><span class="hljs-type">const</span> Rational&amp; <span class="hljs-keyword">operator</span>* (<span class="hljs-type">const</span> Rational &amp;lhs, <span class="hljs-type">const</span> Rational &amp;rhs)&#123;<br>	Rational *result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Rational</span>(lhs.n * rhs.n, lhs.d * rhs.d);<span class="hljs-comment">// 内存泄露</span><br>	<span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>没有办法取得reference背后的隐藏指针，导致无法释放new开辟的内存空间。</p>
<p>一个必须返回新对象的函数就应该让函数返回一个新对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 正确的写法</span><br><span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>* (<span class="hljs-type">const</span> Rational &amp;lhs, <span class="hljs-type">const</span> Rational &amp;rhs)&#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(lhs.n * rhs.n, lhs.d * rhs.d);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在现在的编译器中：编译器会进行RVO&#x2F;NRVO优化，直接构造出返回的对象，避免了拷贝构造。</p>
<h2 id="22：将成员变量声明为private"><a href="#22：将成员变量声明为private" class="headerlink" title="22：将成员变量声明为private"></a>22：将成员变量声明为private</h2><ul>
<li><p>语法一致性：客户唯一访问对象的方法就是通过成员函数。</p>
</li>
<li><p>实现访问控制：如果将成员变量声明为public，每个人都能读写；声明为private变量，通过成员函数来取得设定其值，可以实现“出准访问”，“只读访问”，“读写访问”。</p>
</li>
<li><p>封装：隐藏成员变量，只有成员函数可以影响它们，保留了日后变更实现的权利。如果不隐藏它们，当改变public类型变量将破坏大多数客户代码。从封装的角度观察：只有两种访问权限：private（提供封装）和其他（不提供封装）。</p>
</li>
</ul>
<h2 id="23：宁以non-member、non-friend替换member函数"><a href="#23：宁以non-member、non-friend替换member函数" class="headerlink" title="23：宁以non-member、non-friend替换member函数"></a>23：宁以non-member、non-friend替换member函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WebBrowser</span>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearCache</span><span class="hljs-params">()</span></span>;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearHistory</span><span class="hljs-params">()</span></span>;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeCookies</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// 成员函数一次性调用清理</span><br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearEverything</span><span class="hljs-params">()</span></span>&#123;<br>		<span class="hljs-built_in">clearCache</span>();<br>		<span class="hljs-built_in">clearHistory</span>();<br>		<span class="hljs-built_in">removeCookies</span>();<br>	&#125;<br>&#125;;<br><span class="hljs-comment">// 非成员函数一次性调用清理</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearBrowser</span><span class="hljs-params">(WebBrowser &amp;wb)</span></span>&#123;<br>	wb.<span class="hljs-built_in">clearCache</span>();<br>	wb.<span class="hljs-built_in">clearHistory</span>();<br>	wb.<span class="hljs-built_in">removeCookies</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>采用哪一个版本的函数更好？</p>
<p>从封装的角度考虑：如果某些东西额被封装，它就不在可见。愈多的东西被封装，愈少的人能够看见。我们就能有愈大的弹性来改变它。我们计算能够访问数据的函数的数量，作为粗糙的度量。<strong>愈多的函数可访问它，数据的封装性愈低。</strong></p>
<p>因此：由于能够访问private成员变量的函数只有类的成员函数和友元函数，提供较大封装性的是non-member non-friend函数。</p>
<p>值得注意的是，只在意封装性让函数成为class的non-member并不意味着它不可以是另一个class的member</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 让non-member函数位于class的同一个命名空间</span><br><span class="hljs-keyword">namespace</span> WebBrowserStuff&#123;<br>	<span class="hljs-keyword">class</span> <span class="hljs-title class_">WebBrowser</span>&#123; ... &#125;;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearBrowser</span><span class="hljs-params">(WebBrowser &amp;wb)</span></span>;<br>&#125;<br><span class="hljs-comment">// 头文件&quot;webbrowserbookmarks.h&quot;</span><br><span class="hljs-keyword">namespace</span> WebBrowserStuff&#123;<br>    ...<span class="hljs-comment">// 与书签相关的便利函数</span><br>&#125;<br><span class="hljs-comment">// 头文件“webbrowsercookies.h&quot;</span><br><span class="hljs-keyword">namespace</span> WebBrowserStuff&#123;<br>    ...<span class="hljs-comment">// 与cookie相关的便利函数</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>将所有便利函数放在多个头文件内但属于同一个命名空间，意味着客户可以轻松拓展便利函数。通过添加更多的non-member non-friend函数到此命名空间。</p>
<h2 id="24：若所有参数皆需类型转换，请为此采用non-member函数"><a href="#24：若所有参数皆需类型转换，请为此采用non-member函数" class="headerlink" title="24：若所有参数皆需类型转换，请为此采用non-member函数"></a>24：若所有参数皆需类型转换，请为此采用non-member函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-comment">// 将operator*写成成员函数的写法</span><br>	<span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>* (<span class="hljs-type">const</span> Rational &amp;rhs) <span class="hljs-type">const</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>当需要混合运算就会出现错误</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Ratinoal <span class="hljs-title">oneHalf</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>Rational result = oneHalf * <span class="hljs-number">2</span>;<span class="hljs-comment">// 正确 2被隐式类型转化了</span><br>Rational result = <span class="hljs-number">2</span> * oneHalf;<span class="hljs-comment">// 错误 2不在*参数内，不能隐式转化</span><br></code></pre></td></tr></table></figure>

<p>只有当参数被列于参数列内，这个参数才是隐式类型转化的合格参与者。</p>
<p>将operator*成为一个non-member函数，让编译器在每一个实参上进行隐式类型转化：</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs julia"><span class="hljs-keyword">const</span> <span class="hljs-built_in">Rational</span> operator*(<span class="hljs-keyword">const</span> <span class="hljs-built_in">Rational</span>&amp; lhs, <span class="hljs-keyword">const</span> <span class="hljs-built_in">Rational</span> &amp;rhs)&#123;<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(lhs.numerator() * rhs.numerator(), lhs.denominator() * rhs.denominator());<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Rational result <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * oneHalf<span class="hljs-comment">;// 这样就能通过编译了</span><br></code></pre></td></tr></table></figure>

<p>本例中operator操作都能够通过共有接口来实现，因此就不需要将这个函数声明为friend函数了。</p>
<h2 id="25：考虑写出一个不抛出异常的swap函数"><a href="#25：考虑写出一个不抛出异常的swap函数" class="headerlink" title="25：考虑写出一个不抛出异常的swap函数"></a>25：考虑写出一个不抛出异常的swap函数</h2><p>当</p>
<h2 id="26：尽可能延后变量定义式出现的时间"><a href="#26：尽可能延后变量定义式出现的时间" class="headerlink" title="26：尽可能延后变量定义式出现的时间"></a>26：尽可能延后变量定义式出现的时间</h2><p>不应该只延后变量的定义，尝试延后定义直到能够赋予它初值为止。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 对于下面两个方法</span><br><span class="hljs-comment">// 方法A：定义在循环外</span><br>Widget w;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)&#123;<br>	w = 取决于i的值；<br>&#125;<br><span class="hljs-comment">// 方法B：定义于循环内</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)&#123;<br>	Widget <span class="hljs-built_in">w</span>(取决于i的值);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>除非效率优先否则应该尽量使用方法B。</p>
<h2 id="27：尽量少做转型动作"><a href="#27：尽量少做转型动作" class="headerlink" title="27：尽量少做转型动作"></a>27：尽量少做转型动作</h2><h2 id="28：避免返回handles指向对象内部部分"><a href="#28：避免返回handles指向对象内部部分" class="headerlink" title="28：避免返回handles指向对象内部部分"></a>28：避免返回handles指向对象内部部分</h2><h2 id="29：为”异常安全“而努力是值得的"><a href="#29：为”异常安全“而努力是值得的" class="headerlink" title="29：为”异常安全“而努力是值得的"></a>29：为”异常安全“而努力是值得的</h2><h2 id="30：透彻了解inlining的里里外外"><a href="#30：透彻了解inlining的里里外外" class="headerlink" title="30：透彻了解inlining的里里外外"></a>30：透彻了解inlining的里里外外</h2><p>在做出任何有关inline的决定之前，都应该注意这个条款。</p>
<h2 id="31：将文件间的编译依存关系降至最低"><a href="#31：将文件间的编译依存关系降至最低" class="headerlink" title="31：将文件间的编译依存关系降至最低"></a>31：将文件间的编译依存关系降至最低</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jerry19880126/p/3551836.html">读书笔记_Effective_C++_条款三十一：将文件间的编译依存关系降至最低（第一部分） - Jerry19880126 - 博客园 (cnblogs.com)</a></p>
<h2 id="32：确定你的public继承塑模出is-a关系"><a href="#32：确定你的public继承塑模出is-a关系" class="headerlink" title="32：确定你的public继承塑模出is-a关系"></a>32：确定你的public继承塑模出is-a关系</h2><h2 id="33：避免遮掩继承而带来的名称"><a href="#33：避免遮掩继承而带来的名称" class="headerlink" title="33：避免遮掩继承而带来的名称"></a>33：避免遮掩继承而带来的名称</h2><h2 id="34：区分接口继承和接口实现"><a href="#34：区分接口继承和接口实现" class="headerlink" title="34：区分接口继承和接口实现"></a>34：区分接口继承和接口实现</h2><h2 id="35：考虑virtual函数以外的其它选择"><a href="#35：考虑virtual函数以外的其它选择" class="headerlink" title="35：考虑virtual函数以外的其它选择"></a>35：考虑virtual函数以外的其它选择</h2><h2 id="36：绝不重新定义继承而来的non-virtual函数"><a href="#36：绝不重新定义继承而来的non-virtual函数" class="headerlink" title="36：绝不重新定义继承而来的non-virtual函数"></a>36：绝不重新定义继承而来的non-virtual函数</h2><h2 id="37：绝不重新定义继承而来的缺省参数值"><a href="#37：绝不重新定义继承而来的缺省参数值" class="headerlink" title="37：绝不重新定义继承而来的缺省参数值"></a>37：绝不重新定义继承而来的缺省参数值</h2><h2 id="38：通过复合塑模出has-a或”根据某物实现出“"><a href="#38：通过复合塑模出has-a或”根据某物实现出“" class="headerlink" title="38：通过复合塑模出has-a或”根据某物实现出“"></a>38：通过复合塑模出has-a或”根据某物实现出“</h2><p>复合是类型之间的一种关系，当某种类型的对象内含它种类型对象就是复合。</p>
<p>复合同义词：分层、内含、聚合、内嵌。</p>
<p>复合有两个意义：意味着<strong>has-a</strong>或者<strong>根据某物实现出</strong></p>
<p>区分is-a和根据某物实现出</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 例如set可以根据一个list实现</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Set</span>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">member</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;item)</span> <span class="hljs-type">const</span></span>;<br>	...<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-comment">// 内含list，根据list实现</span><br>	std::list&lt;T&gt; rep;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="39：明智而审慎地使用private继承"><a href="#39：明智而审慎地使用private继承" class="headerlink" title="39：明智而审慎地使用private继承"></a>39：明智而审慎地使用private继承</h2><h2 id="40：明智而审慎地使用多重继承"><a href="#40：明智而审慎地使用多重继承" class="headerlink" title="40：明智而审慎地使用多重继承"></a>40：明智而审慎地使用多重继承</h2>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Effective C++</div>
      <div>http://example.com/2024/07/31/Effective/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年7月31日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/07/31/c++/" title="c++">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">c++</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/07/31/Qt/" title="Qt">
                        <span class="hidden-mobile">Qt</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"lRNjMHJuYBjEDxG7qZ3nMGPi-gzGzoHsz","appKey":"SAOxud4u65tFtKVuwrFrHaQN","path":"window.location.pathname","placeholder":"说点什么吧","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
